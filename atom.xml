<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xuhongbo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xuhongbo.com/"/>
  <updated>2017-03-02T17:32:52.000Z</updated>
  <id>http://xuhongbo.com/</id>
  
  <author>
    <name>xuhongbo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在github pages利用hexo快速搭建静态个人主页以及更改域名</title>
    <link href="http://xuhongbo.com/2017/01/18/%E5%B7%A5%E5%85%B7%E7%B1%BB/%E5%9C%A8github%20pages%E5%88%A9%E7%94%A8hexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%E4%BB%A5%E5%8F%8A%E6%9B%B4%E6%94%B9%E5%9F%9F%E5%90%8D/"/>
    <id>http://xuhongbo.com/2017/01/18/工具类/在github pages利用hexo快速搭建静态个人主页以及更改域名/</id>
    <published>2017-01-18T06:41:30.000Z</published>
    <updated>2017-03-02T17:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>github pages是一种提供免费托管静态页面的工具，可以免费作为我们的个人主页进行使用<br><a id="more"></a></p><p><a href="https://pages.github.com/" target="_blank" rel="noopener">官方地址</a></p><p>既然知道工具是做什么的了，下面我们就开始进行操作吧</p><h6 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h6><ol><li>首先你要确保的是你有一个github账号 <a href="https://github.com/" target="_blank" rel="noopener">传送门</a></li><li>还要确保你的电脑上有安装有git</li><li>最后还要有nodejs</li></ol><p>###在github上申请github pages空间<br>如果你已经看到这了  我已经默认你具备了上面的三个条件了！<br>如果你看了上面的介绍 你应该已经知道了怎么去申请这个空间了 但是为了避免有的人还是犯迷糊我下面还是讲一下怎么申请这个github pages空间吧，避免第一步就卡死这<br>登陆我们的github</p><p>点击这里新建一个仓储</p><p><img src="/images/github0.png" alt="img"></p><p>然后我们到了这个页面  我们按照我写的这个顺序进行操作</p><p><img src="/images/github2.png" alt="img">我们的仓储名格式是xxx.github.io<br>然后选择public<br>然后选择同意 就可以了</p><p>然后我们这个仓储就创建好了，图中的地址一定要记好，后面我们就有用了</p><p><img src="/images/github4.png" alt="img"></p><h3 id="安装hexo以及初始化"><a href="#安装hexo以及初始化" class="headerlink" title="安装hexo以及初始化"></a>安装hexo以及初始化</h3><h5 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h5><p>首先你可以自己看看hexo的官网 <a href="https://hexo.io/" target="_blank" rel="noopener">传送门</a><br>首先在全局安装hexo的脚手架在cmd命令行中输入 <code>$ npm install hexo-cli -g</code> </p><p>等我们在全局安装好以后，找到你想放置你博客文件的目录 然后执行<code>hexo init blogName</code> 执行初始化操作</p><p><img src="/images/HEXO1.png" alt="img"></p><p>然后我们就在本地有了一个blog的文件夹，然后我们输入<code>cd blogName</code> 然后执行<code>hexo server</code>就可以在本地看到你的blog了，但是显然只是本地，你并不满足</p><p><img src="/images/HEXO2.png" alt="img"></p><p>看到这里  你是不是感觉很简单呀</p><p>对 就是这么简单</p><p>下面我们要做的就是往我们的git仓库里面进行push了</p><p>在hexo这个工具中我们可以直接配置我们的git地址</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">//格式如下 https://账户:密码@你的仓储地址，也就是上面要你记住的地址</span><br><span class="line">  repo: https://账户:密码@github.com/xuhongbo/xuhongbo.github.io.git</span><br></pre></td></tr></table></figure><p>在你执行过上面那一步之后  你就离成功只剩一步了</p><p>下面我们再安装一个插件<code>npm install hexo-deployer-git --save</code>当然了，这个操作也是在我们的项目根目录中</p><p>然后就可以进行发布了<code>hexo generate --deploy</code></p><p><img src="/images/HEXO5.png" alt="img"></p><p>至此 你已经可以在你的github pages上看到你的个人博客了</p><p>如果你没有绑定个人域名的需求，就这样就不用往下面看了</p><h3 id="绑定个人域名"><a href="#绑定个人域名" class="headerlink" title="绑定个人域名"></a>绑定个人域名</h3><p>首先我们要有一个域名，如果没有的话，自己想办法哈，这个我是帮不了你</p><p>我在这里说一下怎么配dns和hexo中加入CNAME这两件事</p><p>在这里我拿万网作为例子</p><p>在dns解析中我们加入以下三条记录</p><p>分别是两条github pages ip 和一条你的github pages地址名如<code>xxx.github.io.</code>注意哈，最后的那个点千万别忘了</p><p><img src="/images/wanwang.png" alt="img"></p><p>然后下面添加CNAME文件加入source文件夹中，然后在此文件中写入你的域名记住不带前面的http什么鬼的 只要 express.com 这一段然后再执行一次 <code>hexo generate --deploy</code>  </p><p><img src="/images/CNAME.png" alt="img"><img src="/images/CNAME2.png" alt="img"></p><p>嗯 所有工作已经做完了  你现在出去溜达一会  等个十来分钟  就可以访问了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;github pages是一种提供免费托管静态页面的工具，可以免费作为我们的个人主页进行使用&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS运算符</title>
    <link href="http://xuhongbo.com/2017/01/08/JavaScript/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://xuhongbo.com/2017/01/08/JavaScript/运算符/</id>
    <published>2017-01-08T07:02:02.000Z</published>
    <updated>2017-03-02T17:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>程序中最简单的表达式就是，程序中的常量</li><li>变量名也是一种简单的表达式</li><li>复杂的表达式是由简单的表达式组成的</li><li>函数调用表达式是由函数对象的表达式和0个或多个参数表达式构成</li><li>可以使用运算符来将简单的表达式来组合成复杂的表达式<a id="more"></a><h2 id="原始表达式"><a href="#原始表达式" class="headerlink" title="原始表达式"></a>原始表达式</h2></li></ul><p>“原始表达式”，说简单点就是最简单的表达式，并且不再包含其他表达式   </p><blockquote><p>js中原始表达式有以下：</p><ul><li>常量</li><li>直接量</li><li>关键字</li><li>变量</li></ul><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; //直接量          </span><br><span class="line">&gt; 1.23 // 数字直接量</span><br><span class="line">&gt; &quot;hello&quot; // 字符串直接量</span><br><span class="line">&gt; /pattern/ // 正则表达式直接</span><br><span class="line">&gt; //保留字   </span><br><span class="line">&gt; true</span><br><span class="line">&gt; false</span><br><span class="line">&gt; null // 返回空</span><br><span class="line">&gt; this // 返回“当前对象”</span><br><span class="line">&gt; //变量         </span><br><span class="line">&gt; i // 返回i的值</span><br><span class="line">&gt; sum // 返回sum的值</span><br><span class="line">&gt; undefined // undefined是全局变量，和null不同，不是一个关键字</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="对象和数组的初始化表达式"><a href="#对象和数组的初始化表达式" class="headerlink" title="对象和数组的初始化表达式"></a>对象和数组的初始化表达式</h2><p>对象和数组的初始化表达式实际上是一个新创建的对象和数组，并不是原始表达式</p><h3 id="数组初始化表达式"><a href="#数组初始化表达式" class="headerlink" title="数组初始化表达式"></a>数组初始化表达式</h3><blockquote><p>栗子:</p><ul><li><code>[] //空数组</code></li><li><code>[1+2,3+4] // 2个元素数组 [3,7]</code></li><li><code>var matrix = [[1,2],[3,4]]  // 数组可嵌套</code></li></ul></blockquote><p>js对数组初始化表达式进行求值时候，数组表达式中的所有元素表达式也会各自计算一次</p><p>数组直接量的元素表达式在逗号之间元素可以省略，空位默认填充undefined。<br><code>var array = [1,,3] // 数组包含3个元素。[1,undefined,3]</code></p><p>但是列表结尾处可以留下单个逗号，这时不会创建新的undefined元素</p><h3 id="对象初始化表达式"><a href="#对象初始化表达式" class="headerlink" title="对象初始化表达式"></a>对象初始化表达式</h3><p>对象初始化表达式与数组初始化表达式非常接近，将[]替换成{},每个子表达式都包含一个属性名和冒号为前缀</p><blockquote><p>栗子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; var p = &#123; x:2, y:3 &#125;; // 带2个属性的对象p</span><br><span class="line">&gt; var q = &#123;&#125;; // 空对象</span><br><span class="line">&gt; q.x = 2; q.y =3; // q的属性成员与p一致</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>对象直接量也是允许嵌套的</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; var rect = &#123;</span><br><span class="line">&gt;   upLeft: &#123; x:2, y:3&#125;,</span><br><span class="line">&gt;   bottomRight: &#123; x:4, y:1&#125;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>js求对象初始化表达式时候，对象元素表达式也会各自都计算一次，并且元素表达式不必包含常数值，可以是<br>任意的js表达式。</p><p>对象直接量中属性的名字可以是字符串而不是标示符</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; var side = 1;</span><br><span class="line">&gt; var square = &#123;</span><br><span class="line">&gt;   &quot;upLeft&quot;: &#123; x: p.x, y: p.y&#125;,</span><br><span class="line">&gt;   &quot;bottomRight&quot;: &#123;x: p.x+side, y: p.y+side&#125;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><p>函数定义表达式定义一个js函数，表达式的值是这个新定义的函数。如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var square = function (x)&#123;</span><br><span class="line">  return x * x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="属性访问表达式"><a href="#属性访问表达式" class="headerlink" title="属性访问表达式"></a>属性访问表达式</h2><p>属性访问表达式得到一个对象属性或一个数组元素的值。主要有<code>.</code>和<code>[]</code>两种形式</p><blockquote><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; var o = &#123; x:1, y:&#123; z:3 &#125; &#125;;</span><br><span class="line">&gt; var a = [o, 4, [5,6]];</span><br><span class="line">&gt; o.x // =&gt;1 表达式o的x属性</span><br><span class="line">&gt; o.y.z // =&gt;3 表达式o.y的z属性</span><br><span class="line">&gt; o[&quot;x&quot;] // =&gt;1 表达式o的x属性</span><br><span class="line">&gt; a[1] // =&gt;4 表达式a的索引为1的元素</span><br><span class="line">&gt; a[2][&quot;1&quot;] // =&gt;6 表达式a[2] 的索引为1的元素</span><br><span class="line">&gt; a[0].x // =&gt;1 表达式a[0]的x属性</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>在<code>.</code> 和 <code>[]</code>之前的表达式总会首先计算。如果计算出结果为null 或者 undefined，表达式会抛出类型错误异常。<br>如果运算结果不是对象或者数组，js会将其转换为对象。</p><p>如果对象表达式后面跟随句点和标示符，则会查找由这个标示符所指定的属性的值，然后作为整个表达式的值返回。</p><p>如果表达式后面跟随一对括号，则会计算方括号里面表达式值并转换为字符串，然后查找对应属性的值</p><p>如果以上两种情况，命名属性并不存在，则整个属性访问表达式的值就是undefined</p><ul><li><code>.</code>写法适合要访问的属性名是合法标示符，并且需要知道要访问属性名字</li><li><code>[]</code> 写法适合要访问的属性名不是合法字符，或者访问的属性名是需要运算得出的。对于数组则必须使用这种写法</li></ul><h2 id="调用表达式"><a href="#调用表达式" class="headerlink" title="调用表达式"></a>调用表达式</h2><p>js调用表达式，是一种调用（执行）函数或方法的语法。如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func(0) // f是一个函数表达式，0是一个参数表达式</span><br><span class="line">Math.max(x,y,z) // Math.max是一个函数，x,y,z是参数</span><br><span class="line">a.sort() // a.sort是一个函数。没有参数</span><br></pre></td></tr></table></figure><p>对调用表达式进行求值时候，首先计算函数表达式，然后计算参数表达式，得到一组参数值。</p><p>如果函数表达式不是一个可以调用的对象，会抛出类型错误异常</p><p>如果函数表达式使用return语句返回一个值，那么这个值就是整个调用表达式的值，否则表达式的值就是undefined</p><h2 id="对象创建表达式"><a href="#对象创建表达式" class="headerlink" title="对象创建表达式"></a>对象创建表达式</h2><p>对象创建表达式，顾名思义，就是创建一个对象，并且调用一个函数，初始化新对象的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Object()</span><br><span class="line">new Point(2,6)</span><br></pre></td></tr></table></figure><p>如果一个对象创建表达式不需要传入任何参数给构造函数，那么空括号可以省略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Object</span><br><span class="line">new Date</span><br></pre></td></tr></table></figure><h2 id="运算符概述"><a href="#运算符概述" class="headerlink" title="运算符概述"></a>运算符概述</h2><p>大多数运算符都是由标点符号表示的，如”+”,”=”。而另外一些运算符则是由关键字表示的，比如delete和instanceof。</p><p>优先级从高到低，虚线分割开的运算符不同优先级。</p><table><thead><tr><th>运算符</th><th>操作</th><th>结合性</th><th>操作数个数</th><th>类型</th></tr></thead><tbody><tr><td>++</td><td>前/后增量</td><td>R</td><td>1</td><td>lval =&gt; num</td></tr><tr><td>–</td><td>前/后减量</td><td>R</td><td>1</td><td>lval =&gt; num</td></tr><tr><td>-</td><td>求反</td><td>R</td><td>1</td><td>num =&gt; num</td></tr><tr><td>+</td><td>转换为数字</td><td>R</td><td>1</td><td>num =&gt; num</td></tr><tr><td>~</td><td>按位求反</td><td>R</td><td>1</td><td>int =&gt; int</td></tr><tr><td>!</td><td>逻辑非</td><td>R</td><td>1</td><td>bool =&gt; bool</td></tr><tr><td>delete</td><td>删除属性</td><td>R</td><td>1</td><td>lval =&gt; bool</td></tr><tr><td>typeof</td><td>检测操作数类型</td><td>R</td><td>1</td><td>any =&gt; str</td></tr><tr><td>void</td><td>返回undefined</td><td>R</td><td>1</td><td>any =&gt; undef</td></tr><tr><td>—————</td><td>—————</td><td>—</td><td>–</td><td>———</td></tr><tr><td>*,/,%</td><td>乘、除、取余</td><td>L</td><td>2</td><td>num,num =&gt; num</td></tr><tr><td>—————</td><td>—————</td><td>—</td><td>–</td><td>———</td></tr><tr><td>+、-</td><td>加、减</td><td>L</td><td>2</td><td>num,num =&gt; num</td></tr><tr><td>+</td><td>字符串连接</td><td>L</td><td>2</td><td>str,str =&gt; str</td></tr><tr><td>—————</td><td>—————</td><td>—</td><td>–</td><td>———</td></tr><tr><td>&lt;&lt;</td><td>左移位</td><td>L</td><td>2</td><td>int,int =&gt; int</td></tr><tr><td>&gt;&gt;</td><td>无符号右移位</td><td>L</td><td>2</td><td>int,int =&gt; int</td></tr><tr><td>&gt;&gt;&gt;</td><td>有符号右移位</td><td>L</td><td>2</td><td>int,int =&gt; int</td></tr><tr><td>—————</td><td>—————</td><td>—</td><td>–</td><td>———</td></tr><tr><td>&lt;,&lt;=,&gt;,&gt;=</td><td>比较数字顺序</td><td>L</td><td>2</td><td>num,num =&gt; bool</td></tr><tr><td>&lt;,&lt;=,&gt;,&gt;=</td><td>比较在字母表顺序</td><td>L</td><td>2</td><td>str,str =&gt; bool</td></tr><tr><td>instanceof</td><td>测试对象类</td><td>L</td><td>2</td><td>obj,func =&gt; bool</td></tr><tr><td>in</td><td>测试属性是否存在</td><td>L</td><td>2</td><td>str,obj =&gt; bool</td></tr><tr><td>——————–</td><td>—————</td><td>—</td><td>–</td><td>———</td></tr><tr><td>==</td><td>判断相等</td><td>L</td><td>2</td><td>any,any   =&gt;bool</td></tr><tr><td>!=</td><td>判断不等</td><td>L</td><td>2</td><td>any,any =&gt; bool</td></tr><tr><td>===</td><td>判断恒等</td><td>L</td><td>2</td><td>any,any =&gt; bool</td></tr><tr><td>!==</td><td>判断非恒等</td><td>L</td><td>2</td><td>any,any =&gt; bool</td></tr><tr><td>—————</td><td>—————</td><td>—</td><td>–</td><td>———</td></tr><tr><td>&amp;</td><td>按位与</td><td>L</td><td>2</td><td>int,int =&gt; int</td></tr><tr><td>—————</td><td>—————</td><td>—</td><td>–</td><td>———</td></tr><tr><td>^</td><td>按位异或</td><td>L</td><td>2</td><td>int,int =&gt; int</td></tr><tr><td>—————</td><td>—————</td><td>—</td><td>–</td><td>———</td></tr><tr><td>｜</td><td>按位或</td><td>L</td><td>2</td><td>int,int =&gt; int</td></tr><tr><td>—————</td><td>—————</td><td>—</td><td>–</td><td>———</td></tr><tr><td>&amp;&amp;</td><td>逻辑与</td><td>L</td><td>2</td><td>any,any =&gt; any</td></tr><tr><td>—————</td><td>—————</td><td>—</td><td>–</td><td>———</td></tr><tr><td>｜｜</td><td>逻辑或</td><td>L</td><td>2</td><td>any,any =&gt; any</td></tr><tr><td>—————</td><td>—————</td><td>—</td><td>–</td><td>———</td></tr><tr><td>?:</td><td>条件运算符</td><td>L</td><td>3</td><td>bool,any,any =&gt; any</td></tr><tr><td>—————</td><td>—————</td><td>—</td><td>–</td><td>———</td></tr><tr><td>=</td><td>赋值运算符</td><td>R</td><td>2</td><td>lval,any =&gt; any</td></tr><tr><td>*=,/=,%=,+=,-=,&amp;=</td><td>运算且赋值</td><td>R</td><td>2</td><td>lval,any =&gt; any</td></tr><tr><td>^=,｜｜=,&lt;&lt;=,&gt;&gt;=,&gt;&gt;&gt;=</td><td>运算且赋值</td><td>R</td><td>2</td><td>lval,any =&gt; any</td></tr><tr><td>—————</td><td>—————</td><td>—</td><td>–</td><td>———</td></tr><tr><td>,</td><td>忽略第一个操作数，返回第二个操作数</td><td>L</td><td>2</td><td>any,any =&gt; any</td></tr></tbody></table><h3 id="左值"><a href="#左值" class="headerlink" title="左值"></a>左值</h3><p>上表中出现的lval指的是左值，意思是表达式只能出现在赋值运算符的左侧</p><p>在js中，变量、对象属性、和数组元素都是左值。</p><p>ECMAScript允许内置函数返回左值，但自定义函数不能返回左值</p><h3 id="操作数类型和结果类型"><a href="#操作数类型和结果类型" class="headerlink" title="操作数类型和结果类型"></a>操作数类型和结果类型</h3><p>js运算符通常会根据需要对操作数进行类型转换</p><p><code>*</code>希望操作数为数字，但是表达式<code>&quot;3&quot;*&quot;5&quot;</code>却是合法的，因为js会把操作数转换为数字</p><p>有些操作符对操作数类型有一定程度依赖，比如<code>＋</code>运算符。可以对数字进行加法运算，也可以对字符串进行连接。</p><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>上表中运算符按照优先级从高到低排序，每个虚线内的一组运算符具有相同优先级。</p><p>优先级高的运算符执行总是先于优先级低的运算符<br>举个栗子：<code>m = x + y*z;</code><br><code>*</code>运算符比<code>＋</code>运算符优先级高，优先计算<code>y*z</code>，获得结果再与x相加。<code>=</code>赋值运算符优先级最低，右侧表达式<br>计算出结果后赋值给m</p><p>很多时候为了代码逻辑清晰，加上一些括号来重写优先级，来避免一些优先级引起的bug或者执行顺序与设计不符<br><code>m = (x + y) * z</code></p><h3 id="运算符的结合性"><a href="#运算符的结合性" class="headerlink" title="运算符的结合性"></a>运算符的结合性</h3><p>上表中说明了运算符的结合性。</p><ul><li>L 指从左到右结合,执行时按照从左到右的顺序进行</li><li>R 指从右到左结合,执行时按照从右到左的顺序进行</li></ul><p>举个栗子：<code>-</code>运算符从左到右结合，因此<code>w = x - y - z</code> 等价于 <code>w = ((x - y) - z)</code></p><h3 id="运算顺序"><a href="#运算顺序" class="headerlink" title="运算顺序"></a>运算顺序</h3><p>运算符的优先级和结合性规定了在复杂表达式中的运算顺序，但是没有规定子表达式的计算过程中的运算顺序</p><p>js中，总是严格按照从左到右计算子表达式。例如<code>w=x+y*z</code>，首先计算w,然后计算x,y,z的值，然后y的值和z的值相承<br>之后，再加上x的值，最后将其结果赋值给w。给表达式加括号会改变乘法加法和赋值运算的顺序，但是子表达式的计算<br>顺序仍然是从左至右的顺序</p><p>只有一种情况例外，当任何一个表达式具有副作用而影响其他表达式时候，求值顺序才会有所不同。<br>例如，表达式中x的一个变量自增1，这个变量在z中使用，那么实际上是先计算了x的值再计算z的值，这一点一定要注意</p><p>下面这个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 1;</span><br><span class="line">b = (a++) + a;</span><br></pre></td></tr></table></figure><p>如果按照前面那种不考虑副作用时的顺序是 1) 计算b, 2)计算a++为c, 3）计算a，4）计算c＋a, 5）将c+a结果赋值给b</p><p>按照<code>++</code>的影响，1) 计算b, 2)a++结果仍然为1,c=1,随即a立即自增1, 3）计算a，a已经是2，4）计算c＋a＝3,5）将c+a结果赋值给b，所以b＝3</p><p><strong>切记，a增1的操作是在表达式计算中就已经执行了，不是在整个表达式计算完成之后执行的</strong></p><h2 id="算术表达式"><a href="#算术表达式" class="headerlink" title="算术表达式"></a>算术表达式</h2><p>基本算数运算符包括<code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code></p><h3 id="“-”运算符"><a href="#“-”运算符" class="headerlink" title="“+”运算符"></a>“+”运算符</h3><ul><li>对2个数字进行加法操作</li><li>字符串连接操作</li></ul><p><strong>针对不同操作数，＋运算符行为表现有些不同</strong></p><ul><li>一个操作数是对象，对象会遵循对象到原始值的转换规则转换为原始值<ul><li>日期对象：toString()执行转换</li><li>其他对象通过valueOf()转换，如果valueOf()不可用，会通过toString()方法转换</li></ul></li><li>在进行对象到原始值的转换后，如果其中一个操作数是字符串，另一个操作数也会转换成字符串，然后连接</li><li>否则，两个操作数都转换成数字或者NaN，然后进行加法操作</li></ul><p>下面是一些栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 + 2 // =&gt;3</span><br><span class="line">&quot;1&quot; + 2 // =&gt; &quot;12&quot;</span><br><span class="line">&quot;12&quot; + &quot;3&quot; // =&gt; &quot;123&quot;</span><br><span class="line">1 + &#123;&#125; // &quot;1[object object]&quot;，对象转换为字符串</span><br><span class="line">true + true // 2 ，bool转换为数字做加法</span><br><span class="line"></span><br><span class="line">2 + null // =&gt;2,null转换为0</span><br><span class="line">2 + undefined // =&gt; NaN, undefined转换为NaN后做加法</span><br></pre></td></tr></table></figure><p><strong>最后，还需要考虑，加法的结合性对运算顺序的影响</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 + 2 + &quot;hello&quot; // &quot;3hello&quot;</span><br><span class="line">1 + (2 + &quot;hello&quot;) // &quot;12hello&quot;</span><br></pre></td></tr></table></figure><h3 id="一元算术运算符"><a href="#一元算术运算符" class="headerlink" title="一元算术运算符"></a>一元算术运算符</h3><p>一元运算符作用于一个单独操作数，产生一个新值</p><p>js中一元运算符优先级很高，并且都是右结合</p><p><code>+</code>/<code>-</code>，既是一元运算符，也是二元运算符</p><ul><li><p>一元加法(<code>+</code>)</p><blockquote><p>操作数转换为数字（或者NaN），并且返回这个转换后的数字。如果已经是数字，直接返回</p></blockquote></li><li><p>一元减法(<code>-</code>)</p><blockquote><p>操作数转换为数字（或者NaN），并且返回这个转换后的数字，然后改变运算结果符号</p></blockquote></li><li><p>递增(<code>++</code>)</p><blockquote><p>前增量 <code>++a</code>，先进行增量运算并且返回运算结果<br>后增量 <code>a++</code>，先进行增量计算，返回未做增量运算的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; var i=1, j=i++; // i=2,j=1</span><br><span class="line">&gt; var i=1, j=++i; // i=2,j=2</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>递减(<code>--</code>)</p><blockquote><p>前减量 <code>--a</code>，先进行减量运算并且返回运算结果<br>后减量 <code>a--</code>，先进行减量计算，返回未做减量运算的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; var i=1, j=i--; // i=0,j=1</span><br><span class="line">&gt; var i=1, j=--i; // i=0,j=0</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><ul><li><p><code>&amp;</code> 按位与</p><blockquote><p><code>0x1234 &amp; 0x00ff = 0x0034</code></p></blockquote></li><li><p><code>|</code> 按位或</p><blockquote><p><code>0x1234 | 0x00ff = 0x12ff</code></p></blockquote></li><li><p><code>^</code> 按位异或</p><blockquote><p><code>0xff00 ^ 0xf0f0 = 0x0ff0</code></p></blockquote></li><li><p><code>~</code> 按位非</p><blockquote><p><code>~0x0f = 0xfffffff0</code></p></blockquote></li><li><p><code>&lt;&lt;</code> 左移</p><blockquote><p><code>7 &lt;&lt; 2 = 28</code>,左移一位相当于第一个操作数乘以2<br>移动位数 0～31</p></blockquote></li><li><p><code>&gt;&gt;</code> 带符号右移</p><blockquote><p>带符号右移时候填补在左边的位由原来的数的符号决定，以便保持和原操作数一致<br>移动位数 0～31<br><code>7 &gt;&gt; 1 = 3</code><br><code>-7 &gt;&gt; 1 = -4</code></p></blockquote></li><li><p><code>&gt;&gt;&gt;</code> 无符号右移</p><blockquote><p>无符号右移时候填补在左边的位直接填补0，与原操作数无关<br>移动位数 0～31<br><code>-1 &gt;&gt; 4 = 1</code><br><code>-1 &gt;&gt;&gt; 4 = 0x0fffffff</code></p></blockquote></li></ul><h2 id="关系表达式"><a href="#关系表达式" class="headerlink" title="关系表达式"></a>关系表达式</h2><p>主要包括相等和不相等运算符、比较运算符、in、instanceof</p><h3 id="相等和不相等运算符"><a href="#相等和不相等运算符" class="headerlink" title="相等和不相等运算符"></a>相等和不相等运算符</h3><p>js定义了4个符号<code>==</code>,<code>===</code>,<code>!=</code>,<code>!==</code></p><ul><li><code>==</code>：相等</li><li><code>===</code>: 恒等</li><li><code>!=</code>: 不相等</li><li><code>!==</code>: 不恒等</li></ul><p>严格相等运算符<code>===</code>首先计算其操作数的值，然后比较这两个值，没有类型转换</p><ul><li>如果两个值类型不相同，则它们不相等</li><li>如果两个值都是null或者都是undefined，则它们不相等</li><li>如果两个值都是布尔值true或者false，，则它们相等</li><li>如果其中一个值是NaN，或者2个值都是NaN，则它们不相等。NaN和其他任何值都是不相等的，包括自身。通过X!==X来判断x是否为NaN，只有x为NaN时候，表达式才为true</li><li>如果两个值为数字且数值相等，则他们相等。如果一个值为0，另一个为－0，同样相等</li><li>如果两个值为字符串，且所含对应位上16位数完全相等，则他们相当。如果它们长度或内容不同，则它们不相等。</li><li>两个字符串可能含义完全一样且显示字符一样，但具有不同编码的16位值。js不会对Unicode进行标准化转换，像这样字符串通过”===”和”==”运算符比较结果也是不相等</li><li>如果两个引用值指向同一个对象、数组或者函数，则相等。如果指向不同对象，则它们不相等，尽管两个对象完全一样的属性。</li></ul><p>相等运算符<code>==</code>和恒等运算符相似，但相等运算符并不严格。如果两个操作数不是同一类型，那么相等的运算符会进行一些类型转换，然后进行比较</p><ul><li>如果两个操作数的类型相同，则和上文所属的严格相等的比较规则一样。如果严格相等，则比较结果相等，如果不严格相等，则它们不相等</li><li>如果两个操作数类型不同，<code>==</code>相等操作符也可能认为他们相等。检测相等会遵守以下规则和类型转换如果一个值是null，另一个是undefined,则他们相等如果一个值是数字，另一个是字符串，先将字符串转换成数字，然后使用转换后的值，进行比较如果其中一个值是true，则将其转换为1再进行比较。如果其中一个值是false，则将其转化为0，在进行比较如果一个值是对象，另一个值是数字或字符串，则会使用之前提到的对象到数字或字符串的转换规则将对象转换为原始值，然后进行比较。其他的类型之间的比较均不相等</li></ul><p>举个栗子：<code>&quot;1&quot; == true</code><br>这个表达式结果是true，表明不同类型之间的值比较结果相等。布尔值首先转换为数字1，然后字符串1也转换成数字1，因为两个数字相等，所以结果为true</p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>比较运算符有4个</p><ul><li><code>&lt;</code> 小于</li><li><code>&gt;</code> 大于</li><li><code>&lt;=</code> 小于等于</li><li><code>&gt;=</code> 大于等于</li></ul><p>比较运算符的操作数可以是任何类型，然后只有字符串和数字才能真正的执行比较操作，不是这两种类型的都将进行类型转换。<br>类型转换规则：</p><ul><li>如果操作数为对象，这个对象将按照对象到原始值的转换（具体可以看上篇）</li><li>在对象转换到原始值后，如果两个操作数都是字符串，那么将按照字母表顺序进行比较（字母表指的unicode 16位字符的索引顺序）</li><li>对象转换为原始值后，如果一个操作数不是字符串，那么两个操作数转换为数字之后进行比较。<ul><li>0和－0是相等的</li><li>Infinity比其他任何数字都大（除了自身）</li><li>－Infinity比其他数字都小(除了自身)</li><li>如果一个操作数转换成数字之后是NaN，那么比较操作符总是返回false</li></ul></li></ul><p>在上面规则中，字符串比较需要注意：   </p><ul><li>字符串比较是区分大小写的，所有的大写ascii字符都是小于小写的ascii字符</li><li>对于数字和字符串比较，只有两个操作数都是字符串时，才会进行字符串比较</li></ul><h3 id="in运算符"><a href="#in运算符" class="headerlink" title="in运算符"></a><code>in</code>运算符</h3><p><code>in</code>运算符的左边总是希望是一个字符串，右边操作数总是希望是一个对象，如果右边对象拥有左操作值的属性名，会返回true</p><p>对象，会倾向查找属性名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var point = &#123; x:1, y:1&#125;;</span><br><span class="line">&quot;x&quot; in point // ＝&gt; true, 对象拥有名为“x”的属性</span><br><span class="line">&quot;z&quot; in point // =&gt; false, 对象不存在名为&quot;z&quot;的属性</span><br><span class="line">&quot;toString&quot; in point // =&gt; true，对象继承了默认的toString()方法</span><br></pre></td></tr></table></figure><p>数组，会倾向查找索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var data = [1,2,3]</span><br><span class="line">&quot;0&quot; in data // true，数组包含索引0的元素</span><br><span class="line">1 in data // true，数组包含索引1的元素</span><br><span class="line">3 in data // false 数组不包含索引3的元素</span><br></pre></td></tr></table></figure><h3 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a><code>instanceof</code> 运算符</h3><p><code>instanceof</code>运算符希望左操作数是一个对象，右操作数标识对象的类，如果左侧的对象是右侧类的实例，则返回true，否则返回false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date();</span><br><span class="line">d instanceof Date;  // true，d是由Date()创建的</span><br><span class="line">d instanceof Object; //  true,所有对象都是Object实例</span><br><span class="line">d instanceof Number; // false, d不是Number的实例</span><br></pre></td></tr></table></figure><h2 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h2><p>逻辑运算符是进行布尔运算使用的，主要有</p><ul><li><code>&amp;&amp;</code> 逻辑与</li><li><code>||</code> 逻辑或</li><li><code>!</code> 逻辑非</li></ul><h3 id="逻辑与-amp-amp"><a href="#逻辑与-amp-amp" class="headerlink" title="逻辑与(&amp;&amp;)"></a>逻辑与(&amp;&amp;)</h3><p>当操作数都是布尔值时，<code>&amp;&amp;</code>对两个值进行布尔与操作，第一个与第二个操作数都是true时，才返回true，其中一个是false，就会返回false</p><p>当操作数不都是布尔值时，<code>&amp;&amp;</code>不一定会返回布尔值。</p><ul><li>逻辑与运算符，首先计算左侧的值，如果计算结果是假植，则整个表达式都是假植，因此会简单的返回左侧操作数的值</li><li>如果左侧值是真值，那么整个表达式结果依赖于右侧的值，因此，<code>&amp;&amp;</code>运算符符会计算右侧操作数的值，并且将其返回作为整个表达式的计算结果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var o =&#123; x:1 &#125;;</span><br><span class="line">var p = null;</span><br><span class="line">o &amp;&amp; o.x; // =&gt;1 ，o对象是真值，返回o.x</span><br><span class="line">p &amp;&amp; p.x; // =&gt; null ，p是假值，将其返回，不会计算p.x</span><br></pre></td></tr></table></figure><p>上面那种行为，被称为 <strong>短路</strong>,这一特性非常有用，可以选择性执行代码。 例如：<br><code>if ( a == b ) stop();</code> 等价于 <code>( a == b ) &amp;&amp; stop();</code></p><h3 id="逻辑或"><a href="#逻辑或" class="headerlink" title="逻辑或(||)"></a>逻辑或(||)</h3><p>当操作数都是布尔值时，<code>||</code>对两个操作数作布尔或运算，两个操作数有一个为真，返回true，两个操作数都是假，才会返回false</p><p>当操作数不都是布尔值，<code>||</code>不一定返回布尔值</p><ul><li>逻辑或运算符，首先计算左侧的值，如果计算结果是真值，则整个表达式都是真值，因此会返回这个真值</li><li>否则再计算第二个操作数的值，再返回这个表达式的计算结果</li></ul><p><code>||</code>同样是非常有用，比如从一组备选表达式中选出第一个真值表达式。这种做法经常在函数体内，给参数提供默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var max = max_width || preference.max_width || 500;</span><br></pre></td></tr></table></figure><h3 id="逻辑非"><a href="#逻辑非" class="headerlink" title="逻辑非(!)"></a>逻辑非(!)</h3><p><code>!</code> 运算符是一元运算符，放在一个单独的操作数前，对操作数布尔值进行求反</p><p><code>!</code>运算符首先将操作数转换为布尔值，再进行求反，最终只会返回true或者false</p><p>作为一元运算符，优先级非常高，并且和操作数密切绑定。<br>德摩根公式:    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!(p &amp;&amp; q) === !p || !q</span><br><span class="line">!(p || q) === !p &amp;&amp; !q</span><br></pre></td></tr></table></figure><h2 id="赋值表达式"><a href="#赋值表达式" class="headerlink" title="赋值表达式"></a>赋值表达式</h2><p>js 使用<code>=</code>运算符给变量或者属性进行赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = 0;</span><br><span class="line">0.x = 1;</span><br></pre></td></tr></table></figure><p>除了常规的赋值运算符，还有一些带赋值操作的运算符<code>+=</code>,<code>-=</code>,<code>*=</code>,<code>&amp;=</code>等等<br>只有<code>+=</code>可以用于数字或字符串连接，其他都偏向于数值操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = 10;</span><br><span class="line">b = &apos;1&apos;;</span><br><span class="line">a += 10; // =&gt; 10 + 10 =20</span><br><span class="line">b += 10; // =&gt; &apos;1&apos;+10 = &quot;110&quot;</span><br><span class="line">a -= 10; // =&gt; 20 - 10 = 10</span><br><span class="line">b -= 10; // =&gt; 110 - 10 = 10</span><br></pre></td></tr></table></figure><h2 id="表达式计算"><a href="#表达式计算" class="headerlink" title="表达式计算"></a>表达式计算</h2><p>js可以通过<code>eval()</code>来动态判断源代码中的字符串，并且执行</p><p><code>eval()</code>只有一个参数，如果传入的参数不是字符串，直接返回这个参数。如果参数是字符串，则会把字符串当成代码进行编译。<br>如果编译失败，则返回一个语法错误异常。如果编译成功，则会执行这段代码，并且返回字符串最后一个表达式或者语句的值。<br>如果最后一个表达式或语句没有值，则最终返回undefined</p><p><code>eval()</code>使用来调用它的变量作用域环境，也就是说查找变量会和局部作用域代码完全一样。</p><p>如果将<code>eval()</code>重命名为其他方式来调用，则使用全局对象作为上下文作用域，并且无法读、写、定义局部变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var geval = eval; // geval 是调用全局eval</span><br><span class="line">var x = &quot;global&quot;;</span><br><span class="line">var y = &quot;global&quot;;</span><br><span class="line">function f()&#123;</span><br><span class="line">  var x = &quot;local&quot;;  // 定义局部变量 x，局部作用域x ＝ “local”</span><br><span class="line">  eval(&quot;x+=&apos;changed&apos;;&quot;); //  直接eval更改局部变量x的值</span><br><span class="line">  return x; // 返回更改后的x值</span><br><span class="line">&#125;</span><br><span class="line">function g()&#123;</span><br><span class="line">  var y = &quot;local&quot;;  // 定义局部变量 y，局部作用域y ＝ “local”</span><br><span class="line">  geval(&quot;y+=&apos;changed&apos;;&quot;); // 间接调用改变全局变量的值</span><br><span class="line">  return y; // 返回为更改的局部变量</span><br><span class="line">&#125;</span><br><span class="line">console.log(f(),x); // 更改来局部变量，输出&quot;localchanged global&quot;</span><br><span class="line">console.log(g(),y); // 更改全局变量，输出“local globalchanged”</span><br></pre></td></tr></table></figure><h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><h3 id="条件运算符（-）"><a href="#条件运算符（-）" class="headerlink" title="条件运算符（?:）"></a>条件运算符（?:）</h3><p>条件运算符是唯一一个三元运算符<br><code>(---1---) ? (---2---) : (---3---)</code></p><p>第一个操作数当成布尔值，如果是真值，那么计算第二个操作数，并返回结果。否则如果第一个操作数是假植，那么计算第三个数，返回计算结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &gt; 0 ? x : -x // 求x的绝对值</span><br></pre></td></tr></table></figure><h3 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h3><h3 id="delete运算符"><a href="#delete运算符" class="headerlink" title="delete运算符"></a>delete运算符</h3><p>delete运算符，用来删除对象属性或者数组元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123; x:1, y:2&#125;;</span><br><span class="line">delete o.x; // 删除一个属性</span><br><span class="line">&quot;x&quot; in o; // false，o对象中不存在属性x</span><br><span class="line"></span><br><span class="line">var a = [1,23,4];</span><br><span class="line">delete a[2]; //删除第三个元素</span><br><span class="line">2 in a ; // false, 索引2的元素在数组中已经不存在</span><br></pre></td></tr></table></figure><p>delete删除成功会返回true。然后不是所有属性都可删除的</p><ul><li>一些内置核心和客户端属性是不能删除的</li><li>使用var语句生声明的变量不能删除</li><li>通过function定义的函数和函数参数不能删除。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var 0 = &#123; x:1, y:2&#125;;</span><br><span class="line">delete o.x; // true, 删除对象属性成功</span><br><span class="line">typeof o.x; // undefined ， 属性不存在</span><br><span class="line">delete o.x; // true, 删除不存在的属性，返回true</span><br><span class="line">delete o; // false ，不能删除var声明变量</span><br><span class="line"></span><br><span class="line">delete 1; // true, 参数不是一个左值，返回true</span><br><span class="line">this.x = 1; // 定义全局对象的一个属性</span><br><span class="line">delete x; // 试图删除全局变量的属性，非严格模式下，返回true</span><br><span class="line">x; // 运行时错误，没有定义x</span><br></pre></td></tr></table></figure><h3 id="void-运算符"><a href="#void-运算符" class="headerlink" title="void 运算符"></a>void 运算符</h3><p>void 是一元运算符，操作数照常计算，但是忽略计算结果并且返回undefined</p><p>这个操作符经常用作客户端URL－<code>javascript:URL</code>,通过使用void则让浏览器不必显示这个表达式计算结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:void window.open();&quot;&gt;打开一个新窗口&lt;/a&gt;</span><br></pre></td></tr></table></figure><h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><p>逗号运算符，首先计算左操作数，然后计算右操作数，最后返回右操作数的值。</p><p>总会计算左侧的表达式，但计算结果忽略掉，也就是说，只有左侧表达式有副作用时，，才会使用逗号表达式让代码更通顺。</p><p>经常在for循环中使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(var i=0,j=10;i&lt;j;i++,j--)&#123;</span><br><span class="line">  console.log(i+j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文／zhaolion（简书作者）<br>原文链接：<a href="http://www.jianshu.com/p/ff845f40f036" target="_blank" rel="noopener">http://www.jianshu.com/p/ff845f40f036</a><br>著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;程序中最简单的表达式就是，程序中的常量&lt;/li&gt;
&lt;li&gt;变量名也是一种简单的表达式&lt;/li&gt;
&lt;li&gt;复杂的表达式是由简单的表达式组成的&lt;/li&gt;
&lt;li&gt;函数调用表达式是由函数对象的表达式和0个或多个参数表达式构成&lt;/li&gt;
&lt;li&gt;可以使用运算符来将简单的表达式来组合成复杂的表达式
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ui-router</title>
    <link href="http://xuhongbo.com/2016/12/14/%E6%A1%86%E6%9E%B6/angular/ui-router/"/>
    <id>http://xuhongbo.com/2016/12/14/框架/angular/ui-router/</id>
    <published>2016-12-14T05:57:30.000Z</published>
    <updated>2017-03-02T17:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么用-Route"><a href="#为什么用-Route" class="headerlink" title="为什么用 Route"></a>为什么用 Route</h2><ul><li>AJAX 请求不会留下 History 记录</li><li>用户无法直接通过 URL 进入应用中的指定页面(保存书签、链接分享给朋友)</li><li><p>AJAX 对 SEO 是个灾难</p><a id="more"></a><h2 id="前端路由的基本原理"><a href="#前端路由的基本原理" class="headerlink" title="前端路由的基本原理"></a>前端路由的基本原理</h2></li><li><p>哈希 #</p></li><li><p>HTML5 中新的 history API</p></li><li><p>路由的核心是给应用定义 “状态”</p></li><li><p>使用路由机制会影响到应用的整体编码方式(需预先定义好状态)</p></li><li><p>考虑兼容性问题与 “优雅降级”</p><p>​</p><p>​</p></li></ul><p>1.多视图用@，嵌套用parent.child这种子路由</p><blockquote><p>要切换的视图(main)用ui-view,始终不会变成其他内容的不需要路由</p></blockquote><p>2.要切换的路由ui-sref用子路由</p><p>1.文件结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">D:.douban</span><br><span class="line">|</span><br><span class="line">│  index.html                       </span><br><span class="line">│                                   </span><br><span class="line">├─css                               </span><br><span class="line">│      bootstrap.css                </span><br><span class="line">│      index.css                    </span><br><span class="line">│                                   </span><br><span class="line">├─js                                </span><br><span class="line">│      angular-1.3.0.js             </span><br><span class="line">│      angular-animate.js           </span><br><span class="line">│      angular-ui-router.js         </span><br><span class="line">│      app.js                       </span><br><span class="line">│      ui-bootstrap-tpls-0.11.0.js  </span><br><span class="line">│                                   </span><br><span class="line">└─src                               </span><br><span class="line">        addUser.html                </span><br><span class="line">        bottomBar.html              </span><br><span class="line">        home.html                   </span><br><span class="line">        index.html                  </span><br><span class="line">        userInfo.html</span><br></pre></td></tr></table></figure><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/bootstrap.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/angular-1.3.0.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/angular-animate.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/angular-ui-router.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/app.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined">.active &#123; color: red; font-weight: bold; &#125;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">ng-app</span>=<span class="string">"helloworld"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>app.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myApp = angular.module(<span class="string">'helloworld'</span>, [<span class="string">'ui.router'</span>]);</span><br><span class="line"><span class="comment">// 路由机制</span></span><br><span class="line"><span class="comment">//这一行声明了把$stateProvider和$urlRouterProvider路由引擎作为函数参数传入，这样我们就可易为这个应用程序配置路由了</span></span><br><span class="line">myApp.config(<span class="function"><span class="keyword">function</span>(<span class="params">$stateProvider, $urlRouterProvider</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//下面一行的意思是：如果没有路由引擎能匹配当前的导航状态，那它就会默认将路径路由至PageTab.html，这个页面就是状态名称被声明的地方。只要理解了这个，那么它就像switch case语句中的default选项</span></span><br><span class="line">  $urlRouterProvider.otherwise(<span class="string">'/index'</span>);</span><br><span class="line">  $stateProvider</span><br><span class="line">    .state(<span class="string">'index'</span>, &#123;</span><br><span class="line">      url: <span class="string">'/index'</span>,</span><br><span class="line"><span class="comment">// view 用在该状态下有多个 ui-view 的情况，可以对不同的 ui-view 使用特定的 template, controller, resolve data</span></span><br><span class="line"><span class="comment">// 绝对 view 使用 '@' 符号来区别，比如 'foo@bar' 表明名为 'foo' 的 ui-view 使用了 'bar' 状态的模板(template)，相对 view 则无</span></span><br><span class="line">      views: &#123;</span><br><span class="line">        <span class="comment">//无名view</span></span><br><span class="line">        <span class="string">''</span>: &#123;</span><br><span class="line">         <span class="comment">//配置templateUrl属性，来加载指定位置的模板，这是设置模板的常用方法</span></span><br><span class="line">          templateUrl: <span class="string">'src/index.html'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//main在index模块中</span></span><br><span class="line">        <span class="string">'main@index'</span>: &#123;</span><br><span class="line">          templateUrl: <span class="string">'src/home.html'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'tabBar@index'</span>: &#123;</span><br><span class="line">          templateUrl: <span class="string">'src/bottomBar.html'</span></span><br><span class="line">          <span class="comment">//在下面也可以直接加参数</span></span><br><span class="line">          <span class="comment">//controller:'路由到的页面的控制器名称'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="comment">//index.userInfo表示路由结构  index/userInfo</span></span><br><span class="line">    .state(<span class="string">'index.userInfo'</span>, &#123;</span><br><span class="line">      url: <span class="string">'/userInfo'</span>,</span><br><span class="line">      views: &#123;</span><br><span class="line">        <span class="comment">//替换之前占位的home.html 替换成userInfo.html</span></span><br><span class="line">        <span class="string">'main@index'</span>: &#123;</span><br><span class="line">          templateUrl: <span class="string">'src/userInfo.html'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="comment">//index.userInfo.addUser表示路由结构  index/userInfo/addUser</span></span><br><span class="line">    .state(<span class="string">'index.userInfo.addUser'</span>, &#123;</span><br><span class="line">        url: <span class="string">'/addUser'</span>,</span><br><span class="line">        templateUrl: <span class="string">'src/addUser.html'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>src目录</p><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>=<span class="string">"main"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>=<span class="string">"tabBar"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>home.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"jumbotron text-center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        首页的形式一般比较<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"text-danger"</span>&gt;</span>灵活<span class="tag">&lt;/<span class="name">span</span>&gt;</span>，而且可能随时发生变化。</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>bottomBar.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"navbar navbar-inverse"</span> <span class="attr">role</span>=<span class="string">"navigation"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"nav navbar-nav"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">ui-sref</span>=<span class="string">"index"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">ui-sref</span>=<span class="string">"index.userInfo"</span>&gt;</span>用户管理<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure><p>userInfo.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-3"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-12"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list-group"</span>&gt;</span></span><br><span class="line">             //导航</span><br><span class="line">                    <span class="tag">&lt;<span class="name">a</span> <span class="attr">ui-sref</span>=<span class="string">"index.userInfo.addUser"</span> <span class="attr">class</span>=<span class="string">"list-group-item"</span>&gt;</span>adduser<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                    </span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-9"</span>&gt;</span></span><br><span class="line">      //视图</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="ui-sref-传参"><a href="#ui-sref-传参" class="headerlink" title="ui-sref 传参"></a>ui-sref 传参</h3><h5 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"phones"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"thumbnail phone-list-item"</span> <span class="attr">ng-repeat</span>=<span class="string">"phone in phone_list"</span>&gt;</span></span><br><span class="line">           //要传的参数</span><br><span class="line">           <span class="tag">&lt;<span class="name">a</span> <span class="attr">ui-sref</span>=<span class="string">"detail(&#123;id:phone.id&#125;)"</span> <span class="attr">class</span>=<span class="string">"thumb"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">img</span> <span class="attr">ng-src</span>=<span class="string">"&#123;&#123; phone.imageUrl &#125;&#125;"</span> <span class="attr">alt</span>=<span class="string">"&#123;&#123; phone.id &#125;&#125;"</span> /&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">a</span> <span class="attr">ui-sref</span>=<span class="string">"detail(&#123;id:phone.id&#125;)"</span>&gt;</span>&#123;&#123; phone.name &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; phone.snippet &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.state(<span class="string">'detail'</span>,&#123;</span><br><span class="line">url:<span class="string">'/detail/:id'</span>,<span class="comment">//后面是这种形式的参数http://127.0.0.1:3333/#/detail/motorola-xoom  把参数写在路径里</span></span><br><span class="line">templateUrl:<span class="string">'app/detail/detail.html'</span>,</span><br><span class="line">contorller: <span class="string">'detailListController'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.controller(<span class="string">'detailListController'</span>, [</span><br><span class="line"><span class="string">'$scope'</span>,</span><br><span class="line"><span class="string">'$http'</span>,</span><br><span class="line"><span class="string">'$stateParams'</span>,<span class="comment">//承载上一级传过来的参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">$scope, $http,$stateParams</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log($stateParams)</span><br><span class="line">&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么用-Route&quot;&gt;&lt;a href=&quot;#为什么用-Route&quot; class=&quot;headerlink&quot; title=&quot;为什么用 Route&quot;&gt;&lt;/a&gt;为什么用 Route&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;AJAX 请求不会留下 History 记录&lt;/li&gt;
&lt;li&gt;用户无法直接通过 URL 进入应用中的指定页面(保存书签、链接分享给朋友)&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AJAX 对 SEO 是个灾难&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入理解J avaScript 系列（结局篇）</title>
    <link href="http://xuhongbo.com/2016/11/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript/51%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3J%20avaScript%20%E7%B3%BB%E5%88%97%EF%BC%88%E7%BB%93%E5%B1%80%E7%AF%87%EF%BC%89/"/>
    <id>http://xuhongbo.com/2016/11/12/深入理解javascript/51深入理解J avaScript 系列（结局篇）/</id>
    <published>2016-11-12T04:02:02.000Z</published>
    <updated>2017-03-02T17:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近几个月忙得实在是不可开交，终于把《深入理解 JavaScript 系列》的最后两篇“补全”了，所谓的全是不准确的，因为很多内容都没有写呢，比如高性能、Ajax 安全、DOM 详解、JavaScript 架构等等。但因为经历所限，加上大叔希望接下来写点其它东西，所以此篇文字就暂且当前完结篇的总结吧，以后有时间的话，可以继续加上一些未涉及的专题内容。<br><a id="more"></a></p><h2 id="网络文章来源"><a href="#网络文章来源" class="headerlink" title="网络文章来源"></a>网络文章来源</h2><p>本系列文章参考了大量的互联网网站，在此向各位网站拥有者、博主、提到的以及未提到的作者们说一声：多谢感谢了。</p><p>本系列文章主要参考了如下站点：</p><p>五大原则：<a href="http://freshbrewedcode.com/derekgreer" target="_blank" rel="noopener">http://freshbrewedcode.com/derekgreer</a></p><p>ECMAScript262 系列：<a href="http://dmitrysoshnikov.com/" target="_blank" rel="noopener">http://dmitrysoshnikov.com/</a></p><p>DOM 系列文章：<a href="http://net.tutsplus.com/" target="_blank" rel="noopener">http://net.tutsplus.com</a></p><p>设计模式系列文章参考如下三个网站：</p><p><a href="http://www.addyosmani.com/resources/essentialjsdesignpatterns/book/" target="_blank" rel="noopener">http://www.addyosmani.com/resources/essentialjsdesignpatterns/book/</a></p><p><a href="http://shichuan.github.com/javascript-patterns/" target="_blank" rel="noopener">http://shichuan.github.com/javascript-patterns/</a></p><p><a href="https://github.com/tcorral/Design-Patterns-in-Javascript/" target="_blank" rel="noopener">https://github.com/tcorral/Design-Patterns-in-Javascript/</a></p><p>其它文章，总结自自己的收藏、心得，结合了互联网上的各位大牛的博客总结整理而成，因为参考地址太多，无法一一列出，如果忘记了各位各种的版权声明，请及时告知，以便及时处理，多谢！</p><h2 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h2><p>这里列出的书籍是大叔曾经读过的，也是在整理博文的时候经常参考的书籍，推荐给大家阅读。</p><h3 id="初级读物"><a href="#初级读物" class="headerlink" title="初级读物"></a>初级读物</h3><p>《JavaScript 高级程序设计》：一本非常完整的经典入门书籍，被誉为 JavaScript 圣经之一，详解的非常详细，最新版第三版已经发布了，建议购买。</p><h3 id="中级读物"><a href="#中级读物" class="headerlink" title="中级读物"></a>中级读物</h3><p>《JavaScript 权威指南》：另外一本 JavaScript 圣经，讲解的也非常详细，属于中级读物，建议购买。</p><p>《JavaScript.The.Good.Parts》：Yahoo 大牛，JavaScript 精神领袖 Douglas Crockford 的大作，虽然才 100 多页，但是字字珠玑啊！强烈建议阅读。</p><p>《高性能 JavaScript》：《JavaScript 高级程序设计》作者 Nicholas C. Zakas 的又一大作。</p><p>《Eloquent JavaScript》：这本书才 200 多页，非常短小，但是改变了我写作的习惯，本书通过几个非常经典的例子（艾米丽姨妈的猫、悲惨的隐士、模拟生态圈、推箱子游戏等等）来介绍 JavaScript 方方面面的知识和应用方法，非常值得一读，同时这本书的中文版也是大叔翻译的，点击屏幕右上角可以订购，希望大家多多支持。</p><h3 id="高级读物"><a href="#高级读物" class="headerlink" title="高级读物"></a>高级读物</h3><p>《JavaScript Patterns 》：书中介绍到了各种经典的模式，如构造函数、单例、工厂等等，值得学习。</p><p>《Pro.JavaScript.Design.Patterns》：Apress 出版社讲解 JavaScript 设计模式的书，非常不错。</p><p>《Developing JavaScript Web Applications》：构建富应用的好书，针对 MVC 模式有较为深入的讲解，同时也对一些流程的库进行了讲解。</p><p>《Developing Large Web Applications》：将这本书归结在这里，貌似有点不妥，因为这里不仅有 JavaScript 方面的介绍，还有 CSS、HTML 方面的介绍，但是介绍的内容却都非常不错，真正考虑到了一个大型的 Web 程序下，如何进行 JavaScript 架构设计，值得一读。</p><h3 id="其它参考书籍"><a href="#其它参考书籍" class="headerlink" title="其它参考书籍"></a>其它参考书籍</h3><p>《大话设计模式》：博文里关于设计模式的文章，有些总结性的文字来自于此。</p><p>《设计模式——可复用面向对象软件的基础》：博文里关于设计模式的文章，有些介绍性和总结性的文章来自于此。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在写此系列文章期间，大叔也学到了很多很多内容。同时为了不误人子弟，大叔参考了很多很多文章，同时也阅读了那么多书籍，但博客里的文章，可能依然有很多错误，希望各位如果发现错误的话，请及时告知，以便及时修正而不再继续误导其它人。</p><p>同时，大家在阅读过程中，有任何问题都可以在相应的文章里留言，大叔将在不耽误工作的情况下尽力回复。</p><h2 id="同步与推荐"><a href="#同步与推荐" class="headerlink" title="同步与推荐"></a>同步与推荐</h2><p>深入理解 JavaScript 系列文章，包括了原创，翻译，转载等各类型的文章，如果对你有用，请推荐支持一把，给大叔写作的动力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近几个月忙得实在是不可开交，终于把《深入理解 JavaScript 系列》的最后两篇“补全”了，所谓的全是不准确的，因为很多内容都没有写呢，比如高性能、Ajax 安全、DOM 详解、JavaScript 架构等等。但因为经历所限，加上大叔希望接下来写点其它东西，所以此篇文字就暂且当前完结篇的总结吧，以后有时间的话，可以继续加上一些未涉及的专题内容。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>eslint配置</title>
    <link href="http://xuhongbo.com/2016/10/08/%E5%B7%A5%E5%85%B7%E7%B1%BB/eslint%E9%85%8D%E7%BD%AE/"/>
    <id>http://xuhongbo.com/2016/10/08/工具类/eslint配置/</id>
    <published>2016-10-08T07:02:02.000Z</published>
    <updated>2017-03-02T17:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>EsLint帮助我们检查Javascript编程时的语法错误。比如：在Javascript应用中，你很难找到你漏泄的变量或者方法。EsLint能够帮助我们分析JS代码，找到bug并确保一定程度的JS语法书写的正确性。<br>EsLint是建立在Esprima(ECMAScript解析架构)的基础上的。Esprima支持ES5.1,本身也是用ECMAScript编写的，用于多用途分析。EsLint不但提供一些默认的规则（可扩展），也提供用户自定义规则来约束我们写的Javascript代码。<br><a id="more"></a></p><p>我们在全局安装<code>npm install eslint -g</code></p><p>然后再初始化eslint<code>eslint --init</code></p><p>然后我们配置的时候<br>第一种初始化方式<br><img src="/images/eslint-1.png" alt="img"><br><img src="/images/eslint-1.png" alt="img"><br><img src="/images/eslint-1.png" alt="img"></p><p><img src="/images/eslint-4.png" alt="img"></p><p>第二种初始化方式<br><img src="/images/eslint-5.png" alt="img"></p><p>然后就可以了  重启我们的vscode就可以进行代码风格检查了</p><ul><li>文档 &lt;<a href="http://eslint.cn/docs/user-guide/configuring" target="_blank" rel="noopener">http://eslint.cn/docs/user-guide/configuring</a><a href="http://eslint.cn/docs/user-guide/configuring" target="_blank" rel="noopener">http://eslint.cn/docs/user-guide/configuring</a>ESLint的2种配置:<strong>Configuration Comments</strong> - 使用 JavaScript 注释把配置信息直接嵌入到一个文件。<strong>Configuration Files</strong> - 使用 JavaScript、JSON 或者 YAML 文件为整个目录和它的子目录指定配置信息。可以用 .eslintrc.* 文件或者在 package.json 文件里的 eslintConfig 字段这两种方式进行配置，ESLint 会查找和自动读取它们，再者，你可以在命令行指定一个配置文件。</li></ul><blockquote><blockquote><p>有很多配置信息:</p><ul><li><strong>Environments</strong> -指定脚本的运行环境 每种环境都有一组特定的预定义全局变量</li><li><strong>Globals</strong> -脚本在执行期间访问的额外全局变量</li><li><strong>Rules</strong> -启用的规则及各自的错误级别</li></ul></blockquote></blockquote><h3 id="Configuring-Rules-配置规则"><a href="#Configuring-Rules-配置规则" class="headerlink" title="Configuring Rules 配置规则"></a>Configuring Rules 配置规则</h3><p>ESLint 附带有大量的规则。你可以使用注释或配置文件修改你项目中要使用哪些规则。改变一个规则设置，你必须设置规则 ID 等于这些值之一：</p><ul><li>“off”或0 -关闭规则</li><li>“warn” 或1 - 开启规则, 使用警告 程序不会退出</li><li>“error”或2 - 开启规则, 使用错误 程序退出</li></ul><p>为了在文件注释里配置规则，使用以下格式的注释：</p><p><code>/* eslint eqeqeq: &quot;off&quot;, curly: &quot;error&quot; */</code><br>在这个例子里，eqeqeq 规则被关闭，curly 规则被打开，定义为错误级别。你也可以使用对应的数字定义规则严重程度：</p><p><code>/* eslint eqeqeq: 0, curly: 2 */</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;rules&quot;: &#123;</span><br><span class="line">    &quot;eqeqeq&quot;: &quot;off&quot;,</span><br><span class="line">    &quot;curly&quot;: &quot;error&quot;,</span><br><span class="line">    &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;],</span><br><span class="line">    &quot;plugin1/rule1&quot;: &quot;error&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="临时禁止规则出现警告"><a href="#临时禁止规则出现警告" class="headerlink" title="临时禁止规则出现警告"></a>临时禁止规则出现警告</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* eslint-disable */</span></span><br><span class="line">alert(<span class="string">'foo'</span>);</span><br><span class="line"><span class="comment">/* eslint-enable */</span></span><br></pre></td></tr></table></figure><h3 id="rule解释"><a href="#rule解释" class="headerlink" title="rule解释"></a>rule解释</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"no-alert"</span>: <span class="number">0</span>,<span class="comment">//禁止使用alert confirm prompt</span></span><br><span class="line"><span class="string">"no-array-constructor"</span>: <span class="number">2</span>,<span class="comment">//禁止使用数组构造器</span></span><br><span class="line"><span class="string">"no-bitwise"</span>: <span class="number">0</span>,<span class="comment">//禁止使用按位运算符</span></span><br><span class="line"><span class="string">"no-caller"</span>: <span class="number">1</span>,<span class="comment">//禁止使用arguments.caller或arguments.callee</span></span><br><span class="line"><span class="string">"no-catch-shadow"</span>: <span class="number">2</span>,<span class="comment">//禁止catch子句参数与外部作用域变量同名</span></span><br><span class="line"><span class="string">"no-class-assign"</span>: <span class="number">2</span>,<span class="comment">//禁止给类赋值</span></span><br><span class="line"><span class="string">"no-cond-assign"</span>: <span class="number">2</span>,<span class="comment">//禁止在条件表达式中使用赋值语句</span></span><br><span class="line"><span class="string">"no-console"</span>: <span class="number">2</span>,<span class="comment">//禁止使用console</span></span><br><span class="line"><span class="string">"no-const-assign"</span>: <span class="number">2</span>,<span class="comment">//禁止修改const声明的变量</span></span><br><span class="line"><span class="string">"no-constant-condition"</span>: <span class="number">2</span>,<span class="comment">//禁止在条件中使用常量表达式 if(true) if(1)</span></span><br><span class="line"><span class="string">"no-continue"</span>: <span class="number">0</span>,<span class="comment">//禁止使用continue</span></span><br><span class="line"><span class="string">"no-control-regex"</span>: <span class="number">2</span>,<span class="comment">//禁止在正则表达式中使用控制字符</span></span><br><span class="line"><span class="string">"no-debugger"</span>: <span class="number">2</span>,<span class="comment">//禁止使用debugger</span></span><br><span class="line"><span class="string">"no-delete-var"</span>: <span class="number">2</span>,<span class="comment">//不能对var声明的变量使用delete操作符</span></span><br><span class="line"><span class="string">"no-div-regex"</span>: <span class="number">1</span>,<span class="comment">//不能使用看起来像除法的正则表达式/=foo/</span></span><br><span class="line"><span class="string">"no-dupe-keys"</span>: <span class="number">2</span>,<span class="comment">//在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125;</span></span><br><span class="line"><span class="string">"no-dupe-args"</span>: <span class="number">2</span>,<span class="comment">//函数参数不能重复</span></span><br><span class="line"><span class="string">"no-duplicate-case"</span>: <span class="number">2</span>,<span class="comment">//switch中的case标签不能重复</span></span><br><span class="line"><span class="string">"no-else-return"</span>: <span class="number">2</span>,<span class="comment">//如果if语句里面有return,后面不能跟else语句</span></span><br><span class="line"><span class="string">"no-empty"</span>: <span class="number">2</span>,<span class="comment">//块语句中的内容不能为空</span></span><br><span class="line"><span class="string">"no-empty-character-class"</span>: <span class="number">2</span>,<span class="comment">//正则表达式中的[]内容不能为空</span></span><br><span class="line"><span class="string">"no-empty-label"</span>: <span class="number">2</span>,<span class="comment">//禁止使用空label</span></span><br><span class="line"><span class="string">"no-eq-null"</span>: <span class="number">2</span>,<span class="comment">//禁止对null使用==或!=运算符</span></span><br><span class="line"><span class="string">"no-eval"</span>: <span class="number">1</span>,<span class="comment">//禁止使用eval</span></span><br><span class="line"><span class="string">"no-ex-assign"</span>: <span class="number">2</span>,<span class="comment">//禁止给catch语句中的异常参数赋值</span></span><br><span class="line"><span class="string">"no-extend-native"</span>: <span class="number">2</span>,<span class="comment">//禁止扩展native对象</span></span><br><span class="line"><span class="string">"no-extra-bind"</span>: <span class="number">2</span>,<span class="comment">//禁止不必要的函数绑定</span></span><br><span class="line"><span class="string">"no-extra-boolean-cast"</span>: <span class="number">2</span>,<span class="comment">//禁止不必要的bool转换</span></span><br><span class="line"><span class="string">"no-extra-parens"</span>: <span class="number">2</span>,<span class="comment">//禁止非必要的括号</span></span><br><span class="line"><span class="string">"no-extra-semi"</span>: <span class="number">2</span>,<span class="comment">//禁止多余的冒号</span></span><br><span class="line"><span class="string">"no-fallthrough"</span>: <span class="number">1</span>,<span class="comment">//禁止switch穿透</span></span><br><span class="line"><span class="string">"no-floating-decimal"</span>: <span class="number">2</span>,<span class="comment">//禁止省略浮点数中的0 .5 3.</span></span><br><span class="line"><span class="string">"no-func-assign"</span>: <span class="number">2</span>,<span class="comment">//禁止重复的函数声明</span></span><br><span class="line"><span class="string">"no-implicit-coercion"</span>: <span class="number">1</span>,<span class="comment">//禁止隐式转换</span></span><br><span class="line"><span class="string">"no-implied-eval"</span>: <span class="number">2</span>,<span class="comment">//禁止使用隐式eval</span></span><br><span class="line"><span class="string">"no-inline-comments"</span>: <span class="number">0</span>,<span class="comment">//禁止行内备注</span></span><br><span class="line"><span class="string">"no-inner-declarations"</span>: [<span class="number">2</span>, <span class="string">"functions"</span>],<span class="comment">//禁止在块语句中使用声明（变量或函数）</span></span><br><span class="line"><span class="string">"no-invalid-regexp"</span>: <span class="number">2</span>,<span class="comment">//禁止无效的正则表达式</span></span><br><span class="line"><span class="string">"no-invalid-this"</span>: <span class="number">2</span>,<span class="comment">//禁止无效的this，只能用在构造器，类，对象字面量</span></span><br><span class="line"><span class="string">"no-irregular-whitespace"</span>: <span class="number">2</span>,<span class="comment">//不能有不规则的空格</span></span><br><span class="line"><span class="string">"no-iterator"</span>: <span class="number">2</span>,<span class="comment">//禁止使用__iterator__ 属性</span></span><br><span class="line"><span class="string">"no-label-var"</span>: <span class="number">2</span>,<span class="comment">//label名不能与var声明的变量名相同</span></span><br><span class="line"><span class="string">"no-labels"</span>: <span class="number">2</span>,<span class="comment">//禁止标签声明</span></span><br><span class="line"><span class="string">"no-lone-blocks"</span>: <span class="number">2</span>,<span class="comment">//禁止不必要的嵌套块</span></span><br><span class="line"><span class="string">"no-lonely-if"</span>: <span class="number">2</span>,<span class="comment">//禁止else语句内只有if语句</span></span><br><span class="line"><span class="string">"no-loop-func"</span>: <span class="number">1</span>,<span class="comment">//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）</span></span><br><span class="line"><span class="string">"no-mixed-requires"</span>: [<span class="number">0</span>, <span class="literal">false</span>],<span class="comment">//声明时不能混用声明类型</span></span><br><span class="line"><span class="string">"no-mixed-spaces-and-tabs"</span>: [<span class="number">2</span>, <span class="literal">false</span>],<span class="comment">//禁止混用tab和空格</span></span><br><span class="line"><span class="string">"linebreak-style"</span>: [<span class="number">0</span>, <span class="string">"windows"</span>],<span class="comment">//换行风格</span></span><br><span class="line"><span class="string">"no-multi-spaces"</span>: <span class="number">0</span>,<span class="comment">//不能用多余的空格</span></span><br><span class="line"><span class="string">"no-multi-str"</span>: <span class="number">2</span>,<span class="comment">//字符串不能用\换行</span></span><br><span class="line"><span class="string">"no-multiple-empty-lines"</span>: [<span class="number">1</span>, &#123;<span class="string">"max"</span>: <span class="number">3</span>&#125;],<span class="comment">//空行最多不能超过2行</span></span><br><span class="line"><span class="string">"no-native-reassign"</span>: <span class="number">2</span>,<span class="comment">//不能重写native对象</span></span><br><span class="line"><span class="string">"no-negated-in-lhs"</span>: <span class="number">2</span>,<span class="comment">//in 操作符的左边不能有!</span></span><br><span class="line"><span class="string">"no-nested-ternary"</span>: <span class="number">0</span>,<span class="comment">//禁止使用嵌套的三目运算</span></span><br><span class="line"><span class="string">"no-new"</span>: <span class="number">1</span>,<span class="comment">//禁止在使用new构造一个实例后不赋值</span></span><br><span class="line"><span class="string">"no-new-func"</span>: <span class="number">1</span>,<span class="comment">//禁止使用new Function</span></span><br><span class="line"><span class="string">"no-new-object"</span>: <span class="number">2</span>,<span class="comment">//禁止使用new Object()</span></span><br><span class="line"><span class="string">"no-new-require"</span>: <span class="number">2</span>,<span class="comment">//禁止使用new require</span></span><br><span class="line"><span class="string">"no-new-wrappers"</span>: <span class="number">2</span>,<span class="comment">//禁止使用new创建包装实例，new String new Boolean new Number</span></span><br><span class="line"><span class="string">"no-obj-calls"</span>: <span class="number">2</span>,<span class="comment">//不能调用内置的全局对象，比如Math() JSON()</span></span><br><span class="line"><span class="string">"no-octal"</span>: <span class="number">2</span>,<span class="comment">//禁止使用八进制数字</span></span><br><span class="line"><span class="string">"no-octal-escape"</span>: <span class="number">2</span>,<span class="comment">//禁止使用八进制转义序列</span></span><br><span class="line"><span class="string">"no-param-reassign"</span>: <span class="number">2</span>,<span class="comment">//禁止给参数重新赋值</span></span><br><span class="line"><span class="string">"no-path-concat"</span>: <span class="number">0</span>,<span class="comment">//node中不能使用__dirname或__filename做路径拼接</span></span><br><span class="line"><span class="string">"no-plusplus"</span>: <span class="number">0</span>,<span class="comment">//禁止使用++，--</span></span><br><span class="line"><span class="string">"no-process-env"</span>: <span class="number">0</span>,<span class="comment">//禁止使用process.env</span></span><br><span class="line"><span class="string">"no-process-exit"</span>: <span class="number">0</span>,<span class="comment">//禁止使用process.exit()</span></span><br><span class="line"><span class="string">"no-proto"</span>: <span class="number">2</span>,<span class="comment">//禁止使用__proto__属性</span></span><br><span class="line"><span class="string">"no-redeclare"</span>: <span class="number">2</span>,<span class="comment">//禁止重复声明变量</span></span><br><span class="line"><span class="string">"no-regex-spaces"</span>: <span class="number">2</span>,<span class="comment">//禁止在正则表达式字面量中使用多个空格 /foo bar/</span></span><br><span class="line"><span class="string">"no-restricted-modules"</span>: <span class="number">0</span>,<span class="comment">//如果禁用了指定模块，使用就会报错</span></span><br><span class="line"><span class="string">"no-return-assign"</span>: <span class="number">1</span>,<span class="comment">//return 语句中不能有赋值表达式</span></span><br><span class="line"><span class="string">"no-script-url"</span>: <span class="number">0</span>,<span class="comment">//禁止使用javascript:void(0)</span></span><br><span class="line"><span class="string">"no-self-compare"</span>: <span class="number">2</span>,<span class="comment">//不能比较自身</span></span><br><span class="line"><span class="string">"no-sequences"</span>: <span class="number">0</span>,<span class="comment">//禁止使用逗号运算符</span></span><br><span class="line"><span class="string">"no-shadow"</span>: <span class="number">2</span>,<span class="comment">//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名</span></span><br><span class="line"><span class="string">"no-shadow-restricted-names"</span>: <span class="number">2</span>,<span class="comment">//严格模式中规定的限制标识符不能作为声明时的变量名使用</span></span><br><span class="line"><span class="string">"no-spaced-func"</span>: <span class="number">2</span>,<span class="comment">//函数调用时 函数名与()之间不能有空格</span></span><br><span class="line"><span class="string">"no-sparse-arrays"</span>: <span class="number">2</span>,<span class="comment">//禁止稀疏数组， [1,,2]</span></span><br><span class="line"><span class="string">"no-sync"</span>: <span class="number">0</span>,<span class="comment">//nodejs 禁止同步方法</span></span><br><span class="line"><span class="string">"no-ternary"</span>: <span class="number">0</span>,<span class="comment">//禁止使用三目运算符</span></span><br><span class="line"><span class="string">"no-trailing-spaces"</span>: <span class="number">1</span>,<span class="comment">//一行结束后面不要有空格</span></span><br><span class="line"><span class="string">"no-this-before-super"</span>: <span class="number">0</span>,<span class="comment">//在调用super()之前不能使用this或super</span></span><br><span class="line"><span class="string">"no-throw-literal"</span>: <span class="number">2</span>,<span class="comment">//禁止抛出字面量错误 throw "error";</span></span><br><span class="line"><span class="string">"no-undef"</span>: <span class="number">2</span>,<span class="comment">//不能有未定义的变量</span></span><br><span class="line"><span class="string">"no-undef-init"</span>: <span class="number">2</span>,<span class="comment">//变量初始化时不能直接给它赋值为undefined</span></span><br><span class="line"><span class="string">"no-undefined"</span>: <span class="number">2</span>,<span class="comment">//不能使用undefined</span></span><br><span class="line"><span class="string">"no-unexpected-multiline"</span>: <span class="number">2</span>,<span class="comment">//避免多行表达式</span></span><br><span class="line"><span class="string">"no-underscore-dangle"</span>: <span class="number">1</span>,<span class="comment">//标识符不能以_开头或结尾</span></span><br><span class="line"><span class="string">"no-unneeded-ternary"</span>: <span class="number">2</span>,<span class="comment">//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;</span></span><br><span class="line"><span class="string">"no-unreachable"</span>: <span class="number">2</span>,<span class="comment">//不能有无法执行的代码</span></span><br><span class="line"><span class="string">"no-unused-expressions"</span>: <span class="number">2</span>,<span class="comment">//禁止无用的表达式</span></span><br><span class="line"><span class="string">"no-unused-vars"</span>: [<span class="number">2</span>, &#123;<span class="string">"vars"</span>: <span class="string">"all"</span>, <span class="string">"args"</span>: <span class="string">"after-used"</span>&#125;],<span class="comment">//不能有声明后未被使用的变量或参数</span></span><br><span class="line"><span class="string">"no-use-before-define"</span>: <span class="number">2</span>,<span class="comment">//未定义前不能使用</span></span><br><span class="line"><span class="string">"no-useless-call"</span>: <span class="number">2</span>,<span class="comment">//禁止不必要的call和apply</span></span><br><span class="line"><span class="string">"no-void"</span>: <span class="number">2</span>,<span class="comment">//禁用void操作符</span></span><br><span class="line"><span class="string">"no-var"</span>: <span class="number">0</span>,<span class="comment">//禁用var，用let和const代替</span></span><br><span class="line"><span class="string">"no-warning-comments"</span>: [<span class="number">1</span>, &#123; <span class="string">"terms"</span>: [<span class="string">"todo"</span>, <span class="string">"fixme"</span>, <span class="string">"xxx"</span>], <span class="string">"location"</span>: <span class="string">"start"</span> &#125;],<span class="comment">//不能有警告备注</span></span><br><span class="line"><span class="string">"no-with"</span>: <span class="number">2</span>,<span class="comment">//禁用with</span></span><br><span class="line"></span><br><span class="line"><span class="string">"array-bracket-spacing"</span>: [<span class="number">2</span>, <span class="string">"never"</span>],<span class="comment">//是否允许非空数组里面有多余的空格</span></span><br><span class="line"><span class="string">"arrow-parens"</span>: <span class="number">0</span>,<span class="comment">//箭头函数用小括号括起来</span></span><br><span class="line"><span class="string">"arrow-spacing"</span>: <span class="number">0</span>,<span class="comment">//=&gt;的前/后括号</span></span><br><span class="line"><span class="string">"accessor-pairs"</span>: <span class="number">0</span>,<span class="comment">//在对象中使用getter/setter</span></span><br><span class="line"><span class="string">"block-scoped-var"</span>: <span class="number">0</span>,<span class="comment">//块语句中使用var</span></span><br><span class="line"><span class="string">"brace-style"</span>: [<span class="number">1</span>, <span class="string">"1tbs"</span>],<span class="comment">//大括号风格</span></span><br><span class="line"><span class="string">"callback-return"</span>: <span class="number">1</span>,<span class="comment">//避免多次调用回调什么的</span></span><br><span class="line"><span class="string">"camelcase"</span>: <span class="number">2</span>,<span class="comment">//强制驼峰法命名</span></span><br><span class="line"><span class="string">"comma-dangle"</span>: [<span class="number">2</span>, <span class="string">"never"</span>],<span class="comment">//对象字面量项尾不能有逗号</span></span><br><span class="line"><span class="string">"comma-spacing"</span>: <span class="number">0</span>,<span class="comment">//逗号前后的空格</span></span><br><span class="line"><span class="string">"comma-style"</span>: [<span class="number">2</span>, <span class="string">"last"</span>],<span class="comment">//逗号风格，换行时在行首还是行尾</span></span><br><span class="line"><span class="string">"complexity"</span>: [<span class="number">0</span>, <span class="number">11</span>],<span class="comment">//循环复杂度</span></span><br><span class="line"><span class="string">"computed-property-spacing"</span>: [<span class="number">0</span>, <span class="string">"never"</span>],<span class="comment">//是否允许计算后的键名什么的</span></span><br><span class="line"><span class="string">"consistent-return"</span>: <span class="number">0</span>,<span class="comment">//return 后面是否允许省略</span></span><br><span class="line"><span class="string">"consistent-this"</span>: [<span class="number">2</span>, <span class="string">"that"</span>],<span class="comment">//this别名</span></span><br><span class="line"><span class="string">"constructor-super"</span>: <span class="number">0</span>,<span class="comment">//非派生类不能调用super，派生类必须调用super</span></span><br><span class="line"><span class="string">"curly"</span>: [<span class="number">2</span>, <span class="string">"all"</span>],<span class="comment">//必须使用 if()&#123;&#125; 中的&#123;&#125;</span></span><br><span class="line"><span class="string">"default-case"</span>: <span class="number">2</span>,<span class="comment">//switch语句最后必须有default</span></span><br><span class="line"><span class="string">"dot-location"</span>: <span class="number">0</span>,<span class="comment">//对象访问符的位置，换行的时候在行首还是行尾</span></span><br><span class="line"><span class="string">"dot-notation"</span>: [<span class="number">0</span>, &#123; <span class="string">"allowKeywords"</span>: <span class="literal">true</span> &#125;],<span class="comment">//避免不必要的方括号</span></span><br><span class="line"><span class="string">"eol-last"</span>: <span class="number">0</span>,<span class="comment">//文件以单一的换行符结束</span></span><br><span class="line"><span class="string">"eqeqeq"</span>: <span class="number">0</span>,<span class="comment">//必须使用全等</span></span><br><span class="line"><span class="string">"func-names"</span>: <span class="number">0</span>,<span class="comment">//函数表达式必须有名字</span></span><br><span class="line"><span class="string">"func-style"</span>: [<span class="number">0</span>, <span class="string">"declaration"</span>],<span class="comment">//函数风格，规定只能使用函数声明/函数表达式</span></span><br><span class="line"><span class="string">"generator-star-spacing"</span>: <span class="number">0</span>,<span class="comment">//生成器函数*的前后空格</span></span><br><span class="line"><span class="string">"guard-for-in"</span>: <span class="number">0</span>,<span class="comment">//for in循环要用if语句过滤</span></span><br><span class="line"><span class="string">"handle-callback-err"</span>: <span class="number">0</span>,<span class="comment">//nodejs 处理错误</span></span><br><span class="line"><span class="string">"id-length"</span>: <span class="number">0</span>,<span class="comment">//变量名长度</span></span><br><span class="line"><span class="string">"indent"</span>: [<span class="number">2</span>, <span class="number">2</span>],<span class="comment">//缩进风格</span></span><br><span class="line"><span class="string">"init-declarations"</span>: <span class="number">0</span>,<span class="comment">//声明时必须赋初值</span></span><br><span class="line"><span class="string">"key-spacing"</span>: [<span class="number">0</span>, &#123; <span class="string">"beforeColon"</span>: <span class="literal">false</span>, <span class="string">"afterColon"</span>: <span class="literal">true</span> &#125;],<span class="comment">//对象字面量中冒号的前后空格</span></span><br><span class="line"><span class="string">"lines-around-comment"</span>: <span class="number">0</span>,<span class="comment">//行前/行后备注</span></span><br><span class="line"><span class="string">"max-depth"</span>: [<span class="number">0</span>, <span class="number">4</span>],<span class="comment">//嵌套块深度</span></span><br><span class="line"><span class="string">"max-len"</span>: [<span class="number">0</span>, <span class="number">80</span>, <span class="number">4</span>],<span class="comment">//字符串最大长度</span></span><br><span class="line"><span class="string">"max-nested-callbacks"</span>: [<span class="number">0</span>, <span class="number">2</span>],<span class="comment">//回调嵌套深度</span></span><br><span class="line"><span class="string">"max-params"</span>: [<span class="number">0</span>, <span class="number">3</span>],<span class="comment">//函数最多只能有3个参数</span></span><br><span class="line"><span class="string">"max-statements"</span>: [<span class="number">0</span>, <span class="number">10</span>],<span class="comment">//函数内最多有几个声明</span></span><br><span class="line"><span class="string">"new-cap"</span>: <span class="number">2</span>,<span class="comment">//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用</span></span><br><span class="line"><span class="string">"new-parens"</span>: <span class="number">2</span>,<span class="comment">//new时必须加小括号</span></span><br><span class="line"><span class="string">"newline-after-var"</span>: <span class="number">2</span>,<span class="comment">//变量声明后是否需要空一行</span></span><br><span class="line"><span class="string">"object-curly-spacing"</span>: [<span class="number">0</span>, <span class="string">"never"</span>],<span class="comment">//大括号内是否允许不必要的空格</span></span><br><span class="line"><span class="string">"object-shorthand"</span>: <span class="number">0</span>,<span class="comment">//强制对象字面量缩写语法</span></span><br><span class="line"><span class="string">"one-var"</span>: <span class="number">1</span>,<span class="comment">//连续声明</span></span><br><span class="line"><span class="string">"operator-assignment"</span>: [<span class="number">0</span>, <span class="string">"always"</span>],<span class="comment">//赋值运算符 += -=什么的</span></span><br><span class="line"><span class="string">"operator-linebreak"</span>: [<span class="number">2</span>, <span class="string">"after"</span>],<span class="comment">//换行时运算符在行尾还是行首</span></span><br><span class="line"><span class="string">"padded-blocks"</span>: <span class="number">0</span>,<span class="comment">//块语句内行首行尾是否要空行</span></span><br><span class="line"><span class="string">"prefer-const"</span>: <span class="number">0</span>,<span class="comment">//首选const</span></span><br><span class="line"><span class="string">"prefer-spread"</span>: <span class="number">0</span>,<span class="comment">//首选展开运算</span></span><br><span class="line"><span class="string">"prefer-reflect"</span>: <span class="number">0</span>,<span class="comment">//首选Reflect的方法</span></span><br><span class="line"><span class="string">"quotes"</span>: [<span class="number">1</span>, <span class="string">"single"</span>],<span class="comment">//引号类型 `` "" ''</span></span><br><span class="line"><span class="string">"quote-props"</span>:[<span class="number">2</span>, <span class="string">"always"</span>],<span class="comment">//对象字面量中的属性名是否强制双引号</span></span><br><span class="line"><span class="string">"radix"</span>: <span class="number">2</span>,<span class="comment">//parseInt必须指定第二个参数</span></span><br><span class="line"><span class="string">"id-match"</span>: <span class="number">0</span>,<span class="comment">//命名检测</span></span><br><span class="line"><span class="string">"require-yield"</span>: <span class="number">0</span>,<span class="comment">//生成器函数必须有yield</span></span><br><span class="line"><span class="string">"semi"</span>: [<span class="number">2</span>, <span class="string">"always"</span>],<span class="comment">//语句强制分号结尾</span></span><br><span class="line"><span class="string">"semi-spacing"</span>: [<span class="number">0</span>, &#123;<span class="string">"before"</span>: <span class="literal">false</span>, <span class="string">"after"</span>: <span class="literal">true</span>&#125;],<span class="comment">//分号前后空格</span></span><br><span class="line"><span class="string">"sort-vars"</span>: <span class="number">0</span>,<span class="comment">//变量声明时排序</span></span><br><span class="line"><span class="string">"space-after-keywords"</span>: [<span class="number">0</span>, <span class="string">"always"</span>],<span class="comment">//关键字后面是否要空一格</span></span><br><span class="line"><span class="string">"space-before-blocks"</span>: [<span class="number">0</span>, <span class="string">"always"</span>],<span class="comment">//不以新行开始的块&#123;前面要不要有空格</span></span><br><span class="line"><span class="string">"space-before-function-paren"</span>: [<span class="number">0</span>, <span class="string">"always"</span>],<span class="comment">//函数定义时括号前面要不要有空格</span></span><br><span class="line"><span class="string">"space-in-parens"</span>: [<span class="number">0</span>, <span class="string">"never"</span>],<span class="comment">//小括号里面要不要有空格</span></span><br><span class="line"><span class="string">"space-infix-ops"</span>: <span class="number">0</span>,<span class="comment">//中缀操作符周围要不要有空格</span></span><br><span class="line"><span class="string">"space-return-throw-case"</span>: <span class="number">2</span>,<span class="comment">//return throw case后面要不要加空格</span></span><br><span class="line"><span class="string">"space-unary-ops"</span>: [<span class="number">0</span>, &#123; <span class="string">"words"</span>: <span class="literal">true</span>, <span class="string">"nonwords"</span>: <span class="literal">false</span> &#125;],<span class="comment">//一元运算符的前/后要不要加空格</span></span><br><span class="line"><span class="string">"spaced-comment"</span>: <span class="number">0</span>,<span class="comment">//注释风格要不要有空格什么的</span></span><br><span class="line"><span class="string">"strict"</span>: <span class="number">2</span>,<span class="comment">//使用严格模式</span></span><br><span class="line"><span class="string">"use-isnan"</span>: <span class="number">2</span>,<span class="comment">//禁止比较时使用NaN，只能用isNaN()</span></span><br><span class="line"><span class="string">"valid-jsdoc"</span>: <span class="number">0</span>,<span class="comment">//jsdoc规则</span></span><br><span class="line"><span class="string">"valid-typeof"</span>: <span class="number">2</span>,<span class="comment">//必须使用合法的typeof的值</span></span><br><span class="line"><span class="string">"vars-on-top"</span>: <span class="number">2</span>,<span class="comment">//var必须放在作用域顶部</span></span><br><span class="line"><span class="string">"wrap-iife"</span>: [<span class="number">2</span>, <span class="string">"inside"</span>],<span class="comment">//立即执行函数表达式的小括号风格</span></span><br><span class="line"><span class="string">"wrap-regex"</span>: <span class="number">0</span>,<span class="comment">//正则表达式字面量用小括号包起来</span></span><br><span class="line"><span class="string">"yoda"</span>: [<span class="number">2</span>, <span class="string">"never"</span>]<span class="comment">//禁止尤达条件</span></span><br></pre></td></tr></table></figure><p>vue 2.0 自定义规则如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  root: <span class="literal">true</span>,</span><br><span class="line">  parser: <span class="string">'babel-eslint'</span>,</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    sourceType: <span class="string">'module'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// required to lint *.vue files</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="string">'html'</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// add your custom rules here</span></span><br><span class="line">  <span class="string">'rules'</span>: &#123;</span><br><span class="line">    <span class="comment">// allow debugger during development</span></span><br><span class="line">    <span class="string">'no-debugger'</span>: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="number">2</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="string">"no-alert"</span>: <span class="number">0</span>,<span class="comment">//禁止使用alert confirm prompt</span></span><br><span class="line">    <span class="string">"no-array-constructor"</span>: <span class="number">2</span>,<span class="comment">//禁止使用数组构造器</span></span><br><span class="line">    <span class="string">"no-bitwise"</span>: <span class="number">0</span>,<span class="comment">//禁止使用按位运算符</span></span><br><span class="line">    <span class="string">"no-caller"</span>: <span class="number">1</span>,<span class="comment">//禁止使用arguments.caller或arguments.callee</span></span><br><span class="line">    <span class="string">"no-catch-shadow"</span>: <span class="number">2</span>,<span class="comment">//禁止catch子句参数与外部作用域变量同名</span></span><br><span class="line">    <span class="string">"no-class-assign"</span>: <span class="number">2</span>,<span class="comment">//禁止给类赋值</span></span><br><span class="line">    <span class="string">"no-cond-assign"</span>: <span class="number">2</span>,<span class="comment">//禁止在条件表达式中使用赋值语句</span></span><br><span class="line">    <span class="string">"no-console"</span>: <span class="number">2</span>,<span class="comment">//禁止使用console</span></span><br><span class="line">    <span class="string">"no-const-assign"</span>: <span class="number">2</span>,<span class="comment">//禁止修改const声明的变量</span></span><br><span class="line">    <span class="string">"no-constant-condition"</span>: <span class="number">2</span>,<span class="comment">//禁止在条件中使用常量表达式 if(true) if(1)</span></span><br><span class="line">    <span class="string">"no-continue"</span>: <span class="number">0</span>,<span class="comment">//禁止使用continue</span></span><br><span class="line">    <span class="string">"no-control-regex"</span>: <span class="number">2</span>,<span class="comment">//禁止在正则表达式中使用控制字符</span></span><br><span class="line">    <span class="string">"no-debugger"</span>: <span class="number">2</span>,<span class="comment">//禁止使用debugger</span></span><br><span class="line">    <span class="string">"no-delete-var"</span>: <span class="number">2</span>,<span class="comment">//不能对var声明的变量使用delete操作符</span></span><br><span class="line">    <span class="string">"no-div-regex"</span>: <span class="number">1</span>,<span class="comment">//不能使用看起来像除法的正则表达式/=foo/</span></span><br><span class="line">    <span class="string">"no-dupe-keys"</span>: <span class="number">2</span>,<span class="comment">//在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125;</span></span><br><span class="line">    <span class="string">"no-dupe-args"</span>: <span class="number">2</span>,<span class="comment">//函数参数不能重复</span></span><br><span class="line">    <span class="string">"no-duplicate-case"</span>: <span class="number">2</span>,<span class="comment">//switch中的case标签不能重复</span></span><br><span class="line">    <span class="string">"no-else-return"</span>: <span class="number">2</span>,<span class="comment">//如果if语句里面有return,后面不能跟else语句</span></span><br><span class="line">    <span class="string">"no-empty"</span>: <span class="number">0</span>,<span class="comment">//块语句中的内容不能为空</span></span><br><span class="line">    <span class="string">"no-empty-character-class"</span>: <span class="number">2</span>,<span class="comment">//正则表达式中的[]内容不能为空</span></span><br><span class="line">    <span class="string">"no-eq-null"</span>: <span class="number">2</span>,<span class="comment">//禁止对null使用==或!=运算符</span></span><br><span class="line">    <span class="string">"no-eval"</span>: <span class="number">1</span>,<span class="comment">//禁止使用eval</span></span><br><span class="line">    <span class="string">"no-ex-assign"</span>: <span class="number">2</span>,<span class="comment">//禁止给catch语句中的异常参数赋值</span></span><br><span class="line">    <span class="string">"no-extend-native"</span>: <span class="number">2</span>,<span class="comment">//禁止扩展native对象</span></span><br><span class="line">    <span class="string">"no-extra-bind"</span>: <span class="number">2</span>,<span class="comment">//禁止不必要的函数绑定</span></span><br><span class="line">    <span class="string">"no-extra-boolean-cast"</span>: <span class="number">2</span>,<span class="comment">//禁止不必要的bool转换</span></span><br><span class="line">    <span class="string">"no-extra-parens"</span>: <span class="number">2</span>,<span class="comment">//禁止非必要的括号</span></span><br><span class="line">    <span class="string">"no-extra-semi"</span>: <span class="number">2</span>,<span class="comment">//禁止多余的冒号</span></span><br><span class="line">    <span class="string">"no-fallthrough"</span>: <span class="number">1</span>,<span class="comment">//禁止switch穿透</span></span><br><span class="line">    <span class="string">"no-floating-decimal"</span>: <span class="number">2</span>,<span class="comment">//禁止省略浮点数中的0 .5 3.</span></span><br><span class="line">    <span class="string">"no-func-assign"</span>: <span class="number">2</span>,<span class="comment">//禁止重复的函数声明</span></span><br><span class="line">    <span class="string">"no-implicit-coercion"</span>: <span class="number">1</span>,<span class="comment">//禁止隐式转换</span></span><br><span class="line">    <span class="string">"no-implied-eval"</span>: <span class="number">2</span>,<span class="comment">//禁止使用隐式eval</span></span><br><span class="line">    <span class="string">"no-inline-comments"</span>: <span class="number">0</span>,<span class="comment">//禁止行内备注</span></span><br><span class="line">    <span class="string">"no-inner-declarations"</span>: [<span class="number">2</span>, <span class="string">"functions"</span>],<span class="comment">//禁止在块语句中使用声明（变量或函数）</span></span><br><span class="line">    <span class="string">"no-invalid-regexp"</span>: <span class="number">2</span>,<span class="comment">//禁止无效的正则表达式</span></span><br><span class="line">    <span class="string">"no-invalid-this"</span>: <span class="number">2</span>,<span class="comment">//禁止无效的this，只能用在构造器，类，对象字面量</span></span><br><span class="line">    <span class="string">"no-irregular-whitespace"</span>: <span class="number">2</span>,<span class="comment">//不能有不规则的空格</span></span><br><span class="line">    <span class="string">"no-iterator"</span>: <span class="number">2</span>,<span class="comment">//禁止使用__iterator__ 属性</span></span><br><span class="line">    <span class="string">"no-label-var"</span>: <span class="number">2</span>,<span class="comment">//label名不能与var声明的变量名相同</span></span><br><span class="line">    <span class="string">"no-labels"</span>: <span class="number">0</span>,<span class="comment">//禁止标签声明</span></span><br><span class="line">    <span class="string">"no-lone-blocks"</span>: <span class="number">2</span>,<span class="comment">//禁止不必要的嵌套块</span></span><br><span class="line">    <span class="string">"no-lonely-if"</span>: <span class="number">2</span>,<span class="comment">//禁止else语句内只有if语句</span></span><br><span class="line">    <span class="string">"no-loop-func"</span>: <span class="number">1</span>,<span class="comment">//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）</span></span><br><span class="line">    <span class="string">"no-mixed-requires"</span>: [<span class="number">0</span>, <span class="literal">false</span>],<span class="comment">//声明时不能混用声明类型</span></span><br><span class="line">    <span class="string">"no-mixed-spaces-and-tabs"</span>: [<span class="number">2</span>, <span class="literal">false</span>],<span class="comment">//禁止混用tab和空格</span></span><br><span class="line">    <span class="string">"linebreak-style"</span>: [<span class="number">0</span>, <span class="string">"windows"</span>],<span class="comment">//换行风格</span></span><br><span class="line">    <span class="string">"no-multi-spaces"</span>: <span class="number">0</span>,<span class="comment">//不能用多余的空格</span></span><br><span class="line">    <span class="string">"no-multi-str"</span>: <span class="number">2</span>,<span class="comment">//字符串不能用\换行</span></span><br><span class="line">    <span class="string">"no-multiple-empty-lines"</span>: [<span class="number">1</span>, &#123;<span class="string">"max"</span>: <span class="number">3</span>&#125;],<span class="comment">//空行最多不能超过2行</span></span><br><span class="line">    <span class="string">"no-native-reassign"</span>: <span class="number">2</span>,<span class="comment">//不能重写native对象</span></span><br><span class="line">    <span class="string">"no-negated-in-lhs"</span>: <span class="number">2</span>,<span class="comment">//in 操作符的左边不能有!</span></span><br><span class="line">    <span class="string">"no-nested-ternary"</span>: <span class="number">0</span>,<span class="comment">//禁止使用嵌套的三目运算</span></span><br><span class="line">    <span class="string">"no-new"</span>: <span class="number">1</span>,<span class="comment">//禁止在使用new构造一个实例后不赋值</span></span><br><span class="line">    <span class="string">"no-new-func"</span>: <span class="number">1</span>,<span class="comment">//禁止使用new Function</span></span><br><span class="line">    <span class="string">"no-new-object"</span>: <span class="number">2</span>,<span class="comment">//禁止使用new Object()</span></span><br><span class="line">    <span class="string">"no-new-require"</span>: <span class="number">2</span>,<span class="comment">//禁止使用new require</span></span><br><span class="line">    <span class="string">"no-new-wrappers"</span>: <span class="number">2</span>,<span class="comment">//禁止使用new创建包装实例，new String new Boolean new Number</span></span><br><span class="line">    <span class="string">"no-obj-calls"</span>: <span class="number">2</span>,<span class="comment">//不能调用内置的全局对象，比如Math() JSON()</span></span><br><span class="line">    <span class="string">"no-octal"</span>: <span class="number">2</span>,<span class="comment">//禁止使用八进制数字</span></span><br><span class="line">    <span class="string">"no-octal-escape"</span>: <span class="number">2</span>,<span class="comment">//禁止使用八进制转义序列</span></span><br><span class="line">    <span class="string">"no-param-reassign"</span>: <span class="number">2</span>,<span class="comment">//禁止给参数重新赋值</span></span><br><span class="line">    <span class="string">"no-path-concat"</span>: <span class="number">0</span>,<span class="comment">//node中不能使用__dirname或__filename做路径拼接</span></span><br><span class="line">    <span class="string">"no-plusplus"</span>: <span class="number">0</span>,<span class="comment">//禁止使用++，--</span></span><br><span class="line">    <span class="string">"no-process-env"</span>: <span class="number">0</span>,<span class="comment">//禁止使用process.env</span></span><br><span class="line">    <span class="string">"no-process-exit"</span>: <span class="number">0</span>,<span class="comment">//禁止使用process.exit()</span></span><br><span class="line">    <span class="string">"no-proto"</span>: <span class="number">2</span>,<span class="comment">//禁止使用__proto__属性</span></span><br><span class="line">    <span class="string">"no-redeclare"</span>: <span class="number">2</span>,<span class="comment">//禁止重复声明变量</span></span><br><span class="line">    <span class="string">"no-regex-spaces"</span>: <span class="number">2</span>,<span class="comment">//禁止在正则表达式字面量中使用多个空格 /foo bar/</span></span><br><span class="line">    <span class="string">"no-restricted-modules"</span>: <span class="number">0</span>,<span class="comment">//如果禁用了指定模块，使用就会报错</span></span><br><span class="line">    <span class="string">"no-return-assign"</span>: <span class="number">1</span>,<span class="comment">//return 语句中不能有赋值表达式</span></span><br><span class="line">    <span class="string">"no-script-url"</span>: <span class="number">0</span>,<span class="comment">//禁止使用javascript:void(0)</span></span><br><span class="line">    <span class="string">"no-self-compare"</span>: <span class="number">2</span>,<span class="comment">//不能比较自身</span></span><br><span class="line">    <span class="string">"no-sequences"</span>: <span class="number">0</span>,<span class="comment">//禁止使用逗号运算符</span></span><br><span class="line">    <span class="string">"no-shadow"</span>: <span class="number">2</span>,<span class="comment">//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名</span></span><br><span class="line">    <span class="string">"no-shadow-restricted-names"</span>: <span class="number">2</span>,<span class="comment">//严格模式中规定的限制标识符不能作为声明时的变量名使用</span></span><br><span class="line">    <span class="string">"no-spaced-func"</span>: <span class="number">2</span>,<span class="comment">//函数调用时 函数名与()之间不能有空格</span></span><br><span class="line">    <span class="string">"no-sparse-arrays"</span>: <span class="number">2</span>,<span class="comment">//禁止稀疏数组， [1,,2]</span></span><br><span class="line">    <span class="string">"no-sync"</span>: <span class="number">0</span>,<span class="comment">//nodejs 禁止同步方法</span></span><br><span class="line">    <span class="string">"no-ternary"</span>: <span class="number">0</span>,<span class="comment">//禁止使用三目运算符</span></span><br><span class="line">    <span class="string">"no-trailing-spaces"</span>: <span class="number">1</span>,<span class="comment">//一行结束后面不要有空格</span></span><br><span class="line">    <span class="string">"no-this-before-super"</span>: <span class="number">0</span>,<span class="comment">//在调用super()之前不能使用this或super</span></span><br><span class="line">    <span class="string">"no-throw-literal"</span>: <span class="number">2</span>,<span class="comment">//禁止抛出字面量错误 throw "error";</span></span><br><span class="line">    <span class="string">"no-undef"</span>: <span class="number">2</span>,<span class="comment">//不能有未定义的变量</span></span><br><span class="line">    <span class="string">"no-undef-init"</span>: <span class="number">2</span>,<span class="comment">//变量初始化时不能直接给它赋值为undefined</span></span><br><span class="line">    <span class="string">"no-undefined"</span>: <span class="number">2</span>,<span class="comment">//不能使用undefined</span></span><br><span class="line">    <span class="string">"no-unexpected-multiline"</span>: <span class="number">2</span>,<span class="comment">//避免多行表达式</span></span><br><span class="line">    <span class="string">"no-underscore-dangle"</span>: <span class="number">1</span>,<span class="comment">//标识符不能以_开头或结尾</span></span><br><span class="line">    <span class="string">"no-unneeded-ternary"</span>: <span class="number">2</span>,<span class="comment">//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;</span></span><br><span class="line">    <span class="string">"no-unreachable"</span>: <span class="number">2</span>,<span class="comment">//不能有无法执行的代码</span></span><br><span class="line">    <span class="string">"no-unused-expressions"</span>: <span class="number">2</span>,<span class="comment">//禁止无用的表达式</span></span><br><span class="line">    <span class="string">"no-unused-vars"</span>: [<span class="number">2</span>, &#123;<span class="string">"vars"</span>: <span class="string">"all"</span>, <span class="string">"args"</span>: <span class="string">"after-used"</span>&#125;],<span class="comment">//不能有声明后未被使用的变量或参数</span></span><br><span class="line">    <span class="string">"no-use-before-define"</span>: <span class="number">2</span>,<span class="comment">//未定义前不能使用</span></span><br><span class="line">    <span class="string">"no-useless-call"</span>: <span class="number">2</span>,<span class="comment">//禁止不必要的call和apply</span></span><br><span class="line">    <span class="string">"no-void"</span>: <span class="number">2</span>,<span class="comment">//禁用void操作符</span></span><br><span class="line">    <span class="string">"no-var"</span>: <span class="number">0</span>,<span class="comment">//禁用var，用let和const代替</span></span><br><span class="line">    <span class="string">"no-warning-comments"</span>: [<span class="number">1</span>, &#123; <span class="string">"terms"</span>: [<span class="string">"todo"</span>, <span class="string">"fixme"</span>, <span class="string">"xxx"</span>], <span class="string">"location"</span>: <span class="string">"start"</span> &#125;],<span class="comment">//不能有警告备注</span></span><br><span class="line">    <span class="string">"no-with"</span>: <span class="number">2</span>,<span class="comment">//禁用with</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"array-bracket-spacing"</span>: [<span class="number">2</span>, <span class="string">"never"</span>],<span class="comment">//是否允许非空数组里面有多余的空格</span></span><br><span class="line">    <span class="string">"arrow-parens"</span>: <span class="number">0</span>,<span class="comment">//箭头函数用小括号括起来</span></span><br><span class="line">    <span class="string">"arrow-spacing"</span>: <span class="number">0</span>,<span class="comment">//=&gt;的前/后括号</span></span><br><span class="line">    <span class="string">"accessor-pairs"</span>: <span class="number">0</span>,<span class="comment">//在对象中使用getter/setter</span></span><br><span class="line">    <span class="string">"block-scoped-var"</span>: <span class="number">0</span>,<span class="comment">//块语句中使用var</span></span><br><span class="line">    <span class="string">"brace-style"</span>: [<span class="number">1</span>, <span class="string">"1tbs"</span>],<span class="comment">//大括号风格</span></span><br><span class="line">    <span class="string">"callback-return"</span>: <span class="number">1</span>,<span class="comment">//避免多次调用回调什么的</span></span><br><span class="line">    <span class="string">"camelcase"</span>: <span class="number">2</span>,<span class="comment">//强制驼峰法命名</span></span><br><span class="line">    <span class="string">"comma-dangle"</span>: [<span class="number">2</span>, <span class="string">"never"</span>],<span class="comment">//对象字面量项尾不能有逗号</span></span><br><span class="line">    <span class="string">"comma-spacing"</span>: <span class="number">0</span>,<span class="comment">//逗号前后的空格</span></span><br><span class="line">    <span class="string">"comma-style"</span>: [<span class="number">2</span>, <span class="string">"last"</span>],<span class="comment">//逗号风格，换行时在行首还是行尾</span></span><br><span class="line">    <span class="string">"complexity"</span>: [<span class="number">0</span>, <span class="number">11</span>],<span class="comment">//循环复杂度</span></span><br><span class="line">    <span class="string">"computed-property-spacing"</span>: [<span class="number">0</span>, <span class="string">"never"</span>],<span class="comment">//是否允许计算后的键名什么的</span></span><br><span class="line">    <span class="string">"consistent-return"</span>: <span class="number">0</span>,<span class="comment">//return 后面是否允许省略</span></span><br><span class="line">    <span class="string">"consistent-this"</span>: [<span class="number">2</span>, <span class="string">"that"</span>],<span class="comment">//this别名</span></span><br><span class="line">    <span class="string">"constructor-super"</span>: <span class="number">0</span>,<span class="comment">//非派生类不能调用super，派生类必须调用super</span></span><br><span class="line">    <span class="string">"curly"</span>: [<span class="number">2</span>, <span class="string">"all"</span>],<span class="comment">//必须使用 if()&#123;&#125; 中的&#123;&#125;</span></span><br><span class="line">    <span class="string">"default-case"</span>: <span class="number">2</span>,<span class="comment">//switch语句最后必须有default</span></span><br><span class="line">    <span class="string">"dot-location"</span>: <span class="number">0</span>,<span class="comment">//对象访问符的位置，换行的时候在行首还是行尾</span></span><br><span class="line">    <span class="string">"dot-notation"</span>: [<span class="number">0</span>, &#123; <span class="string">"allowKeywords"</span>: <span class="literal">true</span> &#125;],<span class="comment">//避免不必要的方括号</span></span><br><span class="line">    <span class="string">"eol-last"</span>: <span class="number">0</span>,<span class="comment">//文件以单一的换行符结束</span></span><br><span class="line">    <span class="string">"eqeqeq"</span>: <span class="number">0</span>,<span class="comment">//必须使用全等</span></span><br><span class="line">    <span class="string">"func-names"</span>: <span class="number">0</span>,<span class="comment">//函数表达式必须有名字</span></span><br><span class="line">    <span class="string">"func-style"</span>: [<span class="number">0</span>, <span class="string">"declaration"</span>],<span class="comment">//函数风格，规定只能使用函数声明/函数表达式</span></span><br><span class="line">    <span class="string">"generator-star-spacing"</span>: <span class="number">0</span>,<span class="comment">//生成器函数*的前后空格</span></span><br><span class="line">    <span class="string">"guard-for-in"</span>: <span class="number">0</span>,<span class="comment">//for in循环要用if语句过滤</span></span><br><span class="line">    <span class="string">"handle-callback-err"</span>: <span class="number">0</span>,<span class="comment">//nodejs 处理错误</span></span><br><span class="line">    <span class="string">"id-length"</span>: <span class="number">0</span>,<span class="comment">//变量名长度</span></span><br><span class="line">    <span class="string">"indent"</span>: [<span class="number">2</span>, <span class="number">2</span>],<span class="comment">//缩进风格</span></span><br><span class="line">    <span class="string">"init-declarations"</span>: <span class="number">0</span>,<span class="comment">//声明时必须赋初值</span></span><br><span class="line">    <span class="string">"key-spacing"</span>: [<span class="number">0</span>, &#123; <span class="string">"beforeColon"</span>: <span class="literal">false</span>, <span class="string">"afterColon"</span>: <span class="literal">true</span> &#125;],<span class="comment">//对象字面量中冒号的前后空格</span></span><br><span class="line">    <span class="string">"lines-around-comment"</span>: <span class="number">0</span>,<span class="comment">//行前/行后备注</span></span><br><span class="line">    <span class="string">"max-depth"</span>: [<span class="number">0</span>, <span class="number">4</span>],<span class="comment">//嵌套块深度</span></span><br><span class="line">    <span class="string">"max-len"</span>: [<span class="number">0</span>, <span class="number">80</span>, <span class="number">4</span>],<span class="comment">//字符串最大长度</span></span><br><span class="line">    <span class="string">"max-nested-callbacks"</span>: [<span class="number">0</span>, <span class="number">2</span>],<span class="comment">//回调嵌套深度</span></span><br><span class="line">    <span class="string">"max-params"</span>: [<span class="number">0</span>, <span class="number">3</span>],<span class="comment">//函数最多只能有3个参数</span></span><br><span class="line">    <span class="string">"max-statements"</span>: [<span class="number">0</span>, <span class="number">10</span>],<span class="comment">//函数内最多有几个声明</span></span><br><span class="line">    <span class="string">"new-cap"</span>: <span class="number">2</span>,<span class="comment">//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用</span></span><br><span class="line">    <span class="string">"new-parens"</span>: <span class="number">2</span>,<span class="comment">//new时必须加小括号</span></span><br><span class="line">    <span class="string">"newline-after-var"</span>: <span class="number">2</span>,<span class="comment">//变量声明后是否需要空一行</span></span><br><span class="line">    <span class="string">"object-curly-spacing"</span>: [<span class="number">0</span>, <span class="string">"never"</span>],<span class="comment">//大括号内是否允许不必要的空格</span></span><br><span class="line">    <span class="string">"object-shorthand"</span>: <span class="number">0</span>,<span class="comment">//强制对象字面量缩写语法</span></span><br><span class="line">    <span class="string">"one-var"</span>: <span class="number">1</span>,<span class="comment">//连续声明</span></span><br><span class="line">    <span class="string">"operator-assignment"</span>: [<span class="number">0</span>, <span class="string">"always"</span>],<span class="comment">//赋值运算符 += -=什么的</span></span><br><span class="line">    <span class="string">"operator-linebreak"</span>: [<span class="number">2</span>, <span class="string">"after"</span>],<span class="comment">//换行时运算符在行尾还是行首</span></span><br><span class="line">    <span class="string">"padded-blocks"</span>: <span class="number">0</span>,<span class="comment">//块语句内行首行尾是否要空行</span></span><br><span class="line">    <span class="string">"prefer-const"</span>: <span class="number">0</span>,<span class="comment">//首选const</span></span><br><span class="line">    <span class="string">"prefer-spread"</span>: <span class="number">0</span>,<span class="comment">//首选展开运算</span></span><br><span class="line">    <span class="string">"prefer-reflect"</span>: <span class="number">0</span>,<span class="comment">//首选Reflect的方法</span></span><br><span class="line">    <span class="string">"quotes"</span>: [<span class="number">0</span>, <span class="string">"single"</span>],<span class="comment">//引号类型 `` "" ''</span></span><br><span class="line">    <span class="string">"quote-props"</span>:[<span class="number">0</span>, <span class="string">"always"</span>],<span class="comment">//对象字面量中的属性名是否强制双引号</span></span><br><span class="line">    <span class="string">"radix"</span>: <span class="number">2</span>,<span class="comment">//parseInt必须指定第二个参数</span></span><br><span class="line">    <span class="string">"id-match"</span>: <span class="number">0</span>,<span class="comment">//命名检测</span></span><br><span class="line">    <span class="string">"require-yield"</span>: <span class="number">0</span>,<span class="comment">//生成器函数必须有yield</span></span><br><span class="line">    <span class="string">"semi"</span>: [<span class="number">0</span>, <span class="string">"always"</span>],<span class="comment">//语句强制分号结尾</span></span><br><span class="line">    <span class="string">"semi-spacing"</span>: [<span class="number">0</span>, &#123;<span class="string">"before"</span>: <span class="literal">false</span>, <span class="string">"after"</span>: <span class="literal">false</span>&#125;],<span class="comment">//分号前后空格</span></span><br><span class="line">    <span class="string">"sort-vars"</span>: <span class="number">0</span>,<span class="comment">//变量声明时排序</span></span><br><span class="line">    <span class="string">"space-after-keywords"</span>: [<span class="number">0</span>, <span class="string">"always"</span>],<span class="comment">//关键字后面是否要空一格</span></span><br><span class="line">    <span class="string">"space-before-blocks"</span>: [<span class="number">0</span>, <span class="string">"always"</span>],<span class="comment">//不以新行开始的块&#123;前面要不要有空格</span></span><br><span class="line">    <span class="string">"space-before-function-paren"</span>: [<span class="number">0</span>, <span class="string">"always"</span>],<span class="comment">//函数定义时括号前面要不要有空格</span></span><br><span class="line">    <span class="string">"space-in-parens"</span>: [<span class="number">0</span>, <span class="string">"never"</span>],<span class="comment">//小括号里面要不要有空格</span></span><br><span class="line">    <span class="string">"space-infix-ops"</span>: <span class="number">0</span>,<span class="comment">//中缀操作符周围要不要有空格</span></span><br><span class="line">    <span class="string">"space-unary-ops"</span>: [<span class="number">0</span>, &#123; <span class="string">"words"</span>: <span class="literal">true</span>, <span class="string">"nonwords"</span>: <span class="literal">false</span> &#125;],<span class="comment">//一元运算符的前/后要不要加空格</span></span><br><span class="line">    <span class="string">"spaced-comment"</span>: <span class="number">0</span>,<span class="comment">//注释风格要不要有空格什么的</span></span><br><span class="line">    <span class="string">"strict"</span>: <span class="number">2</span>,<span class="comment">//使用严格模式</span></span><br><span class="line">    <span class="string">"use-isnan"</span>: <span class="number">2</span>,<span class="comment">//禁止比较时使用NaN，只能用isNaN()</span></span><br><span class="line">    <span class="string">"valid-jsdoc"</span>: <span class="number">0</span>,<span class="comment">//jsdoc规则</span></span><br><span class="line">    <span class="string">"valid-typeof"</span>: <span class="number">2</span>,<span class="comment">//必须使用合法的typeof的值</span></span><br><span class="line">    <span class="string">"vars-on-top"</span>: <span class="number">2</span>,<span class="comment">//var必须放在作用域顶部</span></span><br><span class="line">    <span class="string">"wrap-iife"</span>: [<span class="number">2</span>, <span class="string">"inside"</span>],<span class="comment">//立即执行函数表达式的小括号风格</span></span><br><span class="line">    <span class="string">"wrap-regex"</span>: <span class="number">0</span>,<span class="comment">//正则表达式字面量用小括号包起来</span></span><br><span class="line">    <span class="string">"yoda"</span>: [<span class="number">2</span>, <span class="string">"never"</span>]<span class="comment">//禁止尤达条件</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;EsLint帮助我们检查Javascript编程时的语法错误。比如：在Javascript应用中，你很难找到你漏泄的变量或者方法。EsLint能够帮助我们分析JS代码，找到bug并确保一定程度的JS语法书写的正确性。&lt;br&gt;EsLint是建立在Esprima(ECMAScript解析架构)的基础上的。Esprima支持ES5.1,本身也是用ECMAScript编写的，用于多用途分析。EsLint不但提供一些默认的规则（可扩展），也提供用户自定义规则来约束我们写的Javascript代码。&lt;br&gt;
    
    </summary>
    
    
      <category term="主要讲解eslint配置方法" scheme="http://xuhongbo.com/tags/%E4%B8%BB%E8%A6%81%E8%AE%B2%E8%A7%A3eslint%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>揭秘命名函数表达式</title>
    <link href="http://xuhongbo.com/2016/09/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript/48%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%E7%AF%87%EF%BC%89/"/>
    <id>http://xuhongbo.com/2016/09/17/深入理解javascript/48对象创建模式（下篇）/</id>
    <published>2016-09-17T15:02:02.000Z</published>
    <updated>2017-03-02T17:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要是介绍创建对象方面的模式的下篇，利用各种技巧可以极大地避免了错误或者可以编写出非常精简的代码。<br><a id="more"></a></p><h2 id="模式-6：函数语法糖"><a href="#模式-6：函数语法糖" class="headerlink" title="模式 6：函数语法糖"></a>模式 6：函数语法糖</h2><p>函数语法糖是为一个对象快速添加方法（函数）的扩展，这个主要是利用 prototype 的特性，代码比较简单，我们先来看一下实现代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (typeof Function.prototype.method !== &quot;function&quot;) &#123;</span><br><span class="line">    Function.prototype.method = function (name, implementation) &#123;</span><br><span class="line">        this.prototype[name] = implementation;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展对象的时候，可以这么用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var Person = function (name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">.method(&apos;getName&apos;,</span><br><span class="line">            function () &#123;</span><br><span class="line">                return this.name;</span><br><span class="line">            &#125;)</span><br><span class="line">.method(&apos;setName&apos;, function (name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    return this;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样就给 Person 函数添加了 getName 和 setName 这 2 个方法，接下来我们来验证一下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = new Person(&apos;Adam&apos;);</span><br><span class="line">console.log(a.getName()); // &apos;Adam&apos;</span><br><span class="line">console.log(a.setName(&apos;Eve&apos;).getName()); // &apos;Eve&apos;</span><br></pre></td></tr></table></figure><h2 id="模式-7：对象常量"><a href="#模式-7：对象常量" class="headerlink" title="模式 7：对象常量"></a>模式 7：对象常量</h2><p>对象常量是在一个对象提供 set，get，ifDefined 各种方法的体现，而且对于 set 的方法只会保留最先设置的对象，后期再设置都是无效的，已达到别人无法重载的目的。实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var constant = (function () &#123;</span><br><span class="line">    var constants = &#123;&#125;,</span><br><span class="line">        ownProp = Object.prototype.hasOwnProperty,</span><br><span class="line">    // 只允许设置这三种类型的值</span><br><span class="line">        allowed = &#123;</span><br><span class="line">            string: 1,</span><br><span class="line">            number: 1,</span><br><span class="line">            boolean: 1</span><br><span class="line">        &#125;,</span><br><span class="line">        prefix = (Math.random() + &quot;_&quot;).slice(2);  </span><br><span class="line">    return &#123;</span><br><span class="line">        // 设置名称为name的属性</span><br><span class="line">        set: function (name, value) &#123;</span><br><span class="line">            if (this.isDefined(name)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!ownProp.call(allowed, typeof value)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            constants[prefix + name] = value;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;,</span><br><span class="line">        // 判断是否存在名称为name的属性</span><br><span class="line">        isDefined: function (name) &#123;</span><br><span class="line">            return ownProp.call(constants, prefix + name);</span><br><span class="line">        &#125;,</span><br><span class="line">        // 获取名称为name的属性</span><br><span class="line">        get: function (name) &#123;</span><br><span class="line">            if (this.isDefined(name)) &#123;</span><br><span class="line">                return constants[prefix + name];</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; ());</span><br></pre></td></tr></table></figure><p>验证代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 检查是否存在</span><br><span class="line">console.log(constant.isDefined(&quot;maxwidth&quot;)); // false  </span><br><span class="line">// 定义</span><br><span class="line">console.log(constant.set(&quot;maxwidth&quot;, 480)); // true  </span><br><span class="line">// 重新检测</span><br><span class="line">console.log(constant.isDefined(&quot;maxwidth&quot;)); // true  </span><br><span class="line">// 尝试重新定义</span><br><span class="line">console.log(constant.set(&quot;maxwidth&quot;, 320)); // false  </span><br><span class="line">// 判断原先的定义是否还存在</span><br><span class="line">console.log(constant.get(&quot;maxwidth&quot;)); // 480</span><br></pre></td></tr></table></figure><h2 id="模式-8：沙盒模式"><a href="#模式-8：沙盒模式" class="headerlink" title="模式 8：沙盒模式"></a>模式 8：沙盒模式</h2><p>沙盒（Sandbox）模式即时为一个或多个模块提供单独的上下文环境，而不会影响其他模块的上下文环境，比如有个 Sandbox 里有 3 个方法event，dom，ajax，在调用其中 2 个组成一个环境的话，和调用三个组成的环境完全没有干扰。Sandbox 实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">function Sandbox() &#123;</span><br><span class="line">    // 将参数转为数组</span><br><span class="line">    var args = Array.prototype.slice.call(arguments),</span><br><span class="line">    // 最后一个参数为callback</span><br><span class="line">        callback = args.pop(),</span><br><span class="line">        // 除最后一个参数外，其它均为要选择的模块</span><br><span class="line">        modules = (args[0] &amp;&amp; typeof args[0] === &quot;string&quot;) ? args : args[0],</span><br><span class="line">        i;  </span><br><span class="line">    // 强制使用new操作符</span><br><span class="line">    if (!(this instanceof Sandbox)) &#123;</span><br><span class="line">        return new Sandbox(modules, callback);</span><br><span class="line">    &#125;  </span><br><span class="line">    // 添加属性</span><br><span class="line">    this.a = 1;</span><br><span class="line">    this.b = 2;  </span><br><span class="line">    // 向this对象上需想添加模块</span><br><span class="line">    // 如果没有模块或传入的参数为 &quot;*&quot; ，则以为着传入所有模块</span><br><span class="line">    if (!modules || modules == &apos;*&apos;) &#123;</span><br><span class="line">        modules = [];</span><br><span class="line">        for (i in Sandbox.modules) &#123;</span><br><span class="line">            if (Sandbox.modules.hasOwnProperty(i)) &#123;</span><br><span class="line">                modules.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    // 初始化需要的模块</span><br><span class="line">    for (i = 0; i &lt; modules.length; i += 1) &#123;</span><br><span class="line">        Sandbox.modules[modules[i]](this);</span><br><span class="line">    &#125;</span><br><span class="line">    // 调用 callback</span><br><span class="line">    callback(this);</span><br><span class="line">&#125;  </span><br><span class="line">// 默认添加原型对象</span><br><span class="line">Sandbox.prototype = &#123;</span><br><span class="line">    name: &quot;My Application&quot;,</span><br><span class="line">    version: &quot;1.0&quot;,</span><br><span class="line">    getName: function () &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后我们再定义默认的初始模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Sandbox.modules = &#123;&#125;;  </span><br><span class="line">Sandbox.modules.dom = function (box) &#123;</span><br><span class="line">    box.getElement = function () &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    box.getStyle = function () &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    box.foo = &quot;bar&quot;;</span><br><span class="line">&#125;;  </span><br><span class="line">Sandbox.modules.event = function (box) &#123;</span><br><span class="line">    // access to the Sandbox prototype if needed:</span><br><span class="line">    // box.constructor.prototype.m = &quot;mmm&quot;;</span><br><span class="line">    box.attachEvent = function () &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    box.detachEvent = function () &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;  </span><br><span class="line">Sandbox.modules.ajax = function (box) &#123;</span><br><span class="line">    box.makeRequest = function () &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    box.getResponse = function () &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 调用方式</span><br><span class="line">Sandbox([&apos;ajax&apos;, &apos;event&apos;], function (box) &#123;</span><br><span class="line">    console.log(typeof (box.foo));</span><br><span class="line">    // 没有选择dom，所以box.foo不存在</span><br><span class="line">&#125;);  </span><br><span class="line">Sandbox(&apos;ajax&apos;, &apos;dom&apos;, function (box) &#123;</span><br><span class="line">    console.log(typeof (box.attachEvent));</span><br><span class="line">    // 没有选择event,所以event里定义的attachEvent也不存在</span><br><span class="line">&#125;);  </span><br><span class="line">Sandbox(&apos;*&apos;, function (box) &#123;</span><br><span class="line">    console.log(box); // 上面定义的所有方法都可访问</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过三个不同的调用方式，我们可以看到，三种方式的上下文环境都是不同的，第一种里没有 foo；而第二种则没有 attachEvent，因为只加载了 ajax 和 dom，而没有加载 event；第三种则加载了全部。</p><h2 id="模式-9：静态成员"><a href="#模式-9：静态成员" class="headerlink" title="模式 9：静态成员"></a>模式 9：静态成员</h2><p>静态成员（Static Members）只是一个函数或对象提供的静态属性，可分为私有的和公有的，就像 C#或 Java 里的 public static 和 private static 一样。</p><p>我们先来看一下公有成员，公有成员非常简单，我们平时声明的方法，函数都是公有的，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 构造函数</span><br><span class="line">var Gadget = function () &#123;</span><br><span class="line">&#125;;  </span><br><span class="line">// 公有静态方法</span><br><span class="line">Gadget.isShiny = function () &#123;</span><br><span class="line">    return &quot;you bet&quot;;</span><br><span class="line">&#125;;  </span><br><span class="line">// 原型上添加的正常方法</span><br><span class="line">Gadget.prototype.setPrice = function (price) &#123;</span><br><span class="line">    this.price = price;</span><br><span class="line">&#125;;  </span><br><span class="line">// 调用静态方法</span><br><span class="line">console.log(Gadget.isShiny()); // &quot;you bet&quot;  </span><br><span class="line">// 创建实例，然后调用方法</span><br><span class="line">var iphone = new Gadget();</span><br><span class="line">iphone.setPrice(500);  </span><br><span class="line">console.log(typeof Gadget.setPrice); // &quot;undefined&quot;</span><br><span class="line">console.log(typeof iphone.isShiny); // &quot;undefined&quot;</span><br><span class="line">Gadget.prototype.isShiny = Gadget.isShiny;</span><br><span class="line">console.log(iphone.isShiny()); // &quot;you bet&quot;</span><br></pre></td></tr></table></figure><p>而私有静态成员，我们可以利用其闭包特性去实现，以下是两种实现方式。</p><h3 id="第一种实现方式："><a href="#第一种实现方式：" class="headerlink" title="第一种实现方式："></a>第一种实现方式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var Gadget = (function () &#123;</span><br><span class="line">    // 静态变量/属性</span><br><span class="line">    var counter = 0;  </span><br><span class="line">    // 闭包返回构造函数的新实现</span><br><span class="line">    return function () &#123;</span><br><span class="line">        console.log(counter += 1);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; ()); // 立即执行  </span><br><span class="line">var g1 = new Gadget(); // logs 1</span><br><span class="line">var g2 = new Gadget(); // logs 2</span><br><span class="line">var g3 = new Gadget(); // logs 3</span><br></pre></td></tr></table></figure><p>可以看出，虽然每次都是 new 的对象，但数字依然是递增的，达到了静态成员的目的。</p><h3 id="第二种方式："><a href="#第二种方式：" class="headerlink" title="第二种方式："></a>第二种方式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var Gadget = (function () &#123;</span><br><span class="line">    // 静态变量/属性</span><br><span class="line">    var counter = 0,</span><br><span class="line">        NewGadget;  </span><br><span class="line">    //新构造函数实现</span><br><span class="line">    NewGadget = function () &#123;</span><br><span class="line">        counter += 1;</span><br><span class="line">   &#125;;  </span><br><span class="line">    // 授权可以访问的方法</span><br><span class="line">    NewGadget.prototype.getLastId = function () &#123;</span><br><span class="line">        return counter;</span><br><span class="line">    &#125;;  </span><br><span class="line">    // 覆盖构造函数</span><br><span class="line">    return NewGadget;</span><br><span class="line">&#125; ()); // 立即执行  </span><br><span class="line">var iphone = new Gadget();</span><br><span class="line">iphone.getLastId(); // 1</span><br><span class="line">var ipod = new Gadget();</span><br><span class="line">ipod.getLastId(); // 2</span><br><span class="line">var ipad = new Gadget();</span><br><span class="line">ipad.getLastId(); // 3</span><br></pre></td></tr></table></figure><p>数字也是递增了，这是利用其内部授权方法的闭包特性实现的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是对象创建模式的下篇，两篇一起总共9种模式，是我们在日常 JavaScript 编程中经常使用的对象创建模式，不同的场景起到了不同的作用，希望大家根据各自的需求选择适用的模式。</p><h2 id="同步与推荐"><a href="#同步与推荐" class="headerlink" title="同步与推荐"></a>同步与推荐</h2><p>深入理解 JavaScript 系列文章，包括了原创，翻译，转载等各类型的文章，如果对你有用，请推荐支持一把，给大叔写作的动力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇主要是介绍创建对象方面的模式的下篇，利用各种技巧可以极大地避免了错误或者可以编写出非常精简的代码。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>对象创建模式（上篇）</title>
    <link href="http://xuhongbo.com/2016/09/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript/47%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/"/>
    <id>http://xuhongbo.com/2016/09/11/深入理解javascript/47对象创建模式（上篇）/</id>
    <published>2016-09-11T03:02:02.000Z</published>
    <updated>2017-03-02T17:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要是介绍创建对象方面的模式，利用各种技巧可以极大地避免了错误或者可以编写出非常精简的代码。<br><a id="more"></a></p><h2 id="模式-1：命名空间（namespace）"><a href="#模式-1：命名空间（namespace）" class="headerlink" title="模式 1：命名空间（namespace）"></a>模式 1：命名空间（namespace）</h2><p>命名空间可以减少全局命名所需的数量，避免命名冲突或过度。一般我们在进行对象层级定义的时候，经常是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var app = app || &#123;&#125;;</span><br><span class="line">app.moduleA = app.moduleA || &#123;&#125;;</span><br><span class="line">app.moduleA.subModule = app.moduleA.subModule || &#123;&#125;;</span><br><span class="line">app.moduleA.subModule.MethodA = function () &#123;</span><br><span class="line">    console.log(&quot;print A&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">app.moduleA.subModule.MethodB = function () &#123;</span><br><span class="line">    console.log(&quot;print B&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果层级很多的话，那就要一直这样继续下去，很是混乱。namespace 模式就是为了解决这个问题而存在的，我们看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 不安全，可能会覆盖已有的MYAPP对象</span><br><span class="line">var MYAPP = &#123;&#125;;</span><br><span class="line">// 还好</span><br><span class="line">if (typeof MYAPP === &quot;undefined&quot;) &#123;</span><br><span class="line">    var MYAPP = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">// 更简洁的方式</span><br><span class="line">var MYAPP = MYAPP || &#123;&#125;;  </span><br><span class="line">//定义通用方法</span><br><span class="line">MYAPP.namespace = function (ns_string) &#123;</span><br><span class="line">    var parts = ns_string.split(&apos;.&apos;),</span><br><span class="line">        parent = MYAPP,</span><br><span class="line">        i;  </span><br><span class="line">    // 默认如果第一个节点是MYAPP的话，就忽略掉，比如MYAPP.ModuleA</span><br><span class="line">    if (parts[0] === &quot;MYAPP&quot;) &#123;</span><br><span class="line">        parts = parts.slice(1);</span><br><span class="line">    &#125;  </span><br><span class="line">    for (i = 0; i &lt; parts.length; i += 1) &#123;</span><br><span class="line">        // 如果属性不存在，就创建</span><br><span class="line">        if (typeof parent[parts[i]] === &quot;undefined&quot;) &#123;</span><br><span class="line">            parent[parts[i]] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        parent = parent[parts[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    return parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用代码，非常简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 通过namespace以后，可以将返回值赋给一个局部变量</span><br><span class="line">var module2 = MYAPP.namespace(&apos;MYAPP.modules.module2&apos;);</span><br><span class="line">console.log(module2 === MYAPP.modules.module2); // true  </span><br><span class="line">// 跳过MYAPP</span><br><span class="line">MYAPP.namespace(&apos;modules.module51&apos;);  </span><br><span class="line">// 非常长的名字</span><br><span class="line">MYAPP.namespace(&apos;once.upon.a.time.there.was.this.long.nested.property&apos;);</span><br></pre></td></tr></table></figure><h2 id="模式-2：定义依赖"><a href="#模式-2：定义依赖" class="headerlink" title="模式 2：定义依赖"></a>模式 2：定义依赖</h2><p>有时候你的一个模块或者函数可能要引用第三方的一些模块或者工具，这时候最好将这些依赖模块在刚开始的时候就定义好，以便以后可以很方便地替换掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var myFunction = function () &#123;</span><br><span class="line">    // 依赖模块</span><br><span class="line">    var event = YAHOO.util.Event,</span><br><span class="line">        dom = YAHOO.util.dom;  </span><br><span class="line">    // 其它函数后面的代码里使用局部变量event和dom</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="模式-3：私有属性和私有方法"><a href="#模式-3：私有属性和私有方法" class="headerlink" title="模式 3：私有属性和私有方法"></a>模式 3：私有属性和私有方法</h2><p>JavaScript 本书不提供特定的语法来支持私有属性和私有方法，但是我们可以通过闭包来实现，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function Gadget() &#123;</span><br><span class="line">    // 私有对象</span><br><span class="line">    var name = &apos;iPod&apos;;</span><br><span class="line">    // 公有函数</span><br><span class="line">    this.getName = function () &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var toy = new Gadget();  </span><br><span class="line">// name未定义，是私有的</span><br><span class="line">console.log(toy.name); // undefined  </span><br><span class="line">// 公有方法访问name</span><br><span class="line">console.log(toy.getName()); // &quot;iPod&quot;  </span><br><span class="line">var myobj; // 通过自执行函数给myobj赋值</span><br><span class="line">(function () &#123;</span><br><span class="line">    // 自由对象</span><br><span class="line">    var name = &quot;my, oh my&quot;;  </span><br><span class="line">    // 实现了公有部分，所以没有var</span><br><span class="line">    myobj = &#123;</span><br><span class="line">        // 授权方法</span><br><span class="line">        getName: function () &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; ());</span><br></pre></td></tr></table></figure><h2 id="模式-4：Revelation模式"><a href="#模式-4：Revelation模式" class="headerlink" title="模式 4：Revelation模式"></a>模式 4：Revelation模式</h2><p>也是关于隐藏私有方法的模式，和<a href="http://www.cnblogs.com/TomXu/archive/2011/12/30/2288372.html" target="_blank" rel="noopener">《深入理解JavaScript系列（3）：全面解析Module模式》</a>里的 Module 模式有点类似，但是不是 return 的方式，而是在外部先声明一个变量，然后在内部给变量赋值公有方法。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var myarray;</span><br><span class="line">(function () &#123;</span><br><span class="line">    var astr = &quot;[object Array]&quot;,</span><br><span class="line">        toString = Object.prototype.toString;  </span><br><span class="line">    function isArray(a) &#123;</span><br><span class="line">        return toString.call(a) === astr;</span><br><span class="line">    &#125;  </span><br><span class="line">    function indexOf(haystack, needle) &#123;</span><br><span class="line">        var i = 0,</span><br><span class="line">            max = haystack.length;</span><br><span class="line">        for (; i &lt; max; i += 1) &#123;</span><br><span class="line">            if (haystack[i] === needle) &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;  </span><br><span class="line">    //通过赋值的方式，将上面所有的细节都隐藏了</span><br><span class="line">    myarray = &#123;</span><br><span class="line">        isArray: isArray,</span><br><span class="line">        indexOf: indexOf,</span><br><span class="line">        inArray: indexOf</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; ());  </span><br><span class="line">//测试代码</span><br><span class="line">console.log(myarray.isArray([1, 2])); // true</span><br><span class="line">console.log(myarray.isArray(&#123; 0: 1 &#125;)); // false</span><br><span class="line">console.log(myarray.indexOf([&quot;a&quot;, &quot;b&quot;, &quot;z&quot;], &quot;z&quot;)); // 2</span><br><span class="line">console.log(myarray.inArray([&quot;a&quot;, &quot;b&quot;, &quot;z&quot;], &quot;z&quot;)); // 2  </span><br><span class="line">myarray.indexOf = null;</span><br><span class="line">console.log(myarray.inArray([&quot;a&quot;, &quot;b&quot;, &quot;z&quot;], &quot;z&quot;)); // 2</span><br></pre></td></tr></table></figure><h2 id="模式-5：链模式"><a href="#模式-5：链模式" class="headerlink" title="模式 5：链模式"></a>模式 5：链模式</h2><p>链模式可以你连续可以调用一个对象的方法，比如 obj.add(1).remove(2).delete(4).add(2)这样的形式，其实现思路非常简单，就是将 this 原样返回。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    increment: function () &#123;</span><br><span class="line">        this.value += 1;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;,</span><br><span class="line">    add: function (v) &#123;</span><br><span class="line">        this.value += v;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;,</span><br><span class="line">    shout: function () &#123;</span><br><span class="line">        console.log(this.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;  </span><br><span class="line">// 链方法调用</span><br><span class="line">obj.increment().add(3).shout(); // 5  </span><br><span class="line">// 也可以单独一个一个调用</span><br><span class="line">obj.increment();</span><br><span class="line">obj.add(3);</span><br><span class="line">obj.shout();</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇是对象创建模式的上篇，敬请期待明天的下篇。</p><h2 id="同步与推荐"><a href="#同步与推荐" class="headerlink" title="同步与推荐"></a>同步与推荐</h2><p>深入理解 JavaScript 系列文章，包括了原创，翻译，转载等各类型的文章，如果对你有用，请推荐支持一把，给大叔写作的动力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇主要是介绍创建对象方面的模式，利用各种技巧可以极大地避免了错误或者可以编写出非常精简的代码。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Function 模式（下篇）</title>
    <link href="http://xuhongbo.com/2016/08/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript/50Function%20%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%E7%AF%87%EF%BC%89/"/>
    <id>http://xuhongbo.com/2016/08/26/深入理解javascript/50Function 模式（下篇）/</id>
    <published>2016-08-26T08:56:02.000Z</published>
    <updated>2017-03-02T17:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇我们介绍的一些模式称为初始化模式和性能模式，主要是用在初始化以及提高性能方面，一些模式之前已经提到过，这里只是做一下总结。</p><h2 id="立即执行的函数"><a href="#立即执行的函数" class="headerlink" title="立即执行的函数"></a>立即执行的函数</h2><p>在本系列第 4 篇的<a href="http://www.cnblogs.com/TomXu/archive/2011/12/31/2289423.html" target="_blank" rel="noopener">《立即调用的函数表达式》中</a>，我们已经对类似的函数进行过详细的描述，这里我们只是再举两个简单的例子做一下总结。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 声明完函数以后，立即执行该函数</span><br><span class="line">(function () &#123;</span><br><span class="line">    console.log(&apos;watch out!&apos;);</span><br><span class="line">&#125; ());  </span><br><span class="line">//这种方式声明的函数，也可以立即执行</span><br><span class="line">!function () &#123;</span><br><span class="line">    console.log(&apos;watch out!&apos;);</span><br><span class="line">&#125; ();  </span><br><span class="line">// 如下方式也都可以哦</span><br><span class="line">~function () &#123; /* code */ &#125; ();</span><br><span class="line">-function () &#123; /* code */ &#125; ();</span><br><span class="line">+function () &#123; /* code */ &#125; ();</span><br></pre></td></tr></table></figure></p><h2 id="立即执行的对象初始化"><a href="#立即执行的对象初始化" class="headerlink" title="立即执行的对象初始化"></a>立即执行的对象初始化</h2><p>该模式的意思是指在声明一个对象（而非函数）的时候，立即执行对象里的某一个方法来进行初始化工作，通常该模式可以用在一次性执行的代码上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(&#123;</span><br><span class="line">    // 这里你可以定义常量，设置其它值</span><br><span class="line">    maxwidth: 600,</span><br><span class="line">    maxheight: 400,  </span><br><span class="line">    //  当然也可以定义utility方法</span><br><span class="line">    gimmeMax: function () &#123;</span><br><span class="line">        return this.maxwidth + &quot;x&quot; + this.maxheight;</span><br><span class="line">    &#125;,  </span><br><span class="line">    // 初始化</span><br><span class="line">    init: function () &#123;</span><br><span class="line">        console.log(this.gimmeMax());</span><br><span class="line">        // 更多代码...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).init();  // 这样就开始初始化咯</span><br></pre></td></tr></table></figure><h2 id="分支初始化"><a href="#分支初始化" class="headerlink" title="分支初始化"></a>分支初始化</h2><p>分支初始化是指在初始化的时候，根据不同的条件（场景）初始化不同的代码，也就是所谓的条件语句赋值。之前我们在做事件处理的时候，通常使用类似下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var utils = &#123;</span><br><span class="line">    addListener: function (el, type, fn) &#123;</span><br><span class="line">        if (typeof window.addEventListener === &apos;function&apos;) &#123;</span><br><span class="line">            el.addEventListener(type, fn, false);</span><br><span class="line">        &#125; else if (typeof document.attachEvent !== &apos;undefined&apos;) &#123;</span><br><span class="line">            el.attachEvent(&apos;on&apos; + type, fn);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            el[&apos;on&apos; + type] = fn;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    removeListener: function (el, type, fn) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们来改进一下，首先我们要定义两个接口，一个用来add事件句柄，一个用来 remove 事件句柄，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var utils = &#123;</span><br><span class="line">    addListener: null,</span><br><span class="line">    removeListener: null</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if (typeof window.addEventListener === &apos;function&apos;) &#123;</span><br><span class="line">    utils.addListener = function (el, type, fn) &#123;</span><br><span class="line">        el.addEventListener(type, fn, false);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; else if (typeof document.attachEvent !== &apos;undefined&apos;) &#123; // IE</span><br><span class="line">    utils.addListener = function (el, type, fn) &#123;</span><br><span class="line">        el.attachEvent(&apos;on&apos; + type, fn);</span><br><span class="line">    &#125;;</span><br><span class="line">    utils.removeListener = function (el, type, fn) &#123;</span><br><span class="line">        el.detachEvent(&apos;on&apos; + type, fn);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; else &#123; // 其它旧浏览器</span><br><span class="line">    utils.addListener = function (el, type, fn) &#123;</span><br><span class="line">        el[&apos;on&apos; + type] = fn;</span><br><span class="line">    &#125;;</span><br><span class="line">    utils.removeListener = function (el, type, fn) &#123;</span><br><span class="line">        el[&apos;on&apos; + type] = null;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用起来，是不是就很方便了？代码也优雅多了。</p><h2 id="自声明函数"><a href="#自声明函数" class="headerlink" title="自声明函数"></a>自声明函数</h2><p>一般是在函数内部，重写同名函数代码，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var scareMe = function () &#123;</span><br><span class="line">    alert(&quot;Boo!&quot;);</span><br><span class="line">    scareMe = function () &#123;</span><br><span class="line">        alert(&quot;Double boo!&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种代码，非常容易使人迷惑，我们先来看看例子的执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 1. 添加新属性</span><br><span class="line">scareMe.property = &quot;properly&quot;;</span><br><span class="line">// 2. scareMe赋与一个新值</span><br><span class="line">var prank = scareMe;</span><br><span class="line">// 3. 作为一个方法调用</span><br><span class="line">var spooky = &#123;</span><br><span class="line">    boo: scareMe</span><br><span class="line">&#125;;</span><br><span class="line">// 使用新变量名称进行调用</span><br><span class="line">prank(); // &quot;Boo!&quot;</span><br><span class="line">prank(); // &quot;Boo!&quot;</span><br><span class="line">console.log(prank.property); // &quot;properly&quot;</span><br><span class="line">// 使用方法进行调用</span><br><span class="line">spooky.boo(); // &quot;Boo!&quot;</span><br><span class="line">spooky.boo(); // &quot;Boo!&quot;</span><br><span class="line">console.log(spooky.boo.property); // &quot;properly&quot;</span><br></pre></td></tr></table></figure><p>通过执行结果，可以发现，将定于的函数赋值与新变量（或内部方法），代码并不执行重载的 scareMe 代码，而如下例子则正好相反：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 使用自声明函数</span><br><span class="line">scareMe(); // Double boo!</span><br><span class="line">scareMe(); // Double boo!</span><br><span class="line">console.log(scareMe.property); // undefined</span><br></pre></td></tr></table></figure><p>大家使用这种模式时，一定要非常小心才行，否则实际结果很可能和你期望的结果不一样，当然你也可以利用这个特殊做一些特殊的操作。</p><h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><p>该模式主要是利用函数的属性特性来避免大量的重复计算。通常代码形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var myFunc = function (param) &#123;</span><br><span class="line">    if (!myFunc.cache[param]) &#123;</span><br><span class="line">        var result = &#123;&#125;;</span><br><span class="line">        // ... 复杂操作 ...</span><br><span class="line">        myFunc.cache[param] = result;</span><br><span class="line">    &#125;</span><br><span class="line">    return myFunc.cache[param];</span><br><span class="line">&#125;;</span><br><span class="line">// cache 存储</span><br><span class="line">myFunc.cache = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>但是上述代码有个问题，如果传入的参数是 toString 或者其它类似 Object 拥有的一些公用方法的话，就会出现问题，这时候就需要使用传说中的 hasOwnProperty 方法了，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var myFunc = function (param) &#123;</span><br><span class="line">    if (!myFunc.cache.hasOwnProperty(param)) &#123;</span><br><span class="line">        var result = &#123;&#125;;</span><br><span class="line">        // ... 复杂操作 ...</span><br><span class="line">        myFunc.cache[param] = result;</span><br><span class="line">    &#125;</span><br><span class="line">    return myFunc.cache[param];</span><br><span class="line">&#125;;  </span><br><span class="line">// cache 存储</span><br><span class="line">myFunc.cache = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>或者如果你传入的参数是多个的话，可以将这些参数通过 JSON 的 stringify 方法生产一个 cachekey 值进行存储，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var myFunc = function () &#123;</span><br><span class="line">    var cachekey = JSON.stringify(Array.prototype.slice.call(arguments)),</span><br><span class="line">        result;</span><br><span class="line">    if (!myFunc.cache[cachekey]) &#123;</span><br><span class="line">        result = &#123;&#125;;</span><br><span class="line">        // ... 复杂操作 ...</span><br><span class="line">        myFunc.cache[cachekey] = result;</span><br><span class="line">    &#125;</span><br><span class="line">    return myFunc.cache[cachekey];</span><br><span class="line">&#125;;  </span><br><span class="line">// cache 存储</span><br><span class="line">myFunc.cache = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>或者多个参数的话，也可以利用 arguments.callee 特性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var myFunc = function (param) &#123;</span><br><span class="line">    var f = arguments.callee,</span><br><span class="line">        result;</span><br><span class="line">    if (!f.cache[param]) &#123;</span><br><span class="line">        result = &#123;&#125;;</span><br><span class="line">        // ... 复杂操作 ...</span><br><span class="line">        f.cache[param] = result;</span><br><span class="line">    &#125;</span><br><span class="line">    return f.cache[param];</span><br><span class="line">&#125;;  </span><br><span class="line">// cache 存储</span><br><span class="line">myFunc.cache = &#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>就不用总结了吧，大家仔细看代码就行咯</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇我们介绍的一些模式称为初始化模式和性能模式，主要是用在初始化以及提高性能方面，一些模式之前已经提到过，这里只是做一下总结。&lt;/p&gt;
&lt;h2 id=&quot;立即执行的函数&quot;&gt;&lt;a href=&quot;#立即执行的函数&quot; class=&quot;headerlink&quot; title=&quot;立即执行的函数&quot;&gt;&lt;/a&gt;立即执行的函数&lt;/h2&gt;&lt;p&gt;在本系列第 4 篇的&lt;a href=&quot;http://www.cnblogs.com/TomXu/archive/2011/12/31/2289423.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《立即调用的函数表达式》中&lt;/a&gt;，我们已经对类似的函数进行过详细的描述，这里我们只是再举两个简单的例子做一下总结。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>S.O.L.I.D 五大原则之里氏替换原则 LSP</title>
    <link href="http://xuhongbo.com/2016/08/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript/8S.O.L.I.D%20%E4%BA%94%E5%A4%A7%E5%8E%9F%E5%88%99%E4%B9%8B%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%20LSP/"/>
    <id>http://xuhongbo.com/2016/08/23/深入理解javascript/8S.O.L.I.D 五大原则之里氏替换原则 LSP/</id>
    <published>2016-08-23T04:02:02.000Z</published>
    <updated>2017-03-02T17:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>本章我们要讲解的是 S.O.L.I.D 五大原则 JavaScript 语言实现的第3篇，里氏替换原则 LSP（The Liskov Substitution Principle ）。</p><p>开闭原则的描述是：</p><blockquote><p>Subtypes must be substitutable for their base types.<br>派生类型必须可以替换它的基类型。<br><a id="more"></a><br>在面向对象编程里，继承提供了一个机制让子类和共享基类的代码，这是通过在基类型里封装通用的数据和行为来实现的，然后已经及类型来声明更详细的子类型，为了应用里氏替换原则，继承子类型需要在语义上等价于基类型里的期望行为。</p></blockquote><p>为了来更好的理解，请参考如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function Vehicle(my) &#123;</span><br><span class="line">    var my = my || &#123;&#125;;</span><br><span class="line">    my.speed = 0;</span><br><span class="line">    my.running = false;</span><br><span class="line">    this.speed = function() &#123;</span><br><span class="line">        return my.speed;</span><br><span class="line">    &#125;;</span><br><span class="line">    this.start = function() &#123;</span><br><span class="line">        my.running = true;</span><br><span class="line">    &#125;;</span><br><span class="line">    this.stop = function() &#123;</span><br><span class="line">        my.running = false;</span><br><span class="line">    &#125;;</span><br><span class="line">    this.accelerate = function() &#123;</span><br><span class="line">        my.speed++;</span><br><span class="line">    &#125;;</span><br><span class="line">    this.decelerate = function() &#123;</span><br><span class="line">        my.speed--;</span><br><span class="line">    &#125;, this.state = function() &#123;</span><br><span class="line">        if (!my.running) &#123;</span><br><span class="line">            return &quot;parked&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (my.running &amp;&amp; my.speed) &#123;</span><br><span class="line">            return &quot;moving&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (my.running) &#123;</span><br><span class="line">            return &quot;idle&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码我们定义了一个 Vehicle 函数，其构造函数为 vehicle 对象提供了一些基本的操作，我们来想想如果当前函数当前正运行在服务客户的产品环境上，如果现在需要添加一个新的构造函数来实现加快移动的 vehicle。思考以后，我们写出了如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function FastVehicle(my) &#123;</span><br><span class="line">    var my = my || &#123;&#125;;</span><br><span class="line">    var that = new Vehicle(my);</span><br><span class="line">    that.accelerate = function() &#123;</span><br><span class="line">        my.speed += 3;</span><br><span class="line">    &#125;;</span><br><span class="line">    return that;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在浏览器的控制台我们都测试了，所有的功能都是我们的预期，没有问题，FastVehicle 的速度增快了 3 倍，而且继承他的方法也是按照我们的预期工作。此后，我们开始部署这个新版本的类库到产品环境上，可是我们却接到了新的构造函数导致现有的代码不能支持执行了，下面的代码段揭示了这个问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var maneuver = function(vehicle) &#123;</span><br><span class="line">    write(vehicle.state());</span><br><span class="line">    vehicle.start();</span><br><span class="line">    write(vehicle.state());</span><br><span class="line">    vehicle.accelerate();</span><br><span class="line">    write(vehicle.state());</span><br><span class="line">    write(vehicle.speed());</span><br><span class="line">    vehicle.decelerate();</span><br><span class="line">    write(vehicle.speed());</span><br><span class="line">    if (vehicle.state() != &quot;idle&quot;) &#123;</span><br><span class="line">        throw &quot;The vehicle is still moving!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    vehicle.stop();</span><br><span class="line">    write(vehicle.state());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据上面的代码，我们看到抛出的异常是“The vehicle is still moving!”，这是因为写这段代码的作者一直认为加速（accelerate）和减速（decelerate）的数字是一样的。但 FastVehicle 的代码和 Vehicle 的代码并不是完全能够替换掉的。因此，FastVehicle 违反了里氏替换原则。</p><p>在这点上，你可能会想：“但，客户端不能老假定 vehicle 都是按照这样的规则来做”，里氏替换原则(LSP)的妨碍（译者注：就是妨碍实现 LSP 的代码）不是基于我们所想的继承子类应该在行为里确保更新代码，而是这样的更新是否能在当前的期望中得到实现。</p><p>上述代码这个 case，解决这个不兼容的问题需要在 vehicle 类库或者客户端调用代码上进行一点重新设计，或者两者都要改。</p><h2 id="减少-LSP-妨碍"><a href="#减少-LSP-妨碍" class="headerlink" title="减少 LSP 妨碍"></a>减少 LSP 妨碍</h2><p>那么，我们如何避免 LSP 妨碍？不幸的话，并不是一直都是可以做到的。我们这里有几个策略我们处理这个事情。</p><h3 id="契约（Contracts）"><a href="#契约（Contracts）" class="headerlink" title="契约（Contracts）"></a>契约（Contracts）</h3><p>处理 LSP 过分妨碍的一个策略是使用契约，契约清单有 2 种形式：执行说明书（executable specifications）和错误处理，在执行说明书里，一个详细类库的契约也包括一组自动化测试，而错误处理是在代码里直接处理的，例如在前置条件，后置条件，常量检查等，可以从 Bertrand Miller 的大作<a href="http://en.wikipedia.org/wiki/Design_by_contract" target="_blank" rel="noopener">《契约设计》</a>中查看这个技术。虽然自动化测试和契约设计不在本篇文字的范围内，但当我们用的时候我还是推荐如下内容：</p><ol><li>检查使用测试驱动开发（Test-Driven Development）来指导你代码的设计</li><li>设计可重用类库的时候可随意使用契约设计技术</li></ol><p>对于你自己要维护和实现的代码，使用契约设计趋向于添加很多不必要的代码，如果你要控制输入，添加测试是非常有必要的，如果你是类库作者，使用契约设计，你要注意不正确的使用方法以及让你的用户使之作为一个测试工具。</p><h3 id="避免继承"><a href="#避免继承" class="headerlink" title="避免继承"></a>避免继承</h3><p>避免 LSP 妨碍的另外一个测试是：如果可能的话，尽量不用继承，在Gamma的大作<a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612" target="_blank" rel="noopener">《Design Patterns – Elements of Reusable Object-Orineted Software》</a>中，我们可以看到如下建议：</p><blockquote><p>Favor object composition over class inheritance<br>尽量使用对象组合而不是类继承</p></blockquote><p>有些书里讨论了组合比继承好的唯一作用是静态类型，基于类的语言（例如，在运行时可以改变行为），与 JavaScript 相关的一个问题是耦合，当使用继承的时候，继承子类型和他们的基类型耦合在一起了，就是说基类型的改变会影响到继承子类型。组合倾向于对象更小化，更容易向静态和动态语言语言维护。</p><h2 id="与行为有关，而不是继承"><a href="#与行为有关，而不是继承" class="headerlink" title="与行为有关，而不是继承"></a>与行为有关，而不是继承</h2><p>到现在，我们讨论了和继承上下文在内的里氏替换原则，指示出 JavaScript 的面向对象实。不过，里氏替换原则（LSP）的本质不是真的和继承有关，而是行为兼容性。JavaScript 是一个动态语言，一个对象的契约行为不是对象的类型决定的，而是对象期望的功能决定的。里氏替换原则的初始构想是作为继承的一个原则指南，等价于对象设计中的隐式接口。</p><p>举例来说，让我们来看一下 Robert C. Martin的 大作<a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612" target="_blank" rel="noopener">《敏捷软件开发 原则、模式与实践》</a>中的一个矩形类型：</p><h3 id="矩形例子"><a href="#矩形例子" class="headerlink" title="矩形例子"></a>矩形例子</h3><p>考虑我们有一个程序用到下面这样的一个矩形对象:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var rectangle = &#123;</span><br><span class="line">    length: 0,</span><br><span class="line">    width: 0</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>过后，程序有需要一个正方形，由于正方形就是一个长(length)和宽(width)都一样的特殊矩形，所以我们觉得创建一个正方形代替矩形。我们添加了 length 和 width 属性来匹配矩形的声明，但我们觉得使用属性的g etters/setters 一般我们可以让 length 和 width 保存同步，确保声明的是一个正方形：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var square = &#123;&#125;;</span><br><span class="line">(function() &#123;</span><br><span class="line">    var length = 0, width = 0;</span><br><span class="line">    // 注意defineProperty方式是262-5版的新特性</span><br><span class="line">    Object.defineProperty(square, &quot;length&quot;, &#123;</span><br><span class="line">        get: function() &#123; return length; &#125;,</span><br><span class="line">        set: function(value) &#123; length = width = value; &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Object.defineProperty(square, &quot;width&quot;, &#123;</span><br><span class="line">        get: function() &#123; return width; &#125;,</span><br><span class="line">        set: function(value) &#123; length = width = value; &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>不幸的是，当我们使用正方形代替矩形执行代码的时候发现了问题，其中一个计算矩形面积的方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var g = function(rectangle) &#123;</span><br><span class="line">    rectangle.length = 3;</span><br><span class="line">    rectangle.width = 4;</span><br><span class="line">    write(rectangle.length);</span><br><span class="line">    write(rectangle.width);</span><br><span class="line">    write(rectangle.length * rectangle.width);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该方法在调用的时候，结果是 16，而不是期望的 12，我们的正方形 square 对象违反了 LSP 原则，square 的长度和宽度属性暗示着并不是和矩形 100% 兼容，但我们并不总是这样明确的暗示。解决这个问题，我们可以重新设计一个 shape 对象来实现程序，依据多边形的概念，我们声明 rectangle 和square，relevant。不管怎么说，我们的目的是要说里氏替换原则并不只是继承，而是任何方法（其中的行为可以另外的行为）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>里氏替换原则（LSP）表达的意思不是继承的关系，而是任何方法（只要该方法的行为能体会另外的行为就行）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章我们要讲解的是 S.O.L.I.D 五大原则 JavaScript 语言实现的第3篇，里氏替换原则 LSP（The Liskov Substitution Principle ）。&lt;/p&gt;
&lt;p&gt;开闭原则的描述是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Subtypes must be substitutable for their base types.&lt;br&gt;派生类型必须可以替换它的基类型。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Function 模式（上篇）</title>
    <link href="http://xuhongbo.com/2016/08/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript/49Function%20%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/"/>
    <id>http://xuhongbo.com/2016/08/02/深入理解javascript/49Function 模式（上篇）/</id>
    <published>2016-08-02T09:02:02.000Z</published>
    <updated>2017-03-02T17:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要是介绍 Function 方面使用的一些技巧（上篇），利用 Function 特性可以编写出很多非常有意思的代码，本篇主要包括：回调模式、配置对象、返回函数、分布程序、柯里化（Currying）。<br><a id="more"></a></p><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>在 JavaScript 中，当一个函数 A 作为另外一个函数 B 的其中一个参数时，则函数 A 称为回调函数，即 A 可以在函数 B 的周期内执行（开始、中间、结束时均可）。</p><p>举例来说，有一个函数用于生成 node</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var complexComputation = function () &#123; /* 内部处理，并返回一个node*/&#125;;</span><br><span class="line">有一个findNodes函数声明用于查找所有的节点，然后通过callback回调进行执行代码。  </span><br><span class="line">var findNodes = function (callback) &#123;</span><br><span class="line">var nodes = [];  </span><br><span class="line">var node = complexComputation();  </span><br><span class="line">// 如果回调函数可用，则执行它</span><br><span class="line">if (typeof callback === &quot;function&quot;) &#123;</span><br><span class="line">callback(node);</span><br><span class="line">&#125;  </span><br><span class="line">nodes.push(node);</span><br><span class="line">return nodes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于 callback 的定义，我们可以事先定义好来用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 定义callback</span><br><span class="line">var hide = function (node) &#123;</span><br><span class="line">node.style.display = &quot;none&quot;;</span><br><span class="line">&#125;; </span><br><span class="line">// 查找node，然后隐藏所有的node</span><br><span class="line">var hiddenNodes = findNodes(hide);</span><br><span class="line">也可以直接在调用的时候使用匿名定义，如下：  </span><br><span class="line">// 使用匿名函数定义callback</span><br><span class="line">var blockNodes = findNodes(function (node) &#123;</span><br><span class="line">node.style.display = &apos;block&apos;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们平时用的最多的，估计就数 jQuery 的 ajax 方法的调用了，通过在 done/faild 上定义 callback，以便在 ajax 调用成功或者失败的时候做进一步处理，代码如下(本代码基于 jquery1.8 版)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var menuId = $(&quot;ul.nav&quot;).first().attr(&quot;id&quot;);</span><br><span class="line">var request = $.ajax(&#123;</span><br><span class="line">  url: &quot;script.php&quot;,</span><br><span class="line">  type: &quot;POST&quot;,</span><br><span class="line">  data: &#123;id : menuId&#125;,</span><br><span class="line">  dataType: &quot;html&quot;</span><br><span class="line">&#125;);  </span><br><span class="line">//调用成功时的回调处理</span><br><span class="line">request.done(function(msg) &#123;</span><br><span class="line">  $(&quot;#log&quot;).html( msg );</span><br><span class="line">&#125;);  </span><br><span class="line">//调用失败时的回调处理</span><br><span class="line">request.fail(function(jqXHR, textStatus) &#123;</span><br><span class="line">  alert( &quot;Request failed: &quot; + textStatus );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="配置对象"><a href="#配置对象" class="headerlink" title="配置对象"></a>配置对象</h2><p>如果一个函数（或方法）的参数只有一个参数，并且参数为对象字面量，我们则称这种模式为配置对象模式。例如，如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var conf = &#123;</span><br><span class="line">    username:&quot;shichuan&quot;,</span><br><span class="line">    first:&quot;Chuan&quot;,</span><br><span class="line">    last:&quot;Shi&quot;</span><br><span class="line">&#125;;</span><br><span class="line">addPerson(conf);</span><br></pre></td></tr></table></figure><p>则在 addPerson 内部，就可以随意使用 conf 的值了，一般用于初始化工作，例如 jquery 里的 ajaxSetup 也就是这种方式来实现的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 事先设置好初始值</span><br><span class="line">$.ajaxSetup(&#123;</span><br><span class="line">   url: &quot;/xmlhttp/&quot;,</span><br><span class="line">   global: false,</span><br><span class="line">   type: &quot;POST&quot;</span><br><span class="line"> &#125;);  </span><br><span class="line">// 然后再调用</span><br><span class="line"> $.ajax(&#123; data: myData &#125;);</span><br></pre></td></tr></table></figure><p>另外，很多 jquery 的插件也有这种形式的传参，只不过也可以不传，不传的时候则就使用默认值了。</p><h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><p>返回函数，则是指在一个函数的返回值为另外一个函数，或者根据特定的条件灵活创建的新函数，示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var setup = function () &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    return function () &#123;</span><br><span class="line">        console.log(2);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;  </span><br><span class="line">// 调用setup 函数</span><br><span class="line">var my = setup(); // 输出 1</span><br><span class="line">my(); // 输出 2</span><br><span class="line">// 或者直接调用也可</span><br><span class="line">setup()();</span><br></pre></td></tr></table></figure><p>或者你可以利用闭包的特性，在 setup 函数里记录一个私有的计数器数字，通过每次调用来增加计数器，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var setup = function () &#123;</span><br><span class="line">    var count = 0;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        return ++count;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;   </span><br><span class="line">// 用法</span><br><span class="line">var next = setup();</span><br><span class="line">next(); // 返回 1</span><br><span class="line">next(); // 返回 2</span><br><span class="line">next(); // 返回 3</span><br></pre></td></tr></table></figure><h2 id="偏应用"><a href="#偏应用" class="headerlink" title="偏应用"></a>偏应用</h2><p>这里的偏应用，其实是将参数的传入工作分开进行，在有的时候一系列的操作可能会有某一个或几个参数始终完全一样，那么我们就可以先定义一个偏函数，然后再去执行这个函数（执行时传入剩余的不同参数）。</p><p>举个例子，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var partialAny = (function (aps) &#123;</span><br><span class="line">    // 该函数是你们自执行函数表达式的结果，并且赋值给了partialAny变量</span><br><span class="line">    function func(fn) &#123;</span><br><span class="line">        var argsOrig = aps.call(arguments, 1);</span><br><span class="line">        return function () &#123;</span><br><span class="line">            var args = [],</span><br><span class="line">                argsPartial = aps.call(arguments),</span><br><span class="line">                i = 0;  </span><br><span class="line">            // 变量所有的原始参数集，</span><br><span class="line">            // 如果参数是partialAny._ 占位符，则使用下一个函数参数对应的值</span><br><span class="line">            // 否则使用原始参数里的值</span><br><span class="line">            for (; i &lt; argsOrig.length; i++) &#123;</span><br><span class="line">                args[i] = argsOrig[i] === func._</span><br><span class="line">                            ? argsPartial.shift()</span><br><span class="line">                            : argsOrig[i];</span><br><span class="line">            &#125;  </span><br><span class="line">            // 如果有任何多余的参数，则添加到尾部</span><br><span class="line">            return fn.apply(this, args.concat(argsPartial));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  </span><br><span class="line">    // 用于占位符设置</span><br><span class="line">    func._ = &#123;&#125;;  </span><br><span class="line">    return func;</span><br><span class="line">&#125;)(Array.prototype.slice);</span><br></pre></td></tr></table></figure><p>使用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 定义处理函数</span><br><span class="line">function hex(r, g, b) &#123;</span><br><span class="line">    return &apos;#&apos; + r + g + b;</span><br><span class="line">&#125;  </span><br><span class="line">//定义偏函数, 将hex的第一个参数r作为不变的参数值ff</span><br><span class="line">var redMax = partialAny(hex, &apos;ff&apos;, partialAny._, partialAny._);  </span><br><span class="line">// 新函数redMax的调用方式如下，只需要传入2个参数了：</span><br><span class="line">console.log(redMax(&apos;11&apos;, &apos;22&apos;)); // &quot;#ff1122&quot;</span><br></pre></td></tr></table></figure><p>如果觉得 partialAny._太长，可以用__代替哦。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var __ = partialAny._;</span><br><span class="line">var greenMax = partialAny(hex, __, &apos;ff&apos;);</span><br><span class="line">console.log(greenMax(&apos;33&apos;, &apos;44&apos;));</span><br><span class="line">var blueMax = partialAny(hex, __, __, &apos;ff&apos;);</span><br><span class="line">console.log(blueMax(&apos;55&apos;, &apos;66&apos;));</span><br><span class="line">var magentaMax = partialAny(hex, &apos;ff&apos;, __, &apos;ff&apos;);</span><br><span class="line">console.log(magentaMax(&apos;77&apos;));</span><br></pre></td></tr></table></figure><p>这样使用，就简洁多了吧。</p><h2 id="Currying"><a href="#Currying" class="headerlink" title="Currying"></a>Currying</h2><p>Currying 是函数式编程的一个特性，将多个参数的处理转化成单个参数的处理，类似链式调用。</p><p>举一个简单的 add 函数的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">    var oldx = x, oldy = y;</span><br><span class="line">    if (typeof oldy === &quot;undefined&quot;) &#123; // partial</span><br><span class="line">        return function (newy) &#123;</span><br><span class="line">            return oldx + newy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样调用方式就可以有多种了，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 测试</span><br><span class="line">typeof add(5); // &quot;function&quot;</span><br><span class="line">add(3)(4); // 7  </span><br><span class="line">// 也可以这样调用</span><br><span class="line">var add2000 = add(2000);</span><br><span class="line">add2000(10); // 2010</span><br></pre></td></tr></table></figure><p>接下来，我们来定义一个比较通用的 currying 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 第一个参数为要应用的function，第二个参数是需要传入的最少参数个数</span><br><span class="line">function curry(func, minArgs) &#123;</span><br><span class="line">    if (minArgs == undefined) &#123;</span><br><span class="line">        minArgs = 1;</span><br><span class="line">    &#125;  </span><br><span class="line">    function funcWithArgsFrozen(frozenargs) &#123;</span><br><span class="line">        return function () &#123;</span><br><span class="line">            // 优化处理，如果调用时没有参数，返回该函数本身</span><br><span class="line">            var args = Array.prototype.slice.call(arguments);</span><br><span class="line">            var newArgs = frozenargs.concat(args);</span><br><span class="line">            if (newArgs.length &gt;= minArgs) &#123;</span><br><span class="line">                return func.apply(this, newArgs);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return funcWithArgsFrozen(newArgs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  </span><br><span class="line">    return funcWithArgsFrozen([]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就可以随意定义我们的业务行为了，比如定义加法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var plus = curry(function () &#123;</span><br><span class="line">    var result = 0;</span><br><span class="line">    for (var i = 0; i &lt; arguments.length; ++i) &#123;</span><br><span class="line">        result += arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;, 2);</span><br></pre></td></tr></table></figure><p>使用方式，真实多种多样哇。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plus(3, 2) // 正常调用</span><br><span class="line">plus(3) // 偏应用，返回一个函数（返回值为3+参数值）</span><br><span class="line">plus(3)(2) // 完整应用（返回5）</span><br><span class="line">plus()(3)()()(2) // 返回 5</span><br><span class="line">plus(3, 2, 4, 5) // 可以接收多个参数</span><br><span class="line">plus(3)(2, 3, 5) // 同理</span><br></pre></td></tr></table></figure><p>如下是减法的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var minus = curry(function (x) &#123;</span><br><span class="line">    var result = x;</span><br><span class="line">    for (var i = 1; i &lt; arguments.length; ++i) &#123;</span><br><span class="line">        result -= arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;, 2);</span><br></pre></td></tr></table></figure><p>或者如果你想交换参数的顺序，你可以这样定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var flip = curry(function (func) &#123;</span><br><span class="line">    return curry(function (a, b) &#123;</span><br><span class="line">        return func(b, a);</span><br><span class="line">    &#125;, 2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JavaScript 里的 Function 有很多特殊的功效，可以利用闭包以及 arguments 参数特性实现很多不同的技巧，下一篇我们将继续介绍利用 Function 进行初始化的技巧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇主要是介绍 Function 方面使用的一些技巧（上篇），利用 Function 特性可以编写出很多非常有意思的代码，本篇主要包括：回调模式、配置对象、返回函数、分布程序、柯里化（Currying）。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>变量对象（Variable Object）</title>
    <link href="http://xuhongbo.com/2016/07/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript/12%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%EF%BC%88Variable%20Object%EF%BC%89/"/>
    <id>http://xuhongbo.com/2016/07/16/深入理解javascript/12变量对象（Variable Object）/</id>
    <published>2016-07-16T09:06:02.000Z</published>
    <updated>2017-03-02T17:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 编程的时候总避免不了声明函数和变量，以成功构建我们的系统，但是解释器是如何并且在什么地方去查找这些函数和变量呢？我们引用这些对象的时候究竟发生了什么？</p><p>大多数 ECMAScript 程序员应该都知道变量与执行上下文有密切关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 10; // 全局上下文中的变量</span><br><span class="line">(function () &#123;</span><br><span class="line">  var b = 20; // function上下文中的局部变量</span><br><span class="line">&#125;)();</span><br><span class="line">alert(a); // 10</span><br><span class="line">alert(b); // 全局变量 &quot;b&quot; 没有声明</span><br></pre></td></tr></table></figure><a id="more"></a><p>并且，很多程序员也都知道，当前 ECMAScript 规范指出独立作用域只能通过“函数(function)”代码类型的执行上下文创建。也就是说，相对于 C/C++来说，ECMAScript 里的 for 循环并不能创建一个局部的上下文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (var k in &#123;a: 1, b: 2&#125;) &#123;</span><br><span class="line">  alert(k);</span><br><span class="line">&#125;</span><br><span class="line">alert(k); // 尽管循环已经结束但变量k依然在当前作用域</span><br></pre></td></tr></table></figure><p>我们来看看一下，我们声明数据的时候到底都发现了什么细节。</p><h2 id="数据声明"><a href="#数据声明" class="headerlink" title="数据声明"></a>数据声明</h2><p>如果变量与执行上下文相关，那变量自己应该知道它的数据存储在哪里，并且知道如何访问。这种机制称为变量对象(variable object)。</p><blockquote><p>变量对象(缩写为 VO)是一个与执行上下文相关的特殊对象，它存储着在上下文中声明的以下内容：</p></blockquote><ul><li>变量 (var, 变量声明)；</li><li>函数声明 (FunctionDeclaration, 缩写为 FD)；</li><li>函数的形参；</li></ul><p>举例来说，我们可以用普通的 ECMAScript 对象来表示一个变量对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VO = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>就像我们所说的，VO 就是执行上下文的属性(property)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">activeExecutionContext = &#123;</span><br><span class="line">  VO: &#123;</span><br><span class="line">    // 上下文数据（var, FD, function arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>只有全局上下文的变量对象允许通过 VO 的属性名称来间接访问(因为在全局上下文里，全局对象自身就是变量对象，稍后会详细介绍)，在其它上下文中是不能直接访问 VO 对象的，因为它只是内部机制的一个实现。</p><p>当我们声明一个变量或一个函数的时候，和我们创建 VO 新属性的时候一样没有别的区别（即：有名称以及对应的值）。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">function test(x) &#123;</span><br><span class="line">  var b = 20;</span><br><span class="line">&#125;;</span><br><span class="line">test(30);</span><br></pre></td></tr></table></figure><p>对应的变量对象是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 全局上下文的变量对象</span><br><span class="line">VO(globalContext) = &#123;</span><br><span class="line">  a: 10,</span><br><span class="line">  test: &lt;reference to function&gt;</span><br><span class="line">&#125;;</span><br><span class="line">// test函数上下文的变量对象</span><br><span class="line">VO(test functionContext) = &#123;</span><br><span class="line">  x: 30,</span><br><span class="line">  b: 20</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在具体实现层面(以及规范中)变量对象只是一个抽象概念。(从本质上说，在具体执行上下文中，VO 名称是不一样的，并且初始结构也不一样。</p><h2 id="不同执行上下文中的变量对象"><a href="#不同执行上下文中的变量对象" class="headerlink" title="不同执行上下文中的变量对象"></a>不同执行上下文中的变量对象</h2><p>对于所有类型的执行上下文来说，变量对象的一些操作(如变量初始化)和行为都是共通的。从这个角度来看，把变量对象作为抽象的基本事物来理解更为容易。同样在函数上下文中也定义和变量对象相关的额外内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">抽象变量对象VO (变量初始化过程的一般行为)</span><br><span class="line">  ║</span><br><span class="line">  ╠══&gt; 全局上下文变量对象GlobalContextVO</span><br><span class="line">  ║        (VO === this === global)</span><br><span class="line">  ║</span><br><span class="line">  ╚══&gt; 函数上下文变量对象FunctionContextVO</span><br><span class="line">           (VO === AO, 并且添加了&lt;arguments&gt;和&lt;formal parameters&gt;)</span><br></pre></td></tr></table></figure><p>我们来详细看一下：</p><h2 id="全局上下文中的变量对象"><a href="#全局上下文中的变量对象" class="headerlink" title="全局上下文中的变量对象"></a>全局上下文中的变量对象</h2><p>首先，我们要给全局对象一个明确的定义：</p><ul><li>全局对象(Global object) 是在进入任何执行上下文之前就已经创建了的对象；</li><li>这个对象只存在一份，它的属性在程序中任何地方都可以访问，全局对象的生命周期终止于程序退出那一刻。</li></ul><p>全局对象初始创建阶段将 Math、String、Date、parseInt 作为自身属性，等属性初始化，同样也可以有额外创建的其它对象作为属性（其可以指向到全局对象自身）。例如，在 DOM 中，全局对象的 window 属性就可以引用全局对象自身(当然，并不是所有的具体实现都是这样)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">global = &#123;</span><br><span class="line">  Math: &lt;...&gt;,</span><br><span class="line">  String: &lt;...&gt;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  window: global //引用自身</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当访问全局对象的属性时通常会忽略掉前缀，这是因为全局对象是不能通过名称直接访问的。不过我们依然可以通过全局上下文的 this 来访问全局对象，同样也可以递归引用自身。例如，DOM 中的 window。综上所述，代码可以简写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String(10); // 就是global.String(10);</span><br><span class="line">// 带有前缀</span><br><span class="line">window.a = 10; // === global.window.a = 10 === global.a = 10;</span><br><span class="line">this.b = 20; // global.b = 20;</span><br></pre></td></tr></table></figure><p>因此，回到全局上下文中的变量对象——在这里，变量对象就是全局对象自己：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VO(globalContext) === global;</span><br></pre></td></tr></table></figure><p>非常有必要要理解上述结论，基于这个原理，在全局上下文中声明的对应，我们才可以间接通过全局对象的属性来访问它（例如，事先不知道变量名称）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = new String(&apos;test&apos;);</span><br><span class="line">alert(a); // 直接访问，在VO(globalContext)里找到：&quot;test&quot;</span><br><span class="line">alert(window[&apos;a&apos;]); // 间接通过global访问：global === VO(globalContext): &quot;test&quot;</span><br><span class="line">alert(a === this.a); // true</span><br><span class="line">var aKey = &apos;a&apos;;</span><br><span class="line">alert(window[aKey]); // 间接通过动态属性名称访问：&quot;test&quot;</span><br></pre></td></tr></table></figure><h2 id="函数上下文中的变量对象"><a href="#函数上下文中的变量对象" class="headerlink" title="函数上下文中的变量对象"></a>函数上下文中的变量对象</h2><p>在函数执行上下文中，VO 是不能直接访问的，此时由活动对象(activation object，缩写为 AO)扮演 VO 的角色。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VO(functionContext) === AO;</span><br></pre></td></tr></table></figure><p>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性的值是 Arguments 对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">  arguments: &lt;ArgO&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Arguments 对象是活动对象的一个属性，它包括如下属性：</p><ol><li>callee — 指向当前函数的引用</li><li>length — 真正传递的参数个数</li><li>properties-indexes (字符串类型的整数) 属性的值就是函数的参数值(按参数列表从左到右排列)。 properties-indexes 内部元素的个数等于 arguments.length. properties-indexes 的值和实际传递进来的参数之间是共享的。</li></ol><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function foo(x, y, z) &#123;</span><br><span class="line">  // 声明的函数参数数量arguments (x, y, z)</span><br><span class="line">  alert(foo.length); // 3</span><br><span class="line">  // 真正传进来的参数个数(only x, y)</span><br><span class="line">  alert(arguments.length); // 2</span><br><span class="line">  // 参数的callee是函数自身</span><br><span class="line">  alert(arguments.callee === foo); // true</span><br><span class="line">  // 参数共享</span><br><span class="line">  alert(x === arguments[0]); // true</span><br><span class="line">  alert(x); // 10</span><br><span class="line">  arguments[0] = 20;</span><br><span class="line">  alert(x); // 20</span><br><span class="line">  x = 30;</span><br><span class="line">  alert(arguments[0]); // 30</span><br><span class="line">  // 不过，没有传进来的参数z，和参数的第3个索引值是不共享的</span><br><span class="line">  z = 40;</span><br><span class="line">  alert(arguments[2]); // undefined</span><br><span class="line">  arguments[2] = 50;</span><br><span class="line">  alert(z); // 40</span><br><span class="line">&#125;</span><br><span class="line">foo(10, 20);</span><br></pre></td></tr></table></figure><p>这个例子的代码，在当前版本的 Google Chrome 浏览器里有一个 bug — 即使没有传递参数 z，z 和 arguments[2]仍然是共享的。</p><h2 id="处理上下文代码的-2-个阶段"><a href="#处理上下文代码的-2-个阶段" class="headerlink" title="处理上下文代码的 2 个阶段"></a>处理上下文代码的 2 个阶段</h2><p>现在我们终于到了本文的核心点了。执行上下文的代码被分成两个基本的阶段来处理：</p><ol><li>进入执行上下文</li><li>执行代码</li></ol><p>变量对象的修改变化与这两个阶段紧密相关。</p><p>注：这 2 个阶段的处理是一般行为，和上下文的类型无关（也就是说，在全局上下文和函数上下文中的表现是一样的）。</p><h2 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h2><p>当进入执行上下文(代码执行之前)时，VO 里已经包含了下列属性(前面已经说了)：</p><h3 id="函数的所有形参-如果我们是在函数执行上下文中"><a href="#函数的所有形参-如果我们是在函数执行上下文中" class="headerlink" title="函数的所有形参(如果我们是在函数执行上下文中)"></a>函数的所有形参(如果我们是在函数执行上下文中)</h3><p>— 由名称和对应值组成的一个变量对象的属性被创建；没有传递对应参数的话，那么由名称和 undefined 值组成的一种变量对象的属性也将被创建。</p><h3 id="所有函数声明-FunctionDeclaration-FD"><a href="#所有函数声明-FunctionDeclaration-FD" class="headerlink" title="所有函数声明(FunctionDeclaration, FD)"></a>所有函数声明(FunctionDeclaration, FD)</h3><p>—由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建；如果变量对象已经存在相同名称的属性，则完全替换这个属性。</p><h3 id="所有变量声明-var-VariableDeclaration"><a href="#所有变量声明-var-VariableDeclaration" class="headerlink" title="所有变量声明(var, VariableDeclaration)"></a>所有变量声明(var, VariableDeclaration)</h3><p>— 由名称和对应值（undefined）组成一个变量对象的属性被创建；如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。</p><p>让我们看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test(a, b) &#123;</span><br><span class="line">  var c = 10;</span><br><span class="line">  function d() &#123;&#125;</span><br><span class="line">  var e = function _e() &#123;&#125;;</span><br><span class="line">  (function x() &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line">test(10); // call</span><br></pre></td></tr></table></figure><p>当进入带有参数 10 的 test 函数上下文时，AO 表现为如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AO(test) = &#123;</span><br><span class="line">  a: 10,</span><br><span class="line">  b: undefined,</span><br><span class="line">  c: undefined,</span><br><span class="line">  d: &lt;reference to FunctionDeclaration &quot;d&quot;&gt;</span><br><span class="line">  e: undefined</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，AO 里并不包含函数“x”。这是因为“x” 是一个函数表达式(FunctionExpression, 缩写为 FE) 而不是函数声明，函数表达式不会影响 VO。 不管怎样，函数“_e” 同样也是函数表达式，但是就像我们下面将看到的那样，因为它分配给了变量 “e”，所以它可以通过名称“e”来访问。 函数声明 FunctionDeclaration 与函数表达式 FunctionExpression 的不同，将在第 15 章 Functions 进行详细的探讨，也可以参考本系列第 2 章揭秘命名函数表达式来了解。</p><p>这之后，将进入处理上下文代码的第二个阶段 — 执行代码。</p><h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><p>这个周期内，AO/VO 已经拥有了属性(不过，并不是所有的属性都有值，大部分属性的值还是系统默认的初始值 undefined )。</p><p>还是前面那个例子， AO/VO 在代码解释期间被修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AO[&apos;c&apos;] = 10;</span><br><span class="line">AO[&apos;e&apos;] = &lt;reference to FunctionExpression &quot;_e&quot;&gt;;</span><br></pre></td></tr></table></figure><p>再次注意，因为 FunctionExpression“_e”保存到了已声明的变量“e”上，所以它仍然存在于内存中。而 FunctionExpression “x”却不存在于 AO/VO 中，也就是说如果我们想尝试调用“x”函数，不管在函数定义之前还是之后，都会出现一个错误“x is not defined”，未保存的函数表达式只有在它自己的定义或递归中才能被调用。</p><p>另一个经典例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alert(x); // function</span><br><span class="line">var x = 10;</span><br><span class="line">alert(x); // 10</span><br><span class="line">x = 20;</span><br><span class="line">function x() &#123;&#125;; </span><br><span class="line">alert(x); // 20</span><br></pre></td></tr></table></figure><p>为什么第一个 alert “x” 的返回值是 function，而且它还是在“x” 声明之前访问的“x” 的？为什么不是 10 或 20 呢？因为，根据规范函数声明是在当<strong>进入上下文</strong>时填入的； 同意周期，在进入上下文的时候还有一个变量声明“x”，那么正如我们在上一个阶段所说，变量声明在顺序上跟在函数声明和形式参数声明之后，而且在这个<strong>进入上下文</strong>阶段，变量声明不会干扰VO 中已经存在的同名函数声明或形式参数声明，因此，在进入上下文时，VO 的结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VO = &#123;&#125;;</span><br><span class="line">VO[&apos;x&apos;] = &lt;reference to FunctionDeclaration &quot;x&quot;&gt;</span><br><span class="line">// 找到var x = 10;</span><br><span class="line">// 如果function &quot;x&quot;没有已经声明的话</span><br><span class="line">// 这时候&quot;x&quot;的值应该是undefined</span><br><span class="line">// 但是这个case里变量声明没有影响同名的function的值</span><br><span class="line">VO[&apos;x&apos;] = &lt;the value is not disturbed, still function&gt;</span><br></pre></td></tr></table></figure><p>紧接着，在执行代码阶段，VO 做如下修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VO[&apos;x&apos;] = 10;</span><br><span class="line">VO[&apos;x&apos;] = 20;</span><br></pre></td></tr></table></figure><p>我们可以在第二、三个 alert 看到这个效果。</p><p>在下面的例子里我们可以再次看到，变量是在进入上下文阶段放入 VO 中的。(因为，虽然 else 部分代码永远不会执行，但是不管怎样，变量“b”仍然存在于 VO 中。)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  var a = 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  var b = 2;</span><br><span class="line">&#125;</span><br><span class="line">alert(a); // 1</span><br><span class="line">alert(b); // undefined,不是b没有声明，而是b的值是undefined</span><br></pre></td></tr></table></figure><h2 id="关于变量"><a href="#关于变量" class="headerlink" title="关于变量"></a>关于变量</h2><p>通常，各类文章和 JavaScript 相关的书籍都声称：“不管是使用 var 关键字(在全局上下文)还是不使用 var 关键字(在任何地方)，都可以声明一个变量”。请记住，这是错误的概念：</p><p><code>任何时候，变量只能通过使用 var 关键字才能声明。</code></p><p>上面的赋值语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 10;</span><br></pre></td></tr></table></figure><p>这仅仅是给全局对象创建了一个新属性(但它不是变量)。“不是变量”并不是说它不能被改变，而是指它不符合 ECMAScript 规范中的变量概念，所以它“不是变量”(它之所以能成为全局对象的属性，完全是因为 VO(globalContext) === global，大家还记得这个吧？)。</p><p>让我们通过下面的实例看看具体的区别吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(a); // undefined</span><br><span class="line">alert(b); // &quot;b&quot; 没有声明</span><br><span class="line">b = 10;</span><br><span class="line">var a = 20;</span><br></pre></td></tr></table></figure><p>所有根源仍然是 VO 和进入上下文阶段和代码执行阶段：</p><p>进入上下文阶段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VO = &#123;</span><br><span class="line">  a: undefined</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以看到，因为“b”不是一个变量，所以在这个阶段根本就没有“b”，“b”将只在代码执行阶段才会出现(但是在我们这个例子里，还没有到那就已经出错了)。</p><p>让我们改变一下例子代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alert(a); // undefined, 这个大家都知道，</span><br><span class="line">b = 10;</span><br><span class="line">alert(b); // 10, 代码执行阶段创建</span><br><span class="line">var a = 20;</span><br><span class="line">alert(a); // 20, 代码执行阶段修改</span><br></pre></td></tr></table></figure><p>关于变量，还有一个重要的知识点。变量相对于简单属性来说，变量有一个特性(attribute)：{DontDelete}，这个特性的含义就是不能用 delete 操作符直接删除变量属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = 10;</span><br><span class="line">alert(window.a); // 10</span><br><span class="line">alert(delete a); // true</span><br><span class="line">alert(window.a); // undefined</span><br><span class="line">var b = 20;</span><br><span class="line">alert(window.b); // 20</span><br><span class="line">alert(delete b); // false</span><br><span class="line">alert(window.b); // still 20</span><br></pre></td></tr></table></figure><p>但是这个规则在有个上下文里不起走样，那就是 eval 上下文，变量没有{DontDelete}特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eval(&apos;var a = 10;&apos;);</span><br><span class="line">alert(window.a); // 10</span><br><span class="line">alert(delete a); // true</span><br><span class="line">alert(window.a); // undefined</span><br></pre></td></tr></table></figure><p>使用一些调试工具(例如：Firebug)的控制台测试该实例时，请注意，Firebug 同样是使用 eval 来执行控制台里你的代码。因此，变量属性同样没有{DontDelete}特性，可以被删除。</p><h2 id="特殊实现-parent-属性"><a href="#特殊实现-parent-属性" class="headerlink" title="特殊实现: parent 属性"></a>特殊实现: <strong>parent</strong> 属性</h2><p>前面已经提到过，按标准规范，活动对象是不可能被直接访问到的。但是，一些具体实现并没有完全遵守这个规定，例如 SpiderMonkey 和 Rhino；的实现中，函数有一个特殊的属性 <strong>parent</strong>，通过这个属性可以直接引用到活动对象（或全局变量对象），在此对象里创建了函数。</p><p>例如 (SpiderMonkey, Rhino)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var global = this;</span><br><span class="line">var a = 10;</span><br><span class="line">function foo() &#123;&#125;</span><br><span class="line">alert(foo.__parent__); // global</span><br><span class="line">var VO = foo.__parent__;</span><br><span class="line">alert(VO.a); // 10</span><br><span class="line">alert(VO === global); // true</span><br></pre></td></tr></table></figure><p>在上面的例子中我们可以看到，函数 foo 是在全局上下文中创建的，所以属性<strong>parent</strong> 指向全局上下文的变量对象，即全局对象。</p><p>然而，在SpiderMonkey中用同样的方式访问活动对象是不可能的：在不同版本的SpiderMonkey中，内部函数的<strong>parent</strong> 有时指向 null ，有时指向全局对象。</p><p>在 Rhino 中，用同样的方式访问活动对象是完全可以的。</p><p>例如 (Rhino)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var global = this;</span><br><span class="line">var x = 10;</span><br><span class="line">(function foo() &#123;</span><br><span class="line">  var y = 20;</span><br><span class="line">  // &quot;foo&quot;上下文里的活动对象</span><br><span class="line">  var AO = (function () &#123;&#125;).__parent__;</span><br><span class="line">  print(AO.y); // 20</span><br><span class="line">  // 当前活动对象的__parent__ 是已经存在的全局对象</span><br><span class="line">  // 变量对象的特殊链形成了</span><br><span class="line">  // 所以我们叫做作用域链</span><br><span class="line">  print(AO.__parent__ === global); // true</span><br><span class="line">  print(AO.__parent__.x); // 10</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章里，我们深入学习了跟执行上下文相关的对象。我希望这些知识对您来说能有所帮助，能解决一些您曾经遇到的问题或困惑。按照计划，在后续的章节中，我们将探讨作用域链，标识符解析，闭包。</p><h2 id="其它参考"><a href="#其它参考" class="headerlink" title="其它参考"></a>其它参考</h2><ol><li><a href="http://bclary.com/2004/11/07/#a-10.1.3" target="_blank" rel="noopener">Variable Instantiation</a>;</li><li><a href="http://bclary.com/2004/11/07/#a-10.1.5" target="_blank" rel="noopener">Global Object</a>;</li><li><a href="http://bclary.com/2004/11/07/#a-10.1.6" target="_blank" rel="noopener">Activation Object</a>;</li><li><a href="http://bclary.com/2004/11/07/#a-10.1.8" target="_blank" rel="noopener">Arguments Object</a>.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 编程的时候总避免不了声明函数和变量，以成功构建我们的系统，但是解释器是如何并且在什么地方去查找这些函数和变量呢？我们引用这些对象的时候究竟发生了什么？&lt;/p&gt;
&lt;p&gt;大多数 ECMAScript 程序员应该都知道变量与执行上下文有密切关系：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var a = 10; // 全局上下文中的变量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(function () &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  var b = 20; // function上下文中的局部变量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(a); // 10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(b); // 全局变量 &amp;quot;b&amp;quot; 没有声明&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>S.O.L.I.D 五大原则之开闭原则 OCP</title>
    <link href="http://xuhongbo.com/2016/06/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript/7S.O.L.I.D%20%E4%BA%94%E5%A4%A7%E5%8E%9F%E5%88%99%E4%B9%8B%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%20OCP/"/>
    <id>http://xuhongbo.com/2016/06/23/深入理解javascript/7S.O.L.I.D 五大原则之开闭原则 OCP/</id>
    <published>2016-06-23T09:02:02.000Z</published>
    <updated>2017-03-02T17:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>本章我们要讲解的是 S.O.L.I.D 五大原则 JavaScript 语言实现的第 2 篇，开闭原则 OCP（The Open/Closed Principle ）。</p><p>开闭原则的描述是：</p><blockquote><p>Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification.<br>软件实体（类，模块，方法等等）应当对扩展开放，对修改关闭，即软件实体应当在不修改的前提下扩展。<br><a id="more"></a><br>open for extension（对扩展开放）的意思是说当新需求出现的时候，可以通过扩展现有模型达到目的。而 Close for modification（对修改关闭）的意思是说不允许对该实体做任何修改，说白了，就是这些需要执行多样行为的实体应该设计成不需要修改就可以实现各种的变化，坚持开闭原则有利于用最少的代码进行项目维护。</p></blockquote><h2 id="问题代码"><a href="#问题代码" class="headerlink" title="问题代码"></a>问题代码</h2><p>为了直观地描述，我们来举个例子演示一下，下属代码是动态展示 question 列表的代码（没有使用开闭原则）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// 问题类型</span><br><span class="line">var AnswerType = &#123;</span><br><span class="line">    Choice: 0,</span><br><span class="line">    Input: 1</span><br><span class="line">&#125;;</span><br><span class="line">// 问题实体</span><br><span class="line">function question(label, answerType, choices) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        label: label,</span><br><span class="line">        answerType: answerType,</span><br><span class="line">        choices: choices // 这里的choices是可选参数</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var view = (function () &#123;</span><br><span class="line">    // render一个问题</span><br><span class="line">    function renderQuestion(target, question) &#123;</span><br><span class="line">        var questionWrapper = document.createElement(&apos;div&apos;);</span><br><span class="line">        questionWrapper.className = &apos;question&apos;;</span><br><span class="line">        var questionLabel = document.createElement(&apos;div&apos;);</span><br><span class="line">        questionLabel.className = &apos;question-label&apos;;</span><br><span class="line">        var label = document.createTextNode(question.label);</span><br><span class="line">        questionLabel.appendChild(label);</span><br><span class="line">        var answer = document.createElement(&apos;div&apos;);</span><br><span class="line">        answer.className = &apos;question-input&apos;;</span><br><span class="line">        // 根据不同的类型展示不同的代码：分别是下拉菜单和输入框两种</span><br><span class="line">        if (question.answerType === AnswerType.Choice) &#123;</span><br><span class="line">            var input = document.createElement(&apos;select&apos;);</span><br><span class="line">            var len = question.choices.length;</span><br><span class="line">            for (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">                var option = document.createElement(&apos;option&apos;);</span><br><span class="line">                option.text = question.choices[i];</span><br><span class="line">                option.value = question.choices[i];</span><br><span class="line">                input.appendChild(option);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (question.answerType === AnswerType.Input) &#123;</span><br><span class="line">            var input = document.createElement(&apos;input&apos;);</span><br><span class="line">            input.type = &apos;text&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        answer.appendChild(input);</span><br><span class="line">        questionWrapper.appendChild(questionLabel);</span><br><span class="line">        questionWrapper.appendChild(answer);</span><br><span class="line">        target.appendChild(questionWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        // 遍历所有的问题列表进行展示</span><br><span class="line">        render: function (target, questions) &#123;</span><br><span class="line">            for (var i = 0; i &lt; questions.length; i++) &#123;</span><br><span class="line">                renderQuestion(target, questions[i]);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">var questions = [</span><br><span class="line">                question(&apos;Have you used tobacco products within the last 30 days?&apos;, AnswerType.Choice, [&apos;Yes&apos;, &apos;No&apos;]),</span><br><span class="line">                question(&apos;What medications are you currently using?&apos;, AnswerType.Input)</span><br><span class="line">                ];</span><br><span class="line">var questionRegion = document.getElementById(&apos;questions&apos;);</span><br><span class="line">view.render(questionRegion, questions);</span><br></pre></td></tr></table></figure><p>上面的代码，view 对象里包含一个 render 方法用来展示 question 列表，展示的时候根据不同的 question 类型使用不同的展示方式，一个 question 包含一个 label 和一个问题类型以及 choices 的选项（如果是选择类型的话）。如果问题类型是 Choice 那就根据选项生产一个下拉菜单，如果类型是 Input，那就简单地展示 input输入框。</p><p>该代码有一个限制，就是如果再增加一个 question 类型的话，那就需要再次修改 renderQuestion 里的条件语句，这明显违反了开闭原则。</p><h2 id="重构代码"><a href="#重构代码" class="headerlink" title="重构代码"></a>重构代码</h2><p>让我们来重构一下这个代码，以便在出现新 question 类型的情况下允许扩展 view 对象的 render 能力，而不需要修改 view 对象内部的代码。</p><p>先来创建一个通用的 questionCreator 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function questionCreator(spec, my) &#123;</span><br><span class="line">    var that = &#123;&#125;;</span><br><span class="line">    my = my || &#123;&#125;;</span><br><span class="line">    my.label = spec.label;</span><br><span class="line">    my.renderInput = function () &#123;</span><br><span class="line">        throw &quot;not implemented&quot;; </span><br><span class="line">        // 这里renderInput没有实现，主要目的是让各自问题类型的实现代码去覆盖整个方法</span><br><span class="line">    &#125;;</span><br><span class="line">    that.render = function (target) &#123;</span><br><span class="line">        var questionWrapper = document.createElement(&apos;div&apos;);</span><br><span class="line">        questionWrapper.className = &apos;question&apos;;</span><br><span class="line">        var questionLabel = document.createElement(&apos;div&apos;);</span><br><span class="line">        questionLabel.className = &apos;question-label&apos;;</span><br><span class="line">        var label = document.createTextNode(spec.label);</span><br><span class="line">        questionLabel.appendChild(label);</span><br><span class="line">        var answer = my.renderInput();</span><br><span class="line">        // 该render方法是同样的粗合理代码</span><br><span class="line">        // 唯一的不同就是上面的一句my.renderInput()</span><br><span class="line">        // 因为不同的问题类型有不同的实现</span><br><span class="line">        questionWrapper.appendChild(questionLabel);</span><br><span class="line">        questionWrapper.appendChild(answer);</span><br><span class="line">        return questionWrapper;</span><br><span class="line">    &#125;;</span><br><span class="line">    return that;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码的作用组合要是 render 一个问题，同时提供一个未实现的 renderInput 方法以便其他 function 可以覆盖，以使用不同的问题类型，我们继续看一下每个问题类型的实现代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function choiceQuestionCreator(spec) &#123;</span><br><span class="line">    var my = &#123;&#125;,</span><br><span class="line">that = questionCreator(spec, my);           </span><br><span class="line">    // choice类型的renderInput实现</span><br><span class="line">    my.renderInput = function () &#123;</span><br><span class="line">        var input = document.createElement(&apos;select&apos;);</span><br><span class="line">        var len = spec.choices.length;</span><br><span class="line">        for (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            var option = document.createElement(&apos;option&apos;);</span><br><span class="line">            option.text = spec.choices[i];</span><br><span class="line">            option.value = spec.choices[i];</span><br><span class="line">            input.appendChild(option);</span><br><span class="line">        &#125;</span><br><span class="line">        return input;</span><br><span class="line">    &#125;;</span><br><span class="line">    return that;</span><br><span class="line">&#125;</span><br><span class="line">function inputQuestionCreator(spec) &#123;</span><br><span class="line">    var my = &#123;&#125;,</span><br><span class="line">that = questionCreator(spec, my);</span><br><span class="line">    // input类型的renderInput实现</span><br><span class="line">    my.renderInput = function () &#123;</span><br><span class="line">        var input = document.createElement(&apos;input&apos;);</span><br><span class="line">        input.type = &apos;text&apos;;</span><br><span class="line">        return input;</span><br><span class="line">    &#125;;</span><br><span class="line">    return that;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>choiceQuestionCreator 函数和 inputQuestionCreator 函数分别对应下拉菜单和 input 输入框的 renderInput 实现，通过内部调用统一的 questionCreator(spec, my)然后返回 that 对象（同一类型哦）。</p><p>view 对象的代码就很固定了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var view = &#123;</span><br><span class="line">    render: function(target, questions) &#123;</span><br><span class="line">        for (var i = 0; i &lt; questions.length; i++) &#123;</span><br><span class="line">            target.appendChild(questions[i].render());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以我们声明问题的时候只需要这样做，就 OK 了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var questions = [</span><br><span class="line">    choiceQuestionCreator(&#123;</span><br><span class="line">    label: &apos;Have you used tobacco products within the last 30 days?&apos;,</span><br><span class="line">    choices: [&apos;Yes&apos;, &apos;No&apos;]</span><br><span class="line">　　&#125;),</span><br><span class="line">    inputQuestionCreator(&#123;</span><br><span class="line">    label: &apos;What medications are you currently using?&apos;</span><br><span class="line">　　&#125;)</span><br><span class="line">    ];</span><br></pre></td></tr></table></figure><p>最终的使用代码，我们可以这样来用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var questionRegion = document.getElementById(&apos;questions&apos;);</span><br><span class="line">view.render(questionRegion, questions);</span><br></pre></td></tr></table></figure><p>重构后的最终代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">function questionCreator(spec, my) &#123;</span><br><span class="line">    var that = &#123;&#125;;</span><br><span class="line">    my = my || &#123;&#125;;</span><br><span class="line">    my.label = spec.label;</span><br><span class="line">    my.renderInput = function() &#123;</span><br><span class="line">        throw &quot;not implemented&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">    that.render = function(target) &#123;</span><br><span class="line">        var questionWrapper = document.createElement(&apos;div&apos;);</span><br><span class="line">        questionWrapper.className = &apos;question&apos;;</span><br><span class="line">        var questionLabel = document.createElement(&apos;div&apos;);</span><br><span class="line">        questionLabel.className = &apos;question-label&apos;;</span><br><span class="line">        var label = document.createTextNode(spec.label);</span><br><span class="line">        questionLabel.appendChild(label);</span><br><span class="line">        var answer = my.renderInput();</span><br><span class="line">        questionWrapper.appendChild(questionLabel);</span><br><span class="line">        questionWrapper.appendChild(answer);</span><br><span class="line">        return questionWrapper;</span><br><span class="line">    &#125;;</span><br><span class="line">    return that;</span><br><span class="line">&#125;</span><br><span class="line">function choiceQuestionCreator(spec) &#123;</span><br><span class="line">    var my = &#123;&#125;,</span><br><span class="line">        that = questionCreator(spec, my);</span><br><span class="line">    my.renderInput = function() &#123;</span><br><span class="line">        var input = document.createElement(&apos;select&apos;);</span><br><span class="line">        var len = spec.choices.length;</span><br><span class="line">        for (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            var option = document.createElement(&apos;option&apos;);</span><br><span class="line">            option.text = spec.choices[i];</span><br><span class="line">            option.value = spec.choices[i];</span><br><span class="line">            input.appendChild(option);</span><br><span class="line">        &#125;</span><br><span class="line">        return input;</span><br><span class="line">    &#125;;</span><br><span class="line">    return that;</span><br><span class="line">&#125;</span><br><span class="line">function inputQuestionCreator(spec) &#123;</span><br><span class="line">    var my = &#123;&#125;,</span><br><span class="line">        that = questionCreator(spec, my);</span><br><span class="line">    my.renderInput = function() &#123;</span><br><span class="line">        var input = document.createElement(&apos;input&apos;);</span><br><span class="line">        input.type = &apos;text&apos;;</span><br><span class="line">        return input;</span><br><span class="line">    &#125;;</span><br><span class="line">    return that;</span><br><span class="line">&#125;</span><br><span class="line">var view = &#123;</span><br><span class="line">    render: function(target, questions) &#123;</span><br><span class="line">        for (var i = 0; i &lt; questions.length; i++) &#123;</span><br><span class="line">            target.appendChild(questions[i].render());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var questions = [</span><br><span class="line">    choiceQuestionCreator(&#123;</span><br><span class="line">    label: &apos;Have you used tobacco products within the last 30 days?&apos;,</span><br><span class="line">    choices: [&apos;Yes&apos;, &apos;No&apos;]</span><br><span class="line">&#125;),</span><br><span class="line">    inputQuestionCreator(&#123;</span><br><span class="line">    label: &apos;What medications are you currently using?&apos;</span><br><span class="line">&#125;)</span><br><span class="line">    ];</span><br><span class="line">var questionRegion = document.getElementById(&apos;questions&apos;);</span><br><span class="line">view.render(questionRegion, questions);</span><br></pre></td></tr></table></figure><p>上面的代码里应用了一些技术点，我们来逐一看一下：</p><ol><li>首先，questionCreator 方法的创建，可以让我们使用模板方法模式将处理问题的功能 delegat 给针对每个问题类型的扩展代码 renderInput 上。</li><li>其次，我们用一个私有的 spec 属性替换掉了前面 question 方法的构造函数属性，因为我们封装了 render 行为进行操作，不再需要把这些属性暴露给外部代码了。</li><li>第三，我们为每个问题类型创建一个对象进行各自的代码实现，但每个实现里都必须包含 renderInput 方法以便覆盖 questionCreator 方法里的 renderInput 代码，这就是我们常说的策略模式。</li><li>通过重构，我们可以去除不必要的问题类型的枚举 AnswerType，而且可以让 choices 作为 choiceQuestionCreator 函数的必选参数（之前的版本是一个可选参数）。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>重构以后的版本的 view 对象可以很清晰地进行新的扩展了，为不同的问题类型扩展新的对象，然后声明 questions 集合的时候再里面指定类型就行了，view 对象本身不再修改任何改变，从而达到了开闭原则的要求。</p><p>另：懂 C#的话，不知道看了上面的代码后是否和多态的实现有些类似？其实上述的代码用原型也是可以实现的，大家可以自行研究一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章我们要讲解的是 S.O.L.I.D 五大原则 JavaScript 语言实现的第 2 篇，开闭原则 OCP（The Open/Closed Principle ）。&lt;/p&gt;
&lt;p&gt;开闭原则的描述是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification.&lt;br&gt;软件实体（类，模块，方法等等）应当对扩展开放，对修改关闭，即软件实体应当在不修改的前提下扩展。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ThisYes,this!</title>
    <link href="http://xuhongbo.com/2016/06/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript/13ThisYes,this!/"/>
    <id>http://xuhongbo.com/2016/06/22/深入理解javascript/13ThisYes,this!/</id>
    <published>2016-06-22T15:02:02.000Z</published>
    <updated>2017-03-02T17:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇文章里，我们将讨论跟执行上下文直接相关的更多细节。讨论的主题就是 this 关键字。实践证明，这个主题很难，在不同执行上下文中 this 的确定经常会发生问题。</p><p>许多程序员习惯的认为，在程序语言中，this 关键字与面向对象程序开发紧密相关，其完全指向由构造器新创建的对象。在 ECMAScript 规范中也是这样实现的，但正如我们将看到那样，在 ECMAScript 中，this 并不限于只用来指向新创建的对象。</p><p>让我们更详细的了解一下，在 ECMAScript 中 this 到底是什么？<br><a id="more"></a></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>this 是执行上下文中的一个属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">activeExecutionContext = &#123;</span><br><span class="line">  VO: &#123;...&#125;,</span><br><span class="line">  this: thisValue</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里 VO 是我们前一章讨论的变量对象。</p><p>this 与上下文中可执行代码的类型有直接关系，this 值在进入上下文时确定，并且在上下文运行期间永久不变。</p><p>下面让我们更详细研究这些案例：</p><h2 id="全局代码中的-this"><a href="#全局代码中的-this" class="headerlink" title="全局代码中的 this"></a>全局代码中的 this</h2><p>在这里一切都简单。在全局代码中，this 始终是全局对象本身，这样就有可能间接的引用到它了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 显示定义全局对象的属性</span><br><span class="line">this.a = 10; // global.a = 10</span><br><span class="line">alert(a); // 10</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 通过赋值给一个无标示符隐式</span><br><span class="line">b = 20;</span><br><span class="line">alert(this.b); // 20</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 也是通过变量声明隐式声明的</span><br><span class="line">// 因为全局上下文的变量对象是全局对象自身</span><br><span class="line">var c = 30;</span><br><span class="line">alert(this.c); // 30</span><br></pre></td></tr></table></figure><h2 id="函数代码中的-this"><a href="#函数代码中的-this" class="headerlink" title="函数代码中的 this"></a>函数代码中的 this</h2><p>在函数代码中使用 this 时很有趣，这种情况很难且会导致很多问题。</p><p>这种类型的代码中，this 值的首要特点（或许是最主要的）是它不是静态的绑定到一个函数。</p><p>正如我们上面曾提到的那样，this 是进入上下文时确定，在一个函数代码中，这个值在每一次完全不同。</p><p>不管怎样，在代码运行时的 this 值是不变的，也就是说，因为它不是一个变量，就不可能为其分配一个新值（相反，在 Python 编程语言中，它明确的定义为对象本身，在运行期间可以不断改变）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var foo = &#123;x: 10&#125;;</span><br><span class="line">var bar = &#123;</span><br><span class="line">  x: 20,</span><br><span class="line">  test: function () &#123;</span><br><span class="line">    alert(this === bar); // true</span><br><span class="line">    alert(this.x); // 20</span><br><span class="line">    this = foo; // 错误，任何时候不能改变this的值</span><br><span class="line">    alert(this.x); // 如果不出错的话，应该是10，而不是20</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 在进入上下文的时候</span><br><span class="line">// this被当成bar对象</span><br><span class="line">// determined as &quot;bar&quot; object; why so - will</span><br><span class="line">// be discussed below in detail</span><br><span class="line">bar.test(); // true, 20</span><br><span class="line">foo.test = bar.test;</span><br><span class="line">// 不过，这里this依然不会是foo</span><br><span class="line">// 尽管调用的是相同的function</span><br><span class="line">foo.test(); // false, 10</span><br></pre></td></tr></table></figure><p>那么，影响了函数代码中 this 值的变化有几个因素：</p><p>首先，在通常的函数调用中，this 是由激活上下文代码的调用者来提供的，即调用函数的父上下文(parent context )。this 取决于调用函数的方式。</p><p>为了在任何情况下准确无误的确定 this 值，有必要理解和记住这重要的一点。正是调用函数的方式影响了调用的上下文中的 this 值，没有别的什么（我们可以在一些文章，甚至是在关于 javascript 的书籍中看到，它们声称：“this 值取决于函数如何定义，如果它是全局函数，this 设置为全局对象，如果函数是一个对象的方法，this 将总是指向这个对象。–这绝对不正确”）。继续我们的话题，可以看到，即使是正常的全局函数也会被调用方式的不同形式激活，这些不同的调用方式导致了不同的 this 值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  alert(this);</span><br><span class="line">&#125;</span><br><span class="line">foo(); // global</span><br><span class="line">alert(foo === foo.prototype.constructor); // true</span><br><span class="line">// 但是同一个function的不同的调用表达式，this是不同的</span><br><span class="line">foo.prototype.constructor(); // foo.prototype</span><br></pre></td></tr></table></figure><p>有可能作为一些对象定义的方法来调用函数，但是 this 将不会设置为这个对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var foo = &#123;</span><br><span class="line">  bar: function () &#123;</span><br><span class="line">    alert(this);</span><br><span class="line">    alert(this === foo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">foo.bar(); // foo, true</span><br><span class="line">var exampleFunc = foo.bar;</span><br><span class="line">alert(exampleFunc === foo.bar); // true</span><br><span class="line">// 再一次，同一个 function 的不同的调用表达式，this 是不同的</span><br><span class="line">exampleFunc(); // global, false</span><br></pre></td></tr></table></figure><p>那么，调用函数的方式如何影响 this 值？为了充分理解 this 值的确定，需要详细分析其内部类型之一——引用类型（Reference type）。</p><h2 id="引用类型（Reference-type）"><a href="#引用类型（Reference-type）" class="headerlink" title="引用类型（Reference type）"></a>引用类型（Reference type）</h2><p>使用伪代码我们可以将引用类型的值可以表示为拥有两个属性的对象——base（即拥有属性的那个对象），和 base 中的 propertyName 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var valueOfReferenceType = &#123;</span><br><span class="line">  base: &lt;base object&gt;,</span><br><span class="line">  propertyName: &lt;property name&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>引用类型的值只有两种情况：</p><ol><li>当我们处理一个标示符时</li><li>或一个属性访问器</li></ol><p>标示符的处理过程在下一篇文章里详细讨论，在这里我们只需要知道，在该算法的返回值中，总是一个引用类型的值（这对 this 来说很重要）。</p><p>标识符是变量名，函数名，函数参数名和全局对象中未识别的属性名。例如，下面标识符的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var foo = 10;</span><br><span class="line">function bar() &#123;&#125;</span><br></pre></td></tr></table></figure><p>在操作的中间结果中，引用类型对应的值如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var fooReference = &#123;</span><br><span class="line">  base: global,</span><br><span class="line">  propertyName: &apos;foo&apos;</span><br><span class="line">&#125;;</span><br><span class="line">var barReference = &#123;</span><br><span class="line">  base: global,</span><br><span class="line">  propertyName: &apos;bar&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了从引用类型中得到一个对象真正的值，伪代码中的 GetValue 方法可以做如下描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function GetValue(value) &#123;</span><br><span class="line"></span><br><span class="line">  if (Type(value) != Reference) &#123;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;</span><br><span class="line">  var base = GetBase(value);</span><br><span class="line">  if (base === null) &#123;</span><br><span class="line">    throw new ReferenceError;</span><br><span class="line">  &#125;</span><br><span class="line">  return base.[[Get]](GetPropertyName(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部的[[Get]]方法返回对象属性真正的值，包括对原型链中继承的属性分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GetValue(fooReference); // 10</span><br><span class="line">GetValue(barReference); // function object &quot;bar&quot;</span><br></pre></td></tr></table></figure><p>属性访问器都应该熟悉。它有两种变体：点（.）语法（此时属性名是正确的标示符，且事先知道），或括号语法（[]）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.bar();</span><br><span class="line">foo[&apos;bar&apos;]();</span><br></pre></td></tr></table></figure><p>在中间计算的返回值中，我们有了引用类型的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var fooBarReference = &#123;</span><br><span class="line">  base: foo,</span><br><span class="line">  propertyName: &apos;bar&apos;</span><br><span class="line">&#125;;</span><br><span class="line">GetValue(fooBarReference); // function object &quot;bar&quot;</span><br></pre></td></tr></table></figure><p>引用类型的值与函数上下文中的 this 值如何相关？——从最重要的意义上来说。 这个关联的过程是这篇文章的核心。 一个函数上下文中确定 this 值的通用规则如下：</p><p>在一个函数上下文中， this 由调用者提供，由调用函数的方式来决定。如果调用括号()的左边是引用类型的值，this 将设为引用类型值的 base 对象（base object），在其他情况下（与引用类型不同的任何其它属性），这个值为 null。不过，实际不存在 this 的值为 null 的情况，因为当 this 的值为 null 的时候，其值会被隐式转换为全局对象。<code>*注：第 5 版的 ECMAScript 中，已经不强迫转换成全局变量了，而是赋值为 undefined。*</code></p><p>我们看看这个例子中的表现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line">foo(); // global</span><br></pre></td></tr></table></figure><p>我们看到在调用括号的左边是一个引用类型值（因为 foo 是一个标示符）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var fooReference = &#123;</span><br><span class="line">  base: global,</span><br><span class="line">  propertyName: &apos;foo&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相应地，this 也设置为引用类型的 base 对象。即全局对象。</p><p>同样，使用属性访问器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var foo = &#123;</span><br><span class="line">  bar: function () &#123;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">foo.bar(); // foo</span><br></pre></td></tr></table></figure><p>我们再次拥有一个引用类型，其 base 是 foo 对象，在函数 bar 激活时用作 this。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var fooBarReference = &#123;</span><br><span class="line">  base: foo,</span><br><span class="line">  propertyName: &apos;bar&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是，用另外一种形式激活相同的函数，我们得到其它的 this 值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var test = foo.bar;</span><br><span class="line">test(); // global</span><br></pre></td></tr></table></figure><p>因为 test 作为标示符，生成了引用类型的其他值，其 base（全局对象）用作 this 值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var testReference = &#123;</span><br><span class="line">  base: global,</span><br><span class="line">  propertyName: &apos;test&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，我们可以很明确的告诉你，为什么用表达式的不同形式激活同一个函数会不同的 this 值，答案在于引用类型（type Reference）不同的中间值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  alert(this);</span><br><span class="line">&#125;</span><br><span class="line">foo(); // global, because</span><br><span class="line">var fooReference = &#123;</span><br><span class="line">  base: global,</span><br><span class="line">  propertyName: &apos;foo&apos;</span><br><span class="line">&#125;;</span><br><span class="line">alert(foo === foo.prototype.constructor); // true</span><br><span class="line">// 另外一种形式的调用表达式</span><br><span class="line">foo.prototype.constructor(); // foo.prototype, because</span><br><span class="line">var fooPrototypeConstructorReference = &#123;</span><br><span class="line">  base: foo.prototype,</span><br><span class="line">  propertyName: &apos;constructor&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另外一个通过调用方式动态确定 this 值的经典例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  alert(this.bar);</span><br><span class="line">&#125;</span><br><span class="line">var x = &#123;bar: 10&#125;;</span><br><span class="line">var y = &#123;bar: 20&#125;;</span><br><span class="line">x.test = foo;</span><br><span class="line">y.test = foo;</span><br><span class="line">x.test(); // 10</span><br><span class="line">y.test(); // 20</span><br></pre></td></tr></table></figure><h2 id="函数调用和非引用类型"><a href="#函数调用和非引用类型" class="headerlink" title="函数调用和非引用类型"></a>函数调用和非引用类型</h2><p>因此，正如我们已经指出，当调用括号的左边不是引用类型而是其它类型，这个值自动设置为 null，结果为全局对象。</p><p>让我们再思考这种表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">  alert(this); // null =&gt; global</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>在这个例子中，我们有一个函数对象但不是引用类型的对象（它不是标示符，也不是属性访问器），相应地，this 值最终设为全局对象。</p><p>更多复杂的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var foo = &#123;</span><br><span class="line">  bar: function () &#123;</span><br><span class="line">    alert(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">foo.bar(); // Reference, OK =&gt; foo</span><br><span class="line">(foo.bar)(); // Reference, OK =&gt; foo</span><br><span class="line">(foo.bar = foo.bar)(); // global?</span><br><span class="line">(false || foo.bar)(); // global?</span><br><span class="line">(foo.bar, foo.bar)(); // global?</span><br></pre></td></tr></table></figure><p>为什么我们有一个属性访问器，它的中间值应该为引用类型的值，在某些调用中我们得到的 this 值不是 base 对象，而是 global 对象？</p><p>问题在于后面的三个调用，在应用一定的运算操作之后，在调用括号的左边的值不在是引用类型。</p><ol><li>第一个例子很明显———明显的引用类型，结果是，this 为 base 对象，即 foo。</li><li>在第二个例子中，组运算符并不适用，想想上面提到的，从引用类型中获得一个对象真正的值的方法，如 GetValue。相应的，在组运算的返回中———我们得到仍是一个引用类型。这就是 this 值为什么再次设为 base对象，即 foo。</li><li>第三个例子中，与组运算符不同，赋值运算符调用了 GetValue方法。返回的结果是函数对象（但不是引用类型），这意味着 this 设为 null，结果是 global 对象。</li><li>第四个和第五个也是一样——逗号运算符和逻辑运算符（OR）调用了 GetValue 方法，相应地，我们失去了引用而得到了函数。并再次设为 global。</li></ol><h2 id="引用类型和-this-为-null"><a href="#引用类型和-this-为-null" class="headerlink" title="引用类型和 this 为 null"></a>引用类型和 this 为 null</h2><p>有一种情况是这样的：当调用表达式限定了 call 括号左边的引用类型的值， 尽管 this 被设定为 null，但结果被隐式转化成 global。当引用类型值的 base 对象是被活动对象时，这种情况就会出现。</p><p>下面的实例中，内部函数被父函数调用，此时我们就能够看到上面说的那种特殊情况。正如我们在第 12 章知道的一样，局部变量、内部函数、形式参数储存在给定函数的激活对象中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  function bar() &#123;</span><br><span class="line">    alert(this); // global</span><br><span class="line">  &#125;</span><br><span class="line">  bar(); // the same as AO.bar()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>活动对象总是作为 this 返回，值为 null——（即伪代码的 AO.bar()相当于 null.bar()）。这里我们再次回到上面描述的例子，this 设置为全局对象。</p><p>有一种情况除外：如果 with 对象包含一个函数名属性，在 with 语句的内部块中调用函数。With 语句添加到该对象作用域的最前端，即在活动对象的前面。相应地，也就有了引用类型（通过标示符或属性访问器）， 其 base 对象不再是活动对象，而是 with 语句的对象。顺便提一句，它不仅与内部函数相关，也与全局函数相关，因为 with 对象比作用域链里的最前端的对象(全局对象或一个活动对象)还要靠前。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var x = 10;</span><br><span class="line">with (&#123;</span><br><span class="line">  foo: function () &#123;</span><br><span class="line">    alert(this.x);</span><br><span class="line">  &#125;,</span><br><span class="line">  x: 20</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  foo(); // 20</span><br><span class="line">&#125;</span><br><span class="line">// because</span><br><span class="line">var  fooReference = &#123;</span><br><span class="line">  base: __withObject,</span><br><span class="line">  propertyName: &apos;foo&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样的情况出现在 catch 语句的实际参数中函数调用：在这种情况下，catch 对象添加到作用域的最前端，即在活动对象或全局对象的前面。但是，这个特定的行为被确认为 ECMA-262-3 的一个 bug，这个在新版的 ECMA-262-5 中修复了。这样，在特定的活动对象中，this 指向全局对象。而不是 catch 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  throw function () &#123;</span><br><span class="line">    alert(this);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  e(); // ES3标准里是__catchObject, ES5标准里是global </span><br><span class="line">&#125;</span><br><span class="line">// on idea</span><br><span class="line">var eReference = &#123;</span><br><span class="line">  base: __catchObject,</span><br><span class="line">  propertyName: &apos;e&apos;</span><br><span class="line">&#125;;</span><br><span class="line">// ES5新标准里已经fix了这个bug，</span><br><span class="line">// 所以this就是全局对象了</span><br><span class="line">var eReference = &#123;</span><br><span class="line">  base: global,</span><br><span class="line">  propertyName: &apos;e&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样的情况出现在命名函数（函数的更对细节参考第 15 章 Functions）的递归调用中。在函数的第一次调用中，base 对象是父活动对象（或全局对象），在递归调用中，base 对象应该是存储着函数表达式可选名称的特定对象。但是，在这种情况下，this 总是指向全局对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(function foo(bar) &#123;</span><br><span class="line">  alert(this);</span><br><span class="line">  !bar &amp;&amp; foo(1); // &quot;should&quot; be special object, but always (correct) global</span><br><span class="line">&#125;)(); // global</span><br></pre></td></tr></table></figure><h2 id="作为构造器调用的函数中的-this"><a href="#作为构造器调用的函数中的-this" class="headerlink" title="作为构造器调用的函数中的 this"></a>作为构造器调用的函数中的 this</h2><p>还有一个与 this 值相关的情况是在函数的上下文中，这是一个构造函数的调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function A() &#123;</span><br><span class="line">  alert(this); // &quot;a&quot;对象下创建一个新属性</span><br><span class="line">  this.x = 10;</span><br><span class="line">&#125;</span><br><span class="line">var a = new A();</span><br><span class="line">alert(a.x); // 10</span><br></pre></td></tr></table></figure><p>在这个例子中，new 运算符调用“A”函数的内部的[[Construct]] 方法，接着，在对象创建后，调用内部的[[Call]] 方法。 所有相同的函数“A”都将 this 的值设置为新创建的对象。</p><h2 id="函数调用中手动设置-this"><a href="#函数调用中手动设置-this" class="headerlink" title="函数调用中手动设置 this"></a>函数调用中手动设置 this</h2><p>在函数原型中定义的两个方法（因此所有的函数都可以访问它）允许去手动设置函数调用的 this 值。它们是 .apply 和 .call 方法。他们用接受的第一个参数作为 this 值，this 在调用的作用域中使用。这两个方法的区别很小，对于 .apply，第二个参数必须是数组（或者是类似数组的对象，如 arguments，反过来，.call 能接受任何参数。两个方法必须的参数是第一个——this。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var b = 10;</span><br><span class="line">function a(c) &#123;</span><br><span class="line">  alert(this.b);</span><br><span class="line">  alert(c);</span><br><span class="line">&#125;</span><br><span class="line">a(20); // this === global, this.b == 10, c == 20</span><br><span class="line">a.call(&#123;b: 20&#125;, 30); // this === &#123;b: 20&#125;, this.b == 20, c == 30</span><br><span class="line">a.apply(&#123;b: 30&#125;, [40]) // this === &#123;b: 30&#125;, this.b == 30, c == 40</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在这篇文章中，我们讨论了 ECMAScript 中 this 关键字的特征（对比于 C++ 和 Java，它们的确是特色）。我希望这篇文章有助于你准确的理解 ECMAScript 中 this 关键字如何工作。</p><h2 id="其它参考"><a href="#其它参考" class="headerlink" title="其它参考"></a>其它参考</h2><ol><li><a href="http://bclary.com/2004/11/07/#a-10.1.7" target="_blank" rel="noopener">This</a></li><li><a href="http://bclary.com/2004/11/07/#a-11.1.1" target="_blank" rel="noopener">The this keyword</a></li><li><a href="http://bclary.com/2004/11/07/#a-11.2.2" target="_blank" rel="noopener">The new operator</a></li><li><a href="http://bclary.com/2004/11/07/#a-11.2.3" target="_blank" rel="noopener">Function calls</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这篇文章里，我们将讨论跟执行上下文直接相关的更多细节。讨论的主题就是 this 关键字。实践证明，这个主题很难，在不同执行上下文中 this 的确定经常会发生问题。&lt;/p&gt;
&lt;p&gt;许多程序员习惯的认为，在程序语言中，this 关键字与面向对象程序开发紧密相关，其完全指向由构造器新创建的对象。在 ECMAScript 规范中也是这样实现的，但正如我们将看到那样，在 ECMAScript 中，this 并不限于只用来指向新创建的对象。&lt;/p&gt;
&lt;p&gt;让我们更详细的了解一下，在 ECMAScript 中 this 到底是什么？&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>代码复用模式（推荐篇）</title>
    <link href="http://xuhongbo.com/2016/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript/46%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%8E%A8%E8%8D%90%E7%AF%87%EF%BC%89/"/>
    <id>http://xuhongbo.com/2016/05/29/深入理解javascript/46代码复用模式（推荐篇）/</id>
    <published>2016-05-29T15:12:02.000Z</published>
    <updated>2017-03-02T17:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍的四种代码复用模式都是最佳实践，推荐大家在编程的过程中使用。</p><h2 id="模式-1：原型继承"><a href="#模式-1：原型继承" class="headerlink" title="模式 1：原型继承"></a>模式 1：原型继承</h2><p>原型继承是让父对象作为子对象的原型，从而达到继承的目的：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function object(o) &#123;</span><br><span class="line">    function F() &#123;</span><br><span class="line">    &#125;  </span><br><span class="line">    F.prototype = o;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;    </span><br><span class="line">// 要继承的父对象</span><br><span class="line">var parent = &#123;</span><br><span class="line">    name: &quot;Papa&quot;</span><br><span class="line">&#125;;  </span><br><span class="line">// 新对象</span><br><span class="line">var child = object(parent);  </span><br><span class="line">// 测试</span><br><span class="line">console.log(child.name); // &quot;Papa&quot;  </span><br><span class="line">// 父构造函数</span><br><span class="line">function Person() &#123;</span><br><span class="line">    // an &quot;own&quot; property</span><br><span class="line">    this.name = &quot;Adam&quot;;</span><br><span class="line">&#125;</span><br><span class="line">// 给原型添加新属性</span><br><span class="line">Person.prototype.getName = function () &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;;</span><br><span class="line">// 创建新person</span><br><span class="line">var papa = new Person();</span><br><span class="line">// 继承</span><br><span class="line">var kid = object(papa);</span><br><span class="line">console.log(kid.getName()); // &quot;Adam&quot;  </span><br><span class="line">// 父构造函数</span><br><span class="line">function Person() &#123;</span><br><span class="line">    // an &quot;own&quot; property</span><br><span class="line">    this.name = &quot;Adam&quot;;</span><br><span class="line">&#125;</span><br><span class="line">// 给原型添加新属性</span><br><span class="line">Person.prototype.getName = function () &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;;</span><br><span class="line">// 继承</span><br><span class="line">var kid = object(Person.prototype);</span><br><span class="line">console.log(typeof kid.getName); // &quot;function&quot;,因为是在原型里定义的</span><br><span class="line">console.log(typeof kid.name); // &quot;undefined&quot;, 因为只继承了原型</span><br></pre></td></tr></table></figure></p><p>同时，ECMAScript5 也提供了类似的一个方法叫做 Object.create 用于继承对象，用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 使用新版的ECMAScript 5提供的功能 */</span><br><span class="line">var child = Object.create(parent);  </span><br><span class="line">var child = Object.create(parent, &#123;</span><br><span class="line">    age: &#123; value: 2&#125; // ECMA5 descriptor</span><br><span class="line">&#125;);</span><br><span class="line">console.log(child.hasOwnProperty(&quot;age&quot;)); // true</span><br></pre></td></tr></table></figure><p>而且，也可以更细粒度地在第二个参数上定义属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 首先，定义一个新对象man</span><br><span class="line">var man = Object.create(null);  </span><br><span class="line">// 接着，创建包含属性的配置设置</span><br><span class="line">// 属性设置为可写，可枚举，可配置</span><br><span class="line">var config = &#123;</span><br><span class="line">    writable: true,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">&#125;;  </span><br><span class="line">// 通常使用Object.defineProperty()来添加新属性(ECMAScript5支持）</span><br><span class="line">// 现在，为了方便，我们自定义一个封装函数</span><br><span class="line">var defineProp = function (obj, key, value) &#123;</span><br><span class="line">    config.value = value;</span><br><span class="line">    Object.defineProperty(obj, key, config);</span><br><span class="line">&#125;  </span><br><span class="line">defineProp(man, &apos;car&apos;, &apos;Delorean&apos;);</span><br><span class="line">defineProp(man, &apos;dob&apos;, &apos;1981&apos;);</span><br><span class="line">defineProp(man, &apos;beard&apos;, false);</span><br></pre></td></tr></table></figure><p>所以，继承就这么可以做了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var driver = Object.create( man );</span><br><span class="line">defineProp (driver, &apos;topSpeed&apos;, &apos;100mph&apos;);</span><br><span class="line">driver.topSpeed // 100mph</span><br></pre></td></tr></table></figure><p>但是有个地方需要注意，就是 Object.create(null)创建的对象的原型为 undefined，也就是没有 toString 和 valueOf 方法，所以 alert(man)；的时候会出错，但 alert(man.car)；是没问题的。</p><h2 id="模式-2：复制所有属性进行继承"><a href="#模式-2：复制所有属性进行继承" class="headerlink" title="模式 2：复制所有属性进行继承"></a>模式 2：复制所有属性进行继承</h2><p>这种方式的继承就是将父对象里所有的属性都复制到子对象上，一般子对象可以使用父对象的数据。</p><p>先来看一个浅拷贝的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* 浅拷贝 */</span><br><span class="line">function extend(parent, child) &#123;</span><br><span class="line">    var i;</span><br><span class="line">    child = child || &#123;&#125;;</span><br><span class="line">    for (i in parent) &#123;</span><br><span class="line">        if (parent.hasOwnProperty(i)) &#123;</span><br><span class="line">            child[i] = parent[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return child;</span><br><span class="line">&#125;  </span><br><span class="line">var dad = &#123; name: &quot;Adam&quot; &#125;;</span><br><span class="line">var kid = extend(dad);</span><br><span class="line">console.log(kid.name); // &quot;Adam&quot;  </span><br><span class="line">var dad = &#123;</span><br><span class="line">    counts: [1, 2, 3],</span><br><span class="line">    reads: &#123; paper: true &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var kid = extend(dad);</span><br><span class="line">kid.counts.push(4);</span><br><span class="line">console.log(dad.counts.toString()); // &quot;1,2,3,4&quot;</span><br><span class="line">console.log(dad.reads === kid.reads); // true</span><br></pre></td></tr></table></figure><p>代码的最后一行，你可以发现 dad 和 kid 的 reads 是一样的，也就是他们使用的是同一个引用，这也就是浅拷贝带来的问题。</p><p>我们再来看一下深拷贝：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/* 深拷贝 */</span><br><span class="line">function extendDeep(parent, child) &#123;</span><br><span class="line">    var i,</span><br><span class="line">        toStr = Object.prototype.toString,</span><br><span class="line">        astr = &quot;[object Array]&quot;;  </span><br><span class="line">    child = child || &#123;&#125;;  </span><br><span class="line">    for (i in parent) &#123;</span><br><span class="line">        if (parent.hasOwnProperty(i)) &#123;</span><br><span class="line">            if (typeof parent[i] === &apos;object&apos;) &#123;</span><br><span class="line">                child[i] = (toStr.call(parent[i]) === astr) ? [] : &#123;&#125;;</span><br><span class="line">                extendDeep(parent[i], child[i]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                child[i] = parent[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return child;</span><br><span class="line">&#125;  </span><br><span class="line">var dad = &#123;</span><br><span class="line">    counts: [1, 2, 3],</span><br><span class="line">    reads: &#123; paper: true &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var kid = extendDeep(dad);  </span><br><span class="line">kid.counts.push(4);</span><br><span class="line">console.log(kid.counts.toString()); // &quot;1,2,3,4&quot;</span><br><span class="line">console.log(dad.counts.toString()); // &quot;1,2,3&quot;  </span><br><span class="line">console.log(dad.reads === kid.reads); // false</span><br><span class="line">kid.reads.paper = false;</span><br></pre></td></tr></table></figure><p>深拷贝以后，两个值就不相等了，bingo！</p><h2 id="模式-3：混合（mix-in）"><a href="#模式-3：混合（mix-in）" class="headerlink" title="模式 3：混合（mix-in）"></a>模式 3：混合（mix-in）</h2><p>混入就是将一个对象的一个或多个（或全部）属性（或方法）复制到另外一个对象，我们举一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function mix() &#123;</span><br><span class="line">    var arg, prop, child = &#123;&#125;;</span><br><span class="line">    for (arg = 0; arg &lt; arguments.length; arg += 1) &#123;</span><br><span class="line">        for (prop in arguments[arg]) &#123;</span><br><span class="line">            if (arguments[arg].hasOwnProperty(prop)) &#123;</span><br><span class="line">                child[prop] = arguments[arg][prop];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return child;</span><br><span class="line">&#125;  </span><br><span class="line">var cake = mix(</span><br><span class="line">                &#123; eggs: 2, large: true &#125;,</span><br><span class="line">                &#123; butter: 1, salted: true &#125;,</span><br><span class="line">                &#123; flour: &apos;3 cups&apos; &#125;,</span><br><span class="line">                &#123; sugar: &apos;sure!&apos; &#125;</span><br><span class="line">                );  </span><br><span class="line">console.dir(cake);</span><br></pre></td></tr></table></figure><p>mix 函数将所传入的所有参数的子属性都复制到 child 对象里，以便产生一个新对象。</p><p>那如何我们只想混入部分属性呢？该个如何做？其实我们可以使用多余的参数来定义需要混入的属性，例如 mix（child,parent,method1,method2)这样就可以只将 parent 里的 method1 和 method2 混入到 child 里。上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// Car </span><br><span class="line">var Car = function (settings) &#123;</span><br><span class="line">    this.model = settings.model || &apos;no model provided&apos;;</span><br><span class="line">    this.colour = settings.colour || &apos;no colour provided&apos;;</span><br><span class="line">&#125;;  </span><br><span class="line">// Mixin</span><br><span class="line">var Mixin = function () &#123; &#125;;</span><br><span class="line">Mixin.prototype = &#123;</span><br><span class="line">    driveForward: function () &#123;</span><br><span class="line">        console.log(&apos;drive forward&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    driveBackward: function () &#123;</span><br><span class="line">        console.log(&apos;drive backward&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;  </span><br><span class="line">// 定义的2个参数分别是被混入的对象（reciving）和从哪里混入的对象（giving)</span><br><span class="line">function augment(receivingObj, givingObj) &#123;</span><br><span class="line">    // 如果提供了指定的方法名称的话，也就是参数多余3个</span><br><span class="line">    if (arguments[2]) &#123;</span><br><span class="line">        for (var i = 2, len = arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">            receivingObj.prototype[arguments[i]] = givingObj.prototype[arguments[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果不指定第3个参数，或者更多参数，就混入所有的方法</span><br><span class="line">    else &#123;</span><br><span class="line">        for (var methodName in givingObj.prototype) &#123;</span><br><span class="line">            // 检查receiving对象内部不包含要混入的名字，如何包含就不混入了</span><br><span class="line">            if (!receivingObj.prototype[methodName]) &#123;</span><br><span class="line">                receivingObj.prototype[methodName] = givingObj.prototype[methodName];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line">// 给Car混入属性，但是值混入&apos;driveForward&apos; 和 &apos;driveBackward&apos;*/</span><br><span class="line">augment(Car, Mixin, &apos;driveForward&apos;, &apos;driveBackward&apos;);  </span><br><span class="line">// 创建新对象Car</span><br><span class="line">var vehicle = new Car(&#123; model: &apos;Ford Escort&apos;, colour: &apos;blue&apos; &#125;);  </span><br><span class="line">// 测试是否成功得到混入的方法</span><br><span class="line">vehicle.driveForward();</span><br><span class="line">vehicle.driveBackward();</span><br></pre></td></tr></table></figure><p>该方法使用起来就比较灵活了。</p><h2 id="模式-4：借用方法"><a href="#模式-4：借用方法" class="headerlink" title="模式 4：借用方法"></a>模式 4：借用方法</h2><p>一个对象借用另外一个对象的一个或两个方法，而这两个对象之间不会有什么直接联系。不用多解释，直接用代码解释吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">var one = &#123;</span><br><span class="line">    name: &apos;object&apos;,</span><br><span class="line">    say: function (greet) &#123;</span><br><span class="line">        return greet + &apos;, &apos; + this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;  </span><br><span class="line">// 测试</span><br><span class="line">console.log(one.say(&apos;hi&apos;)); // &quot;hi, object&quot;  </span><br><span class="line">var two = &#123;</span><br><span class="line">    name: &apos;another object&apos;</span><br><span class="line">&#125;;  </span><br><span class="line">console.log(one.say.apply(two, [&apos;hello&apos;])); // &quot;hello, another object&quot;  </span><br><span class="line">// 将say赋值给一个变量，this将指向到全局变量</span><br><span class="line">var say = one.say;</span><br><span class="line">console.log(say(&apos;hoho&apos;)); // &quot;hoho, undefined&quot;  </span><br><span class="line">// 传入一个回调函数callback</span><br><span class="line">var yetanother = &#123;</span><br><span class="line">    name: &apos;Yet another object&apos;,</span><br><span class="line">    method: function (callback) &#123;</span><br><span class="line">        return callback(&apos;Hola&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(yetanother.method(one.say)); // &quot;Holla, undefined&quot;  </span><br><span class="line">function bind(o, m) &#123;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        return m.apply(o, [].slice.call(arguments));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;  </span><br><span class="line">var twosay = bind(two, one.say);</span><br><span class="line">console.log(twosay(&apos;yo&apos;)); // &quot;yo, another object&quot;  </span><br><span class="line">// ECMAScript 5给Function.prototype添加了一个bind()方法，以便很容易使用apply()和call()。  </span><br><span class="line">if (typeof Function.prototype.bind === &apos;undefined&apos;) &#123;</span><br><span class="line">    Function.prototype.bind = function (thisArg) &#123;</span><br><span class="line">        var fn = this,</span><br><span class="line">slice = Array.prototype.slice,</span><br><span class="line">args = slice.call(arguments, 1);</span><br><span class="line">        return function () &#123;</span><br><span class="line">            return fn.apply(thisArg, args.concat(slice.call(arguments)));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;  </span><br><span class="line">var twosay2 = one.say.bind(two);</span><br><span class="line">console.log(twosay2(&apos;Bonjour&apos;)); // &quot;Bonjour, another object&quot;  </span><br><span class="line">var twosay3 = one.say.bind(two, &apos;Enchanté&apos;);</span><br><span class="line">console.log(twosay3()); // &quot;Enchanté, another object&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍的四种代码复用模式都是最佳实践，推荐大家在编程的过程中使用。&lt;/p&gt;
&lt;h2 id=&quot;模式-1：原型继承&quot;&gt;&lt;a href=&quot;#模式-1：原型继承&quot; class=&quot;headerlink&quot; title=&quot;模式 1：原型继承&quot;&gt;&lt;/a&gt;模式 1：原型继承&lt;/h2&gt;&lt;p&gt;原型继承是让父对象作为子对象的原型，从而达到继承的目的：&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式之装饰者模式</title>
    <link href="http://xuhongbo.com/2016/05/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript/29%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xuhongbo.com/2016/05/11/深入理解javascript/29设计模式之装饰者模式/</id>
    <published>2016-05-11T05:03:03.000Z</published>
    <updated>2017-03-02T17:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>装饰者提供比继承更有弹性的替代方案。 装饰者用用于包装同接口的对象，不仅允许你向方法添加行为，而且还可以将方法设置成原始对象调用（例如装饰者的构造函数）。</p><p>装饰者用于通过重载方法的形式添加新功能，该模式可以在被装饰者前面或者后面加上自己的行为以达到特定的目的。<br><a id="more"></a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>那么装饰者模式有什么好处呢？前面说了，装饰者是一种实现继承的替代方案。当脚本运行时，在子类中增加行为会影响原有类所有的实例，而装饰者却不然。取而代之的是它能给不同对象各自添加新行为。如下代码所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//需要装饰的类（函数）</span><br><span class="line">function Macbook() &#123;</span><br><span class="line">    this.cost = function () &#123;</span><br><span class="line">        return 1000;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function Memory(macbook) &#123;</span><br><span class="line">    this.cost = function () &#123;</span><br><span class="line">        return macbook.cost() + 75;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function BlurayDrive(macbook) &#123;</span><br><span class="line">    this.cost = function () &#123;</span><br><span class="line">        return macbook.cost() + 300;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function Insurance(macbook) &#123;</span><br><span class="line">    this.cost = function () &#123;</span><br><span class="line">        return macbook.cost() + 250;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">// 用法</span><br><span class="line">var myMacbook = new Insurance(new BlurayDrive(new Memory(new Macbook())));</span><br><span class="line">console.log(myMacbook.cost());</span><br></pre></td></tr></table></figure><p>下面是另一个实例，当我们在装饰者对象上调用 performTask 时，它不仅具有一些装饰者的行为，同时也调用了下层对象的 performTask 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function ConcreteClass() &#123;</span><br><span class="line">    this.performTask = function () &#123;</span><br><span class="line">        this.preTask();</span><br><span class="line">        console.log(&apos;doing something&apos;);</span><br><span class="line">        this.postTask();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function AbstractDecorator(decorated) &#123;</span><br><span class="line">    this.performTask = function () &#123;</span><br><span class="line">        decorated.performTask();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function ConcreteDecoratorClass(decorated) &#123;</span><br><span class="line">    this.base = AbstractDecorator;</span><br><span class="line">    this.base(decorated);</span><br><span class="line">    decorated.preTask = function () &#123;</span><br><span class="line">        console.log(&apos;pre-calling..&apos;);</span><br><span class="line">    &#125;;</span><br><span class="line">    decorated.postTask = function () &#123;</span><br><span class="line">        console.log(&apos;post-calling..&apos;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var concrete = new ConcreteClass();</span><br><span class="line">var decorator1 = new ConcreteDecoratorClass(concrete);</span><br><span class="line">var decorator2 = new ConcreteDecoratorClass(decorator1);</span><br><span class="line">decorator2.performTask();</span><br></pre></td></tr></table></figure><p>再来一个彻底的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tree = &#123;&#125;;</span><br><span class="line">tree.decorate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Make sure the tree won\'t fall'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">tree.getDecorator = <span class="function"><span class="keyword">function</span> (<span class="params">deco</span>) </span>&#123;</span><br><span class="line">    tree[deco].prototype = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> tree[deco];</span><br><span class="line">&#125;;</span><br><span class="line">tree.RedBalls = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.decorate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.RedBalls.prototype.decorate(); <span class="comment">// 第7步：先执行原型（这时候是Angel了）的decorate方法</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Put on some red balls'</span>); <span class="comment">// 第8步 再输出 red</span></span><br><span class="line">        <span class="comment">// 将这2步作为RedBalls的decorate方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">tree.BlueBalls = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.decorate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.BlueBalls.prototype.decorate(); <span class="comment">// 第1步：先执行原型的decorate方法，也就是tree.decorate()</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Add blue balls'</span>); <span class="comment">// 第2步 再输出blue</span></span><br><span class="line">        <span class="comment">// 将这2步作为BlueBalls的decorate方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">tree.Angel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.decorate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.Angel.prototype.decorate(); <span class="comment">// 第4步：先执行原型（这时候是BlueBalls了）的decorate方法</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'An angel on the top'</span>); <span class="comment">// 第5步 再输出angel</span></span><br><span class="line">        <span class="comment">// 将这2步作为Angel的decorate方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">tree = tree.getDecorator(<span class="string">'BlueBalls'</span>); <span class="comment">// 第3步：将BlueBalls对象赋给tree，这时候父原型里的getDecorator依然可用</span></span><br><span class="line">tree = tree.getDecorator(<span class="string">'Angel'</span>); <span class="comment">// 第6步：将Angel对象赋给tree，这时候父原型的父原型里的getDecorator依然可用</span></span><br><span class="line">tree = tree.getDecorator(<span class="string">'RedBalls'</span>); <span class="comment">// 第9步：将RedBalls对象赋给tree</span></span><br><span class="line">tree.decorate(); <span class="comment">// 第10步：执行RedBalls对象的decorate方法</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>装饰者模式是为已有功能动态地添加更多功能的一种方式，把每个要装饰的功能放在单独的函数里，然后用该函数包装所要装饰的已有函数对象，因此，当需要执行特殊行为的时候，调用代码就可以根据需要有选择地、按顺序地使用装饰功能来包装对象。优点是把类（函数）的核心职责和装饰功能区分开了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;装饰者提供比继承更有弹性的替代方案。 装饰者用用于包装同接口的对象，不仅允许你向方法添加行为，而且还可以将方法设置成原始对象调用（例如装饰者的构造函数）。&lt;/p&gt;
&lt;p&gt;装饰者用于通过重载方法的形式添加新功能，该模式可以在被装饰者前面或者后面加上自己的行为以达到特定的目的。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript 与 DOM（下）</title>
    <link href="http://xuhongbo.com/2016/04/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript/24JavaScript%20%E4%B8%8E%20DOM%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://xuhongbo.com/2016/04/26/深入理解javascript/24JavaScript 与 DOM（下）/</id>
    <published>2016-04-26T14:12:02.000Z</published>
    <updated>2017-03-02T17:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一章我们介绍了 JavaScript 的基本内容和 DOM 对象的各个方面，包括如何访问 node 节点。本章我们将讲解如何通过 DOM 操作元素并且讨论浏览器事件模型。</p><h2 id="操作元素"><a href="#操作元素" class="headerlink" title="操作元素"></a>操作元素</h2><p>上一章节我们提到了 DOM 节点集合或单个节点的访问步骤，每个 DOM 节点都包括一个属性集合，大多数的属性都提供为相应的功能提供了抽象。例如，如果有一个带有 ID 属性 intro 的文本元素，你可以很容易地通过 DOM API 来改变该元素的颜色：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&apos;intro&apos;).style.color = &apos;#FF0000&apos;;</span><br></pre></td></tr></table></figure></p><p>为了理解这个 API 的功能，我们一步一步分开来看就非常容易理解了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myDocument = document;  </span><br><span class="line">var myIntro = myDocument.getElementById(&apos;intro&apos;);  </span><br><span class="line">var myIntroStyles = myIntro.style;  </span><br><span class="line">// 现在，我们可以设置颜色了:  </span><br><span class="line">myIntroStyles.color = &apos;#FF0000&apos;;</span><br></pre></td></tr></table></figure><p>现在，我们有了该文本的 style 对象的引用了，所以我们可以添加其它的 CSS 样式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myIntroStyles.padding = &apos;2px 3px 0 3px&apos;;  </span><br><span class="line">myIntroStyles.backgroundColor = &apos;#FFF&apos;;  </span><br><span class="line">myIntroStyles.marginTop = &apos;20px&apos;;</span><br></pre></td></tr></table></figure><p>这里我们只是要了基本的 CSS 属性名称，唯一区别是 CSS 属性的名称如果带有-的话，就需要去除，比如用 marginTop 代替 margin-top。例如，下面的代码是不工作的，并且会抛出语法错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myIntroStyles.padding-top = &apos;10em&apos;;     </span><br><span class="line">// 产生语法错误：</span><br><span class="line">// 在JavaScript里横线-是减法操作符</span><br><span class="line">// 而且也没有这样的属性名称</span><br></pre></td></tr></table></figure><p>属性可以像数组一样访问，所以利用这个知识我们可以创建一个函数来改变任何给定元素的样式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function changeStyle(elem, property, val) &#123;</span><br><span class="line">    elem.style[property] = val; // 使用[]来访问属性</span><br><span class="line">&#125;</span><br><span class="line">// 使用上述的函数：  </span><br><span class="line">var myIntro = document.getElementById(&apos;intro&apos;); // 获取intro文本对象</span><br><span class="line">changeStyle(myIntro, &apos;color&apos;, &apos;red&apos;);</span><br></pre></td></tr></table></figure><p>这仅仅是个例子，所以该函数也许没什么用，语法上来说，直接用还是会快点，例如（elem.style.color = ‘red’）。除了 style 属性以外，一个节点（或元素）也还有其他很多属性可以操作，如果你使用 Firebug，点击 DOM 选项卡可以看到所有该节点（或元素）的所有属性：</p><p><img src="http://wiki.jikexueyuan.com/project/javascript-depth-understanding/images/15.png" alt="img"></p><p>所有的属性都可以通过点标示符来访问（例如：Element.tabIndex）。不是所有的属性都是原始数据类型（strings，numbers，Booleans 等等），sytle 属性也是一个包含自己属性的对象，很多元素的属性都是只读的，也就是说不能修改他们的值。例如，你不能直接修改一个节点的 parentNode 属性，如果你修改只读属性的时候浏览器会抛出错误：例如，抛出错误“setting a property that has only a getter”，只是我们需要注意的。</p><p>通常 DOM 操作都是改变原始的内容，这里有几种方式来实现这个，最简单的是使用 innerHTML 属性，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myIntro = document.getElementById(&apos;intro&apos;);  </span><br><span class="line">// 替换当前的内容</span><br><span class="line">myIntro.innerHTML = &apos;New content for the &lt;strong&gt;amazing&lt;/strong&gt; paragraph!&apos;;  </span><br><span class="line">// 添加内容到当前的内容里 </span><br><span class="line">myIntro.innerHTML += &apos;... some more content...&apos;;</span><br></pre></td></tr></table></figure><p>唯一的问题是该方法没在规范里定义，而且在 DOM 规范里也没有定义，如果你不反感的话请继续使用，因为它比我们下面要讨论其它的方法快多了。</p><h3 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node 节点"></a>Node 节点</h3><p>通过 DOM API 创建内容的时候需要注意 node 节点的 2 种类型，一种是元素节点，一种是 text 节点，上一章节已经列出了所有的节点类型，这两种需要我们现在特别注意。创建元素可以通过 createElement 方法，而创建 text 节点可以使用 createTextNode，相应代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myIntro = document.getElementById(&apos;intro&apos;);  </span><br><span class="line">// 添加内容</span><br><span class="line">var someText = &apos;This is the text I want to add&apos;;  </span><br><span class="line">var textNode = document.createTextNode(someText);  </span><br><span class="line">myIntro.appendChild(textNode);</span><br></pre></td></tr></table></figure><p>这里我们使用了 appendChild 方法将新 text 节点附件到文本字段，这样做比非标准的 innerHTML 方法显得有点长，但了解这些原理依然很重要，这里有一个使用 DOM 方法的更详细例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var myIntro = document.getElementById(&apos;intro&apos;);  </span><br><span class="line">// 添加新连接到文本节点</span><br><span class="line">// 首先，创建新连接元素</span><br><span class="line">var myNewLink = document.createElement(&apos;a&apos;); // &lt;a/&gt;  </span><br><span class="line">myNewLink.href = &apos;http://google.com&apos;; // &lt;a href=&quot;http://google.com&quot;/&gt;  </span><br><span class="line">myNewLink.appendChild(document.createTextNode(&apos;Visit Google&apos;)); </span><br><span class="line">// &lt;a href=&quot;http://google.com&quot;&gt;Visit Google&lt;/a&gt;  </span><br><span class="line">// 将内容附件到文本节点</span><br><span class="line">myIntro.appendChild(myNewLink);</span><br></pre></td></tr></table></figure><p>另外 DOM 里还有一个 insertBefore 方法用于再节点前面附件内容，通过 insertBefore 和 appendChild 我们可以实现自己的 insertAfter 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// &apos;Target&apos;是DOM里已经存在的元素</span><br><span class="line">// &apos;Bullet&apos;是要插入的新元素</span><br><span class="line">function insertAfter(target, bullet) &#123;  </span><br><span class="line">    target.nextSibling ?  </span><br><span class="line">        target.parentNode.insertBefore(bullet, target.nextSibling)  </span><br><span class="line">        : target.parentNode.appendChild(bullet);  </span><br><span class="line">&#125;  </span><br><span class="line">// 使用了3目表达式:  </span><br><span class="line">// 格式：条件?条件为true时的表达式：条件为false时的表达式</span><br></pre></td></tr></table></figure><p>上面的函数首先检查 target 元素的同级下一个节点是否存在，如果存在就在该节点前面添加 bullet 节点，如果不存在，就说明 target 是最后一个节点了，直接在后面 append 新节点就可以了。DOM API 没有给提供 insertAfter 是因为真的没必要了——我们可以自己创建。</p><p>DOM 操作有很多内容，上面你看到的只是其中一部分。</p><h2 id="Event-事件"><a href="#Event-事件" class="headerlink" title="Event 事件"></a>Event 事件</h2><p>浏览器事件是所有 web 程序的核心，通过这些事件我们定义将要发生的行为，如果在页面里有个按钮，那点击此按钮之前你需要验证表单是否合法，这时候就可以使用 click 事件，下面列出的最标准的事件列表：</p><p>注：正如我们上章所说的，DOM 和 JavaScript 语言是 2 个单独的东西，浏览器事件是 DOM API 的一部分，而不是 JavaScript 的一部分。</p><h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><ol><li>‘mousedown’ – 鼠标设备按下一个元素的时候触发 mousedown 事件。</li><li>‘mouseup’ – 鼠标设备从按下的元素上弹起的时候触发 mouseup 事件。</li><li>‘click’ – 鼠标点击元素的时候触发 click 事件。</li><li>‘dblclick’ – 鼠标双击元素的时候触发 dblclick 事件。</li><li>‘mouseover’ – 鼠标移动到某元素上的时候触发 mouseover 事件。</li><li>‘mouseout’ – 鼠标从某元素离开的时候触发 mouseout 事件。</li><li>‘mousemove’ – 鼠标在某元素上移动但未离开的时候触发 mousemove 事件。</li></ol><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><ol><li>‘keypress’ – 按键按下的时候触发该事件。</li><li>‘keydown’ – 按键按下的时候触发该事件，并且在 keypress 事件之前。</li><li>‘keyup’ – 按键松开的时候触发该事件，在 keydown 和 keypress 事件之后。</li></ol><h3 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h3><ol><li>‘select’ – 文本字段（input, textarea等）的文本被选择的时候触发该事件。</li><li>‘change’ – 控件失去 input 焦点的时候触发该事件（或者值被改变的时候）。</li><li>‘submit’ – 表单提交的时候触发该事件。</li><li>‘reset’ – 表单重置的时候触发该事件。</li><li>‘focus’ – 元素获得焦点的时候触发该事件，通常来自鼠标设备或 Tab 导航。</li><li>‘blur’ – 元素失去焦点的时候触发该事件，通常来自鼠标设备或 Tab 导航。</li></ol><h3 id="其它事件"><a href="#其它事件" class="headerlink" title="其它事件"></a>其它事件</h3><ol><li>‘load’ – 页面加载完毕（包括内容、图片、frame、object）的时候触发该事件。</li><li>‘resize’ – 页面大小改变的时候触发该事件（例如浏览器缩放）。</li><li>‘scroll’ – 页面滚动的时候触发该事件。</li><li>‘unload’ – 从页面或 frame 删除所有内容的时候触发该事件（例如离开一个页面）。</li></ol><p>还有很多各种各样的事件，上面展示的事件是我们在 JavaScript 里最常用的事件，有些事件在跨浏览器方面可能有所不同。还有其它浏览器实现的一些属性事件，例如 Gecko 实现的 DOMContentLoaded 或 DOMMouseScroll 等，Gecko 的详细事件列表请查看这里。</p><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>我们将了事件，但是还没有将到如何将处理函数和事件管理起来，使用这些事件之前，你首先要注册这些事件句柄，然后描述该事件发生的时候该如何处理，下面的例子展示了一个基本的事件注册模型：</p><p>基本事件注册：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- HTML --&gt;  </span><br><span class="line">&lt;button id=&quot;my-button&quot;&gt;Click me!&lt;/button&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// JavaScript:  </span><br><span class="line">var myElement = document.getElementById(&apos;my-button&apos;);</span><br><span class="line">// 事件处理句柄:  </span><br><span class="line">function buttonClick() &#123;</span><br><span class="line">    alert(&apos;You just clicked the button!&apos;);</span><br><span class="line">&#125;</span><br><span class="line">// 注册事件</span><br><span class="line">myElement.onclick = buttonClick;</span><br></pre></td></tr></table></figure><p>使用 document.getElementById 命令，通过 ID=my-button 获取该 button 对象，然后创建一个处理函数，随后将该函数赋值给该 DOM 的 onclick 属性。就这么简单！</p><p>基本事件注册是非常简单的，在事件名称前面添加前缀 on 作为 DOM 的属性就可以使用了，这是事件处理的基本核心，但下面的代码我不推荐使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;return buttonClick()&quot;&gt;Click me!&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>上述 Inline 的事件处理方式不利用页面维护，建议将这些处理函数都封装在单独的 js 文件，原因和CSS样式的一样的。</p><p>高级事件注册：</p><p>别被标题迷惑了，“高级”不意味着好用，实际上上面讨论的基本事件注册是我们大部分时候用的方式，但有一个限制：不能绑定多个处理函数到一个事件上。这也是我们要讲解该小节原因：</p><p>该模型运行你绑定多个处理句柄到一个事件上，也就是说一个事件触发的时候多个函数都可以执行，另外，该模型也可以让你很容易里删除某个已经绑定的句柄。</p><p>严格来说，有 2 种不同的模型：W3C 模型和微软模型，除 IE 之外 W3C 模型支持所有的现代浏览器，而微软模型只支持 IE，使用 W3C 模型的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 格式：target.addEventListener( type, function, useCapture );  </span><br><span class="line">// 例子:  </span><br><span class="line">var myIntro = document.getElementById(&apos;intro&apos;);</span><br><span class="line">myIntro.addEventListener(&apos;click&apos;, introClick, false);</span><br></pre></td></tr></table></figure><p>使用 IE 模型的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 格式: target.attachEvent ( &apos;on&apos; + type, function );  </span><br><span class="line">// 例子:  </span><br><span class="line">var myIntro = document.getElementById(&apos;intro&apos;);</span><br><span class="line">myIntro.attachEvent(&apos;onclick&apos;, introClick);</span><br></pre></td></tr></table></figure><p>introClick 的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function introClick() &#123;  </span><br><span class="line">    alert(&apos;You clicked the paragraph!&apos;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，要做出通用的话，我们可以自定义一个函数以支持跨浏览器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function addEvent(elem, type, fn) &#123;</span><br><span class="line">    if (elem.attachEvent) &#123;</span><br><span class="line">        elem.attachEvent(&apos;on&apos; + type, fn);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (elem.addEventListener) &#123;</span><br><span class="line">        elem.addEventListener(type, fn, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数首先检查 attachEvent 和 addEventListener 属性，谁可以就用谁，这两种类型的模型都支持删除句柄功能，参考下面的 removeEvent 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function removeEvent(elem, type, fn) &#123;</span><br><span class="line">    if (elem.detachEvent) &#123;</span><br><span class="line">        elem.detachEvent(&apos;on&apos; + type, fn);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (elem.removeEventListener) &#123;</span><br><span class="line">        elem.removeEventListener(type, fn, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以这样使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var myIntro = document.getElementById(&apos;intro&apos;);</span><br><span class="line">addEvent(myIntro, &apos;click&apos;, function () &#123;</span><br><span class="line">    alert(&apos;YOU CLICKED ME!!!&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意到我们传入了一个匿名函数作为第三个参数，JavaScript 运行我们定义和执行匿名函数，这种匿名函数特别适合作为参数传递，实际上我们也可以传递有名的函数（代码如下），但是你们函数更容易做。</p><p>如果你只想在第一次 click 的时候触发一个函数，你可以这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 注意：前提是我们已经定于好了addEvent/removeEvent函数</span><br><span class="line">// (定义好了才能使用哦)  </span><br><span class="line">var myIntro = document.getElementById(&apos;intro&apos;);</span><br><span class="line">addEvent(myIntro, &apos;click&apos;, oneClickOnly);</span><br><span class="line">function oneClickOnly() &#123;</span><br><span class="line">    alert(&apos;WOW!&apos;);</span><br><span class="line">    removeEvent(myIntro, &apos;click&apos;, oneClickOnly);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当第一次触发以后，我们就立即删除该句柄，但是有匿名函数的话却很难将自身的引用删除，不过实际上可以通过如下的形式来做（只不过有点麻烦）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addEvent(myIntro, &apos;click&apos;, function () &#123;</span><br><span class="line">    alert(&apos;WOW!&apos;);</span><br><span class="line">    removeEvent(myIntro, &apos;click&apos;, arguments.callee);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里我们是有了 arguments 对象的 callee 属性，arguments 对象包含了所有传递进来的参数以及该函数自身(callee)，这样我们就可以放心地删除自身的引用了。</p><p>关于 W3C 和微软模型还有其他的少许差异，比如 this，在触发事件的时候函数中的 this 一般都是该元素上下文，，也就说 this 引用该元素自身，在基本事件注册和 W3C 模型中都没有问题，但在微软模型的实现里却可能出错，请参考如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function myEventHandler() &#123;</span><br><span class="line">    this.style.display = &apos;none&apos;;</span><br><span class="line">&#125;</span><br><span class="line">// 正常工作，this是代表该元素</span><br><span class="line">myIntro.onclick = myEventHandler;</span><br><span class="line">// 正常工作，this是代表该元素</span><br><span class="line">myIntro.addEventListener(&apos;click&apos;, myEventHandler, false);</span><br><span class="line">// 不正常，这时候的this是代表Window对象</span><br><span class="line">myIntro.attachEvent(&apos;onclick&apos;, myEventHandler);</span><br></pre></td></tr></table></figure><p>这里有一些方式可以避免这个问题，最简单的方式是使用前面的基本事件注册方式，或者是再做一个通用的 addEvent，通用代码请参考 <a href="http://ejohn.org/apps/jselect/event.html" target="_blank" rel="noopener">John Resig</a> 或 <a href="http://dean.edwards.name/weblog/2005/10/add-event2/" target="_blank" rel="noopener">Dean Edward</a> 的文章。</p><h2 id="Event-对象"><a href="#Event-对象" class="headerlink" title="Event 对象"></a>Event 对象</h2><p>另外一个非常重要的内容是 Event 对象，当事件发生的时候出发某个函数，该 Event 对象将自动在函数内可用，该对象包含了很多事件触发时候的信息，但IE却没有这么实现，而是自己实现的，IE 浏览器是通过全局对象 window 下的 event 属性来包含这些信息，虽然不是大问题，但我们也需要注意一下，下面的代码是兼容性的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function myEventHandler(e) &#123;</span><br><span class="line">    // 注意参数e</span><br><span class="line">    // 该函数调用的时候e是event对象（W3C实现）</span><br><span class="line">    // 兼容IE的代码</span><br><span class="line">    e = e || window.event;</span><br><span class="line">    // 现在e就可以兼容各种浏览器了</span><br><span class="line">&#125;</span><br><span class="line">// 这里可以自由地绑定事件了</span><br></pre></td></tr></table></figure><p>这里判断 e 对象（Event 对象）是否存在我们使用了 OR 操作符：如果 e 不存在（为 null，undefined，0 等）的时候，将 window.event 赋值给 e，否则的话继续使用 e。通过这方式很快就能在多浏览器里得到真正的 Event 对象，如果你不喜欢这种方式的话，你可以使用 if 语句来处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!e) &#123;</span><br><span class="line">    e = window.event;</span><br><span class="line">&#125; // 没有else语句，因为e在其它浏览器已经定义了</span><br></pre></td></tr></table></figure><p>另外 Event 对象下的命令和属性都很有用，遗憾的是不不能全兼容浏览器，例如当你想取消默认的行为的时候你可以使用 Event 对象里的 preventDefault()方法，但 IE 里不得不使用对象的 returnValue 属性值来控制，兼容代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function myEventHandler(e) &#123;</span><br><span class="line">    e = e || window.event;</span><br><span class="line">    // 防止默认行为</span><br><span class="line">    if (e.preventDefault) &#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        e.returnValue = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，当你点击一个连接的时候，默认行为是导航到 href 里定义的地址，但有时候你想禁用这个默认行为，通过 returnValue 和 preventDefault 就可以实现，Event 对象里的很多属性在浏览器里都不兼容，所以很多时候需要处理这些兼容性代码。</p><p>注意：现在很多 JS 类库都已经封装好了 e.preventDefault 代码，也就是说在 IE 里可用了，但是原理上依然是使用 returnValue 来实现的。</p><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>事件冒泡，就是事件触发的时候通过 DOM 向上冒泡，首先要知道不是所有的事件都有冒泡。事件在一个目标元素上触发的时候，该事件将触发一一触发祖先节点元素，直到最顶层的元素：</p><p><img src="http://wiki.jikexueyuan.com/project/javascript-depth-understanding/images/16.png" alt="img"></p><p>如图所示，如果 a 连接被点击，触发触发连接的 click 事件，然后触发 p 的 click 事件，以此再触发 div 和 body 的 click 事件。顺序不变，而且不一定是在同时触发的。</p><p>这样你就可以利用该特性去处理自己的逻辑了，并且再任何时候都可以停止冒泡，比如，如果你只想冒泡到文本节点上，而不再进一步冒泡，你可以在 p 的 click 事件处理函数里丁停止冒泡：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function myParagraphEventHandler(e) &#123;</span><br><span class="line">    e = e || window.event;</span><br><span class="line">    // 停止向上冒泡</span><br><span class="line">    if (e.stopPropagation) &#123;</span><br><span class="line">        // W3C实现  </span><br><span class="line">        e.stopPropagation();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // IE实现  </span><br><span class="line">        e.cancelBubble = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 使用我们自定义的addEvent函数将myParagraphEventHandler绑定到click事件上：  </span><br><span class="line">addEvent(document.getElementsByTagName(&apos;p&apos;)[0], &apos;click&apos;, myParagraphEventHandler);</span><br></pre></td></tr></table></figure><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>举例来说，如果你有一个很多行的大表格，在每个  上绑定点击事件是个非常危险的想法，因为性能是个大问题。流行的做法是使用事件委托。事件委托描述的是将事件绑定在容器元素上，然后通过判断点击的 target 子元素的类型来触发相应的事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var myTable = document.getElementById(&apos;my-table&apos;);</span><br><span class="line">myTable.onclick = function () &#123;</span><br><span class="line">    // 处理浏览器兼容</span><br><span class="line">    e = e || window.event;</span><br><span class="line">    var targetNode = e.target || e.srcElement;</span><br><span class="line">    // 测试如果点击的是TR就触发</span><br><span class="line">    if (targetNode.nodeName.toLowerCase() === &apos;tr&apos;) &#123;</span><br><span class="line">        alert(&apos;You clicked a table row!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件委托依赖于事件冒泡，如果事件冒泡到 table 之前被禁用的话，那上面的代码就无法工作了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章我们覆盖到了 DOM 元素的操作以及相关的浏览器事件模型，希望大家能对 DOM 有了进一步的了解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章我们介绍了 JavaScript 的基本内容和 DOM 对象的各个方面，包括如何访问 node 节点。本章我们将讲解如何通过 DOM 操作元素并且讨论浏览器事件模型。&lt;/p&gt;
&lt;h2 id=&quot;操作元素&quot;&gt;&lt;a href=&quot;#操作元素&quot; class=&quot;headerlink&quot; title=&quot;操作元素&quot;&gt;&lt;/a&gt;操作元素&lt;/h2&gt;&lt;p&gt;上一章节我们提到了 DOM 节点集合或单个节点的访问步骤，每个 DOM 节点都包括一个属性集合，大多数的属性都提供为相应的功能提供了抽象。例如，如果有一个带有 ID 属性 intro 的文本元素，你可以很容易地通过 DOM API 来改变该元素的颜色：&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript 与 DOM（上）——也适用于新手</title>
    <link href="http://xuhongbo.com/2016/04/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript/23JavaScript%20%E4%B8%8E%20DOM%EF%BC%88%E4%B8%8A%EF%BC%89%E2%80%94%E2%80%94%E4%B9%9F%E9%80%82%E7%94%A8%E4%BA%8E%E6%96%B0%E6%89%8B/"/>
    <id>http://xuhongbo.com/2016/04/25/深入理解javascript/23JavaScript 与 DOM（上）——也适用于新手/</id>
    <published>2016-04-25T12:02:02.000Z</published>
    <updated>2017-03-02T17:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文档对象模型-Document-Object-Model"><a href="#文档对象模型-Document-Object-Model" class="headerlink" title="文档对象模型 Document Object Model"></a>文档对象模型 Document Object Model</h2><p>DOM（Document Object Model，文档对象模型）是一个通过和 JavaScript 进行内容交互的 API。Javascript 和 DOM 一般经常作为一个整体，因为 Javascript 通常都是用来进行 DOM 操作和交互的。<br><a id="more"></a><br><img src="http://wiki.jikexueyuan.com/project/javascript-depth-understanding/images/12.png" alt="img"></p><p>关于DOM，有些知识需要注意：</p><ol><li>window 对象作为全局对象，也就是说你可以通过 window 来访问全局对象。<ol><li>属性在对象下面以变量的形式存放，在页面上创建的所有全局对象都会变成 window 对象的属性。</li><li>方法在对象下面以函数的形式存放，因为左右的函数都存放在 window 对象下面，所以他们也可以称为方法。</li></ol></li><li>DOM 为 web 文档创建带有层级的结果，这些层级是通过 node 节点组成，这里有几种 DOM node 类型，最重要的是 Element，Text，Document。<ol><li>Element 节点在页面里展示的是一个元素，所以如果你有段落元素(<code></code>)，你可以通过这个 DOM 节点来访问。</li><li>Text 节点在页面里展示的所有文本相关的元素，所以如果你的段落有文本在里面的话，你可以直接通过 DOM 的 Text 节点来访问这个文本</li><li>Document 节点代表是整个文档，它是 DOM 的根节点。</li></ol></li><li>每个引擎对 DOM 标准的实现有一些轻微的不同。例如，Firefox 浏览器使用的 Gecko 引擎有着很好的实现（尽管没有完全遵守 W3C 规范），但 IE 浏览器使用的 Trident 引擎的实现却不完整而且还有 bug，给开发人言带来了很多问题。</li></ol><p><code>如果你正在使用 Firefox，我推荐你立即下载 Firebug 插件，对于你了解 DOM 结构非常有用。</code></p><h2 id="Web-上的-JavaScript"><a href="#Web-上的-JavaScript" class="headerlink" title="Web 上的 JavaScript"></a>Web 上的 JavaScript</h2><h3 id="Script-元素"><a href="#Script-元素" class="headerlink" title="Script 元素"></a>Script 元素</h3><p>当你在网站页面上使用 JavaScript 的时候，需要使用 <code></code> 元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;  </span><br><span class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;  </span><br><span class="line">    &lt;head&gt;  </span><br><span class="line">            &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;  </span><br><span class="line">            &lt;title&gt;JavaScript!&lt;/title&gt;  </span><br><span class="line">    &lt;/head&gt;  </span><br><span class="line">    &lt;body&gt;        </span><br><span class="line">        &lt;script type=&quot;text/javascript&quot;&gt;  </span><br><span class="line">        // &lt;![CDATA[     </span><br><span class="line">        // ]]&gt;  </span><br><span class="line">        &lt;/script&gt;        </span><br><span class="line">    &lt;/body&gt;  </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>上述代码，严格来说 SCRIPT 的 TYPE 属性应该设置为 application/javascript，但是由于 IE 不支持这个，所以平时我们不得不写成 text/javascript 或者直接去掉 type。另外你也可以看到在 SCRIPT 元素里的注释行// &lt;![CDATA[ 是用来告诉支持 XHTML 的浏览器，这里面的代码是字符数据而不是 XHTML 标签，比如如果你在里面的数据使用了 &lt; 或 &gt;，浏览器就不会再解析成 XHTML 标签了。</p><h3 id="Defer属性"><a href="#Defer属性" class="headerlink" title="Defer属性"></a>Defer属性</h3><p>任何在 SCRIPT 元素里声明的代码在页面加载的时候都会运行，唯一一个例外是给 SCRIPT 元素加上一个 defer 属性。defer 属性告诉浏览器加载完HTML文档以后再执行 JS 代码，但这个属性只能在 IE 下使用。</p><h3 id="连接外部脚本"><a href="#连接外部脚本" class="headerlink" title="连接外部脚本"></a>连接外部脚本</h3><p>如果你想了解外部脚本，只需要简单地在 SCRIPT 上使用 SRC 属性就行了，使用单独的 JS 文件的好处是可以缓存，而且也不需要担心 CDATA 方面的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;my-script.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="JavaScript-必备"><a href="#JavaScript-必备" class="headerlink" title="JavaScript 必备"></a>JavaScript 必备</h3><p>在我们继续 DOM 之前，我们来复习一下 JavaScript 的核心必备知识，如果你还不了解，也没关系，我们在这一章节将稍微花点时间来回顾一下。</p><p>JavaScript 有几种数据类型：Number，String，Boolean，Object，Undefined and Null。</p><p>单行注释使用双斜杠//，双斜杠后面的所有文字都会被注释掉，多行注意使用<code>/*</code>和<code>*/</code>括住。</p><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>在 JavaScript 里所有的 Number 都是浮点型的，当声明一个数字变量的时候，记得不要使用任何引号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 注：使用var类声明变量</span><br><span class="line">var leftSide = 100;  </span><br><span class="line">var topSide = 50;  </span><br><span class="line">var areaOfRectangle = leftSide * topSide; // = 5000  </span><br><span class="line">String</span><br></pre></td></tr></table></figure><p>JavaScript 里声明字符串特别简单，和其它语言一样，在 JS 里使用单引号或双引号都可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var firstPart = &apos;Hello&apos;;  </span><br><span class="line">var secondPart = &apos;World!&apos;;  </span><br><span class="line">var allOfIt = firstPart + &apos; &apos; + secondPart; // Hello World!  </span><br><span class="line">// +符合是字符连接符。也用于数字相加</span><br></pre></td></tr></table></figure><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>布尔类型用于条件判断，布尔类型是只有 2 个值：true 和 false。任何使用逻辑操作符的比较都会返回布尔值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5 === (3 + 2); // = true  </span><br><span class="line">// 你也可以将布尔值赋给一个变量</span><br><span class="line">var veryTired = true;</span><br><span class="line">// 这样使用</span><br><span class="line">if (veryTired) &#123;</span><br><span class="line">    // 执行代码 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>===也是比较操作符，不仅比较数值，还比较类型。</p><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p>函数是特殊的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 使用function操作符来声明新函数  </span><br><span class="line">function myFunctionName(arg1, arg2) &#123;</span><br><span class="line">    // 函数代码</span><br><span class="line">&#125;</span><br><span class="line">// 你也可以声明匿名函数 </span><br><span class="line">function (arg1, arg2) &#123;</span><br><span class="line">    // Function code goes here.  </span><br><span class="line">&#125;</span><br><span class="line">// 运行函数很简单，直接在函数名称后面加上小括号就可以了</span><br><span class="line">// 或者也可以带上参数</span><br><span class="line">myFunctionName(); // 无参</span><br><span class="line">myFunctionName(&apos;foo&apos;, &apos;bar&apos;); // 有参数</span><br><span class="line">// 也可以使用自调用  </span><br><span class="line">(function () &#123;</span><br><span class="line">    // 这里自调用函数</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>数组也是特殊的对象，它包含了一批值（或对象），访问这些数据的话需要使用数字索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 2种方式声明数组</span><br><span class="line">// 字面量:  </span><br><span class="line">var fruit = [&apos;apple&apos;, &apos;lemon&apos;, &apos;banana&apos;];</span><br><span class="line">// Array构造函数:  </span><br><span class="line">var fruit = new Array(&apos;apple&apos;, &apos;lemon&apos;, &apos;banana&apos;);</span><br><span class="line">fruit[0]; // 访问第1个项(apple)  </span><br><span class="line">fruit[1]; // 访问第2个项(lemon)  </span><br><span class="line">fruit[2]; // 访问第3个项(banana) </span><br><span class="line">Object</span><br></pre></td></tr></table></figure><p>一个对象是一个 key-value 的集合，和数组相似，唯一的不同是你可以为每个数据定义一个名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 2种类型定义Object对象</span><br><span class="line">// 字面量（大括号）</span><br><span class="line">var profile = &#123;</span><br><span class="line">    name: &apos;Bob&apos;,</span><br><span class="line">    age: 99,</span><br><span class="line">    job: &apos;Freelance Hitman&apos;</span><br><span class="line">&#125;;</span><br><span class="line">// 使用Object构造函数</span><br><span class="line">var profile = new Object();</span><br><span class="line">profile.name = &apos;Bob&apos;;</span><br><span class="line">profile.age = 99;</span><br><span class="line">profile.job = &apos;Freelance Hitman&apos;;</span><br></pre></td></tr></table></figure><h3 id="IF-Else-语句"><a href="#IF-Else-语句" class="headerlink" title="IF/Else 语句"></a>IF/Else 语句</h3><p>JS 里使用最多的语句莫过于条件语句了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var legalDrinkingAge = 21;  </span><br><span class="line">var yourAge = 29;  </span><br><span class="line">if ( yourAge &gt;= legalDrinkingAge ) &#123;   </span><br><span class="line">    alert(&apos;You can drink.&apos;);  </span><br><span class="line">&#125; else &#123;  </span><br><span class="line">    alert(&apos;Sorry, you cannot drink.&apos;);</span><br></pre></td></tr></table></figure><h3 id="JavaScript-操作符"><a href="#JavaScript-操作符" class="headerlink" title="JavaScript 操作符"></a>JavaScript 操作符</h3><p>建议你访问这个页面来查看所有的 JS 操作符，这里我仅仅给出一些例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 加减乘除</span><br><span class="line">var someMaths = 2 + 3 + 4 - 10 * 100 / 2;     </span><br><span class="line">// 等于  </span><br><span class="line">if ( 2 == (5 - 3 ) &#123; /* 代码 */ &#125; // == 比较是否相等</span><br><span class="line">// 不等于 </span><br><span class="line">if ( 2 != (5 - 3 ) &#123; /* 代码 */ &#125;   </span><br><span class="line">// 严格等于（推荐） </span><br><span class="line">2 === 2 // 代替 2 == 2  </span><br><span class="line">2 !== 3 // 代替 2 != 3  </span><br><span class="line">// 赋值:  </span><br><span class="line">var numberOfFruit = 9;  </span><br><span class="line">numberOfFruit -= 2; // 等价于 &quot;numberOfFruit = numberOfFruit - 2&quot;  </span><br><span class="line">numberOfFruit += 2; // 等价于 &quot;numberOfFruit = numberOfFruit + 2&quot;</span><br></pre></td></tr></table></figure><h3 id="Loop循环"><a href="#Loop循环" class="headerlink" title="Loop循环"></a>Loop循环</h3><p>Loop 循环在是遍历数组或者对象的所有成员的时候非常方便，JavaScript 里使用最多的是 FOR 和 WHILE 语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var envatoTutSites = [&apos;NETTUTS&apos;, &apos;PSDTUTS&apos;, &apos;AUDIOTUTS&apos;, &apos;AETUTS&apos;, &apos;VECTORTUTS&apos;];</span><br><span class="line">// WHILE循环</span><br><span class="line">var counter = 0;</span><br><span class="line">var lengthOfArray = envatoTutSites.length;</span><br><span class="line">while (counter &lt; lengthOfArray) &#123;</span><br><span class="line">    alert(envatoTutSites[counter]);</span><br><span class="line">    counter++; // 等价于counter += 1;  </span><br><span class="line">&#125;</span><br><span class="line">// FOR循环</span><br><span class="line">// i只是用于迭代，可以任意取名 </span><br><span class="line">for (var i = 0, length = envatoTutSites.length; i &lt; length; i++) &#123;</span><br><span class="line">    alert(envatoTutSites[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DOM-正文"><a href="#DOM-正文" class="headerlink" title="DOM 正文"></a>DOM 正文</h2><h3 id="访问-DOM-节点"><a href="#访问-DOM-节点" class="headerlink" title="访问 DOM 节点"></a>访问 DOM 节点</h3><p>我们来个例子，一个 HTML 里包含一段文本和一个无序的列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;  </span><br><span class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;  </span><br><span class="line">    &lt;head&gt;  </span><br><span class="line">            &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;  </span><br><span class="line">            &lt;title&gt;JavaScript!&lt;/title&gt;  </span><br><span class="line">    &lt;/head&gt;  </span><br><span class="line">    &lt;body&gt;  </span><br><span class="line">        &lt;p id=&quot;intro&quot;&gt;My first paragraph...&lt;/p&gt;  </span><br><span class="line">        &lt;ul&gt;  </span><br><span class="line">            &lt;li&gt;List item 1&lt;/li&gt;  </span><br><span class="line">            &lt;li&gt;List item 1&lt;/li&gt;  </span><br><span class="line">            &lt;li&gt;List item 1&lt;/li&gt;  </span><br><span class="line">            &lt;li&gt;List item 1&lt;/li&gt;  </span><br><span class="line">            &lt;li&gt;List item 1&lt;/li&gt;  </span><br><span class="line">        &lt;/ul&gt;  </span><br><span class="line">        &lt;script type=&quot;text/javascript&quot;&gt;  </span><br><span class="line">        // &lt;![CDATA[  </span><br><span class="line">        // ]]&gt;  </span><br><span class="line">&lt;/script&gt;  </span><br><span class="line">    &lt;/body&gt;  </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>上面例子里，我们使用 getElementById DOM 方法来访问 p 段落，在 SCRIPT 里添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var introParagraph = document.getElementById(&apos;intro&apos;);  </span><br><span class="line">// 现在有了该DOM节点，这个DOM节点展示的是该信息段落</span><br></pre></td></tr></table></figure><p>变量 introParagraph 现在已经引用到该 DOM 节点上了，我们可以对该节点做很多事情，比如查询内容和属性，或者其它任何操作，甚至可以删除它，克隆它，或者将它移到到 DOM 树的其它节点上。</p><p>文档上的任何内容，我们都可以使用 JavaScript 和 DOM API 来访问，所以类似地，我们也可以访问上面的无序列表，唯一的问题是该元素没有 ID 属性，如果 ID 的话就可以使用相同的方式，或者使用如下 getElementsByTagName 方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var allUnorderedLists = document.getElementsByTagName(&apos;ul&apos;);  </span><br><span class="line">// &apos;getElementsByTagName&apos;返回的是一个节点集合</span><br><span class="line">// - 和数组有点相似</span><br></pre></td></tr></table></figure><h3 id="getElementsByTagName"><a href="#getElementsByTagName" class="headerlink" title="getElementsByTagName"></a>getElementsByTagName</h3><p>getElementsByTagName 方法返回的是一个节点集合，和数组类似也有 length 属性，重要的一个特性是他是 live 的——如果你在该元素里添加一个新的 li 元素，这个集合就会自动更新，介于他和数组类型，所以可以和访问数组一样的方法来访问，所以从 0 开始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 访问无序列表: [0]索引</span><br><span class="line">var unorderedList = document.getElementsByTagName(&apos;ul&apos;)[0];</span><br><span class="line">// 获取所有的li集合:  </span><br><span class="line">var allListItems = unorderedList.getElementsByTagName(&apos;li&apos;);</span><br><span class="line">// 循环遍历</span><br><span class="line">for (var i = 0, length = allListItems.length; i &lt; length; i++) &#123;</span><br><span class="line">    // 弹出该节点的text内容</span><br><span class="line">    alert(allListItems[i].firstChild.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下图例更清晰地展示了 DOM 获取的知识：</p><p><img src="http://wiki.jikexueyuan.com/project/javascript-depth-understanding/images/13.png" alt="img"></p><h3 id="DOM-穿梭"><a href="#DOM-穿梭" class="headerlink" title="DOM 穿梭"></a>DOM 穿梭</h3><p>“穿梭”这个词主要是用来描述通过 DOM 查找节点，DOM API 提供了大量的节点属性让我们来往上或者往下查询节点。</p><p>所有的节点都有这些属性，都是可以用于访问相关的 node 节点：</p><ol><li>Node.childNodes: 访问一个单元素下所有的直接子节点元素，可以是一个可循环的类数组对象。该节点集合可以保护不同的类型的子节点（比如 text 节点或其他元素节点）。</li><li>Node.firstChild: 与‘childNodes’数组的第一个项(‘Element.childNodes[0]‘)是同样的效果，仅仅是快捷方式。</li><li>Node.lastChild: 与‘childNodes’数组的最后一个项(‘Element.childNodes[Element.childNodes.length-1]‘)是同样的效果，仅仅是快捷方式。shortcut。</li><li>Node.parentNode: 访问当前节点的父节点，父节点只能有一个，祖节点可以用‘Node.parentNode.parentNode’的形式来访问。</li><li>Node.nextSibling: 访问 DOM 树上与当前节点同级别的下一个节点。</li><li>Node.previousSibling: 访问 DOM 树上与当前节点同级别的上一个节点。</li></ol><p><img src="http://wiki.jikexueyuan.com/project/javascript-depth-understanding/images/14.png" alt="img"></p><p>通过这张图，理解起来就简单多了，但有个非常重要的知识点：那就是元素之间不能有空格，如果 ul 和 li 之间有空格的话，就会被认为是内容为空的 text node 节点，这样 ul.childNodes[0]就不是第一个 li 元素了。相应地，</p><p>的下一个节点也不是<ul>，因为<p>和<ul>之间有一个空行的节点，一般遇到这种情况需要遍历所有的子节点然后判断 nodeType 类型，1 是元素，2 是属性，3 是 text 节点，详细的 type 类型可以通过此地址：</ul></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Node.ELEMENT_NODE == 1</span><br><span class="line">Node.ATTRIBUTE_NODE == 2</span><br><span class="line">Node.TEXT_NODE == 3</span><br><span class="line">Node.CDATA_SECTION_NODE == 4</span><br><span class="line">Node.ENTITY_REFERENCE_NODE == 5</span><br><span class="line">Node.ENTITY_NODE == 6</span><br><span class="line">Node.PROCESSING_INSTRUCTION_NODE == 7</span><br><span class="line">Node.COMMENT_NODE == 8</span><br><span class="line">Node.DOCUMENT_NODE == 9</span><br><span class="line">Node.DOCUMENT_TYPE_NODE == 10</span><br><span class="line">Node.DOCUMENT_FRAGMENT_NODE == 11</span><br><span class="line">Node.NOTATION_NODE == 12</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>原生的 DOM 方法和属性足够我们日常的应用了，本章节我们只列举了一些例子，下一章节我们列举更多的例子，还会包括浏览器事件模型。</p></ul></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文档对象模型-Document-Object-Model&quot;&gt;&lt;a href=&quot;#文档对象模型-Document-Object-Model&quot; class=&quot;headerlink&quot; title=&quot;文档对象模型 Document Object Model&quot;&gt;&lt;/a&gt;文档对象模型 Document Object Model&lt;/h2&gt;&lt;p&gt;DOM（Document Object Model，文档对象模型）是一个通过和 JavaScript 进行内容交互的 API。Javascript 和 DOM 一般经常作为一个整体，因为 Javascript 通常都是用来进行 DOM 操作和交互的。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式之建造者模式</title>
    <link href="http://xuhongbo.com/2016/04/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript/27%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xuhongbo.com/2016/04/13/深入理解javascript/27设计模式之建造者模式/</id>
    <published>2016-04-13T04:31:02.000Z</published>
    <updated>2017-03-02T17:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。<br><a id="more"></a><br>建造者模式可以将一个复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。也就是说如果我们用了建造者模式，那么用户就需要指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不需要知道了。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这个模式相对来说比较简单，先上代码，然后再解释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function getBeerById(id, callback) &#123;</span><br><span class="line">    // 使用ID来请求数据，然后返回数据.</span><br><span class="line">    asyncRequest(&apos;GET&apos;, &apos;beer.uri?id=&apos; + id, function (resp) &#123;</span><br><span class="line">        // callback调用 response</span><br><span class="line">        callback(resp.responseText);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">var el = document.querySelector(&apos;#test&apos;);</span><br><span class="line">el.addEventListener(&apos;click&apos;, getBeerByIdBridge, false);</span><br><span class="line">function getBeerByIdBridge(e) &#123;</span><br><span class="line">    getBeerById(this.id, function (beer) &#123;</span><br><span class="line">        console.log(&apos;Requested Beer: &apos; + beer);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据建造者的定义，表相即是回调，也就是说获取数据以后如何显示和处理取决于回调函数，相应地回调函数在处理数据的时候不需要关注是如何获取数据的，同样的例子也可以在 jquery 的 ajax 方法里看到，有很多回调函数（比如 success，error 回调等），主要目的就是职责分离。</p><p>同样再来一个 jQuery 的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;&lt;div class= &quot;foo&quot;&gt; bar &lt;/div&gt;&apos;);</span><br></pre></td></tr></table></figure><p>我们只需要传入要生成的 HTML 字符，而不需要关系具体的 HTML 对象是如何生产的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>建造者模式主要用于“分步骤构建一个复杂的对象”，在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化，其优点是：建造者模式的“加工工艺”是暴露的，这样使得建造者模式更加灵活，并且建造者模式解耦了组装过程和创建具体部件，使得我们不用去关心每个部件是如何组装的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法确相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？这就是要说的建造者模式。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式之工厂模式</title>
    <link href="http://xuhongbo.com/2016/04/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript/28%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xuhongbo.com/2016/04/12/深入理解javascript/28设计模式之工厂模式/</id>
    <published>2016-04-12T06:02:02.000Z</published>
    <updated>2017-03-02T17:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>与创建型模式类似，工厂模式创建对象（视为工厂里的产品）时无需指定创建对象的具体类。</p><p>工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。</p><p>这个模式十分有用，尤其是创建对象的流程赋值的时候，比如依赖于很多设置文件等。并且，你会经常在程序里看到工厂方法，用于让子类类定义需要创建的对象类型。<br><a id="more"></a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>下面这个例子中，是应用了工厂方法对第 26 章构造函数模式代码的改进版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var Car = (function () &#123;</span><br><span class="line">    var Car = function (model, year, miles) &#123;</span><br><span class="line">        this.model = model;</span><br><span class="line">        this.year = year;</span><br><span class="line">        this.miles = miles;</span><br><span class="line">    &#125;;</span><br><span class="line">    return function (model, year, miles) &#123;</span><br><span class="line">        return new Car(model, year, miles);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">var tom = new Car(&quot;Tom&quot;, 2009, 20000);</span><br><span class="line">var dudu = new Car(&quot;Dudu&quot;, 2010, 5000);</span><br></pre></td></tr></table></figure><p>不好理解的话，我们再给一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var productManager = &#123;&#125;;</span><br><span class="line">productManager.createProductA = function () &#123;</span><br><span class="line">    console.log(&apos;ProductA&apos;);</span><br><span class="line">&#125;</span><br><span class="line">productManager.createProductB = function () &#123;</span><br><span class="line">    console.log(&apos;ProductB&apos;);</span><br><span class="line">&#125;      </span><br><span class="line">productManager.factory = function (typeType) &#123;</span><br><span class="line">    return new productManager[typeType];</span><br><span class="line">&#125;</span><br><span class="line">productManager.factory(&quot;createProductA&quot;);</span><br></pre></td></tr></table></figure><p>如果还不理解的话，那我们就再详细一点咯，假如我们想在网页面里插入一些元素，而这些元素类型不固定，可能是图片，也有可能是连接，甚至可能是文本，根据工厂模式的定义，我们需要定义工厂类和相应的子类，我们先来定义子类的具体实现（也就是子函数）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var page = page || &#123;&#125;;</span><br><span class="line">page.dom = page.dom || &#123;&#125;;</span><br><span class="line">//子函数1：处理文本</span><br><span class="line">page.dom.Text = function () &#123;</span><br><span class="line">    this.insert = function (where) &#123;</span><br><span class="line">        var txt = document.createTextNode(this.url);</span><br><span class="line">        where.appendChild(txt);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">//子函数2：处理链接</span><br><span class="line">page.dom.Link = function () &#123;</span><br><span class="line">    this.insert = function (where) &#123;</span><br><span class="line">        var link = document.createElement(&apos;a&apos;);</span><br><span class="line">        link.href = this.url;</span><br><span class="line">        link.appendChild(document.createTextNode(this.url));</span><br><span class="line">        where.appendChild(link);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">//子函数3：处理图片</span><br><span class="line">page.dom.Image = function () &#123;</span><br><span class="line">    this.insert = function (where) &#123;</span><br><span class="line">        var im = document.createElement(&apos;img&apos;);</span><br><span class="line">        im.src = this.url;</span><br><span class="line">        where.appendChild(im);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么我们如何定义工厂处理函数呢？其实很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">page.dom.factory = function (type) &#123;</span><br><span class="line">    return new page.dom[type];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var o = page.dom.factory(&apos;Link&apos;);</span><br><span class="line">o.url = &apos;http://www.cnblogs.com&apos;;</span><br><span class="line">o.insert(document.body);</span><br></pre></td></tr></table></figure><p>至此，工厂模式的介绍相信大家都已经了然于心了，我就不再多叙述了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="什么时候使用工厂模式"><a href="#什么时候使用工厂模式" class="headerlink" title="什么时候使用工厂模式"></a>什么时候使用工厂模式</h3><p>以下几种情景下工厂模式特别有用：</p><ol><li>对象的构建十分复杂</li><li>需要依赖具体环境创建不同实例</li><li>处理大量具有相同属性的小对象</li></ol><h3 id="什么时候不该用工厂模式"><a href="#什么时候不该用工厂模式" class="headerlink" title="什么时候不该用工厂模式"></a>什么时候不该用工厂模式</h3><p>不滥用运用工厂模式，有时候仅仅只是给代码增加了不必要的复杂度，同时使得测试难以运行下去。</p><p>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与创建型模式类似，工厂模式创建对象（视为工厂里的产品）时无需指定创建对象的具体类。&lt;/p&gt;
&lt;p&gt;工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。&lt;/p&gt;
&lt;p&gt;这个模式十分有用，尤其是创建对象的流程赋值的时候，比如依赖于很多设置文件等。并且，你会经常在程序里看到工厂方法，用于让子类类定义需要创建的对象类型。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>S.O.L.I.D 五大原则之单一职责 SRP</title>
    <link href="http://xuhongbo.com/2016/04/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript/6S.O.L.I.D%20%E4%BA%94%E5%A4%A7%E5%8E%9F%E5%88%99%E4%B9%8B%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%20SRP/"/>
    <id>http://xuhongbo.com/2016/04/08/深入理解javascript/6S.O.L.I.D 五大原则之单一职责 SRP/</id>
    <published>2016-04-08T07:02:02.000Z</published>
    <updated>2017-03-02T17:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>Bob 大叔提出并发扬了 S.O.L.I.D 五大原则，用来更好地进行面向对象编程，五大原则分别是：</p><ol><li>The Single Responsibility Principle（单一职责 SRP）</li><li>The Open/Closed Principle（开闭原则 OCP）</li><li>The Liskov Substitution Principle（里氏替换原则 LSP）</li><li>The Interface Segregation Principle（接口分离原则 ISP）</li><li>The Dependency Inversion Principle（依赖反转原则 DIP）</li></ol><p>五大原则，我相信在博客园已经被讨论烂了，尤其是 C# 的实现，但是相对于 JavaScript 这种以原型为 base 的动态类型语言来说还为数不多，该系列将分 5 篇文章以 JavaScript 编程语言为基础来展示五大原则的应用。 OK，开始我们的第一篇：单一职责。<br><a id="more"></a></p><h2 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h2><p>单一职责的描述如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A class should have only one reason to change</span><br><span class="line">类发生更改的原因应该只有一个</span><br></pre></td></tr></table></figure><p>一个类（JavaScript 下应该是一个对象）应该有一组紧密相关的行为的意思是什么？遵守单一职责的好处是可以让我们很容易地来维护这个对象，当一个对象封装了很多职责的话，一旦一个职责需要修改，势必会影响该对象想的其它职责代码。通过解耦可以让每个职责工更加有弹性地变化。</p><p>不过，我们如何知道一个对象的多个行为构造多个职责还是单个职责？我们可以通过参考<a href="http://www.amazon.com/Object-Design-Roles-Responsibilities-Collaborations/dp/0201379430" target="_blank" rel="noopener">Object Design: Roles, Responsibilies, and Collaborations</a>一书提出的 Role Stereotypes 概念来决定，该书提出了如下 Role Stereotypes 来区分职责：</p><ol><li>Information holder – 该对象设计为存储对象并提供对象信息给其它对象。</li><li>Structurer – 该对象设计为维护对象和信息之间的关系</li><li>Service provider – 该对象设计为处理工作并提供服务给其它对象</li><li>Controller – 该对象设计为控制决策一系列负责的任务处理</li><li>Coordinator – 该对象不做任何决策处理工作，只是delegate工作到其它对象上</li><li>Interfacer – 该对象设计为在系统的各个部分转化信息（或请求）</li></ol><p>一旦你知道了这些概念，那就狠容易知道你的代码到底是多职责还是单一职责了。</p><h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><p>该实例代码演示的是将商品添加到购物车，代码非常糟糕，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function Product(id, description) &#123;</span><br><span class="line">    this.getId = function () &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;;</span><br><span class="line">    this.getDescription = function () &#123;</span><br><span class="line">        return description;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function Cart(eventAggregator) &#123;</span><br><span class="line">    var items = [];</span><br><span class="line">    this.addItem = function (item) &#123;</span><br><span class="line">        items.push(item);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">(function () &#123;</span><br><span class="line">    var products = [new Product(1, &quot;Star Wars Lego Ship&quot;),</span><br><span class="line">            new Product(2, &quot;Barbie Doll&quot;),</span><br><span class="line">            new Product(3, &quot;Remote Control Airplane&quot;)],</span><br><span class="line">cart = new Cart();</span><br><span class="line">    function addToCart() &#123;</span><br><span class="line">        var productId = $(this).attr(&apos;id&apos;);</span><br><span class="line">        var product = $.grep(products, function (x) &#123;</span><br><span class="line">            return x.getId() == productId;</span><br><span class="line">        &#125;)[0];</span><br><span class="line">        cart.addItem(product);</span><br><span class="line">        var newItem = $(&apos;&lt;li&gt;&lt;/li&gt;&apos;).html(product.getDescription()).attr(&apos;id-cart&apos;, product.getId()).appendTo(&quot;#cart&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    products.forEach(function (product) &#123;</span><br><span class="line">        var newItem = $(&apos;&lt;li&gt;&lt;/li&gt;&apos;).html(product.getDescription())</span><br><span class="line">                                    .attr(&apos;id&apos;, product.getId())</span><br><span class="line">                                    .dblclick(addToCart)</span><br><span class="line">                                    .appendTo(&quot;#products&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>该代码声明了 2 个 function 分别用来描述 product 和 cart，而匿名函数的职责是更新屏幕和用户交互，这还不是一个很复杂的例子，但匿名函数里却包含了很多不相关的职责，让我们来看看到底有多少职责：</p><ol><li>首先，有 product 的集合的声明</li><li>其次，有一个将 product 集合绑定到 #product 元素的代码，而且还附件了一个添加到购物车的事件处理</li><li>第三，有 Cart 购物车的展示功能</li><li>第四，有添加 product item 到购物车并显示的功能</li></ol><h2 id="重构代码"><a href="#重构代码" class="headerlink" title="重构代码"></a>重构代码</h2><p>让我们来分解一下，以便代码各自存放到各自的对象里，为此，我们参考了 martinfowler 的事件聚合（Event Aggregator）理论在处理代码以便各对象之间进行通信。</p><p>首先我们先来实现事件聚合的功能，该功能分为 2 部分，1 个是 Event，用于 Handler 回调的代码，1 个是 EventAggregator 用来订阅和发布 Event，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">function Event(name) &#123;</span><br><span class="line">    var handlers = [];</span><br><span class="line">    this.getName = function () &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;;</span><br><span class="line">    this.addHandler = function (handler) &#123;</span><br><span class="line">        handlers.push(handler);</span><br><span class="line">    &#125;;</span><br><span class="line">    this.removeHandler = function (handler) &#123;</span><br><span class="line">        for (var i = 0; i &lt; handlers.length; i++) &#123;</span><br><span class="line">            if (handlers[i] == handler) &#123;</span><br><span class="line">                handlers.splice(i, 1);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    this.fire = function (eventArgs) &#123;</span><br><span class="line">        handlers.forEach(function (h) &#123;</span><br><span class="line">            h(eventArgs);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function EventAggregator() &#123;</span><br><span class="line">    var events = [];</span><br><span class="line">    function getEvent(eventName) &#123;</span><br><span class="line">        return $.grep(events, function (event) &#123;</span><br><span class="line">            return event.getName() === eventName;</span><br><span class="line">        &#125;)[0];</span><br><span class="line">    &#125;</span><br><span class="line">    this.publish = function (eventName, eventArgs) &#123;</span><br><span class="line">        var event = getEvent(eventName);</span><br><span class="line">        if (!event) &#123;</span><br><span class="line">            event = new Event(eventName);</span><br><span class="line">            events.push(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.fire(eventArgs);</span><br><span class="line">    &#125;;</span><br><span class="line">    this.subscribe = function (eventName, handler) &#123;</span><br><span class="line">        var event = getEvent(eventName);</span><br><span class="line">        if (!event) &#123;</span><br><span class="line">            event = new Event(eventName);</span><br><span class="line">            events.push(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.addHandler(handler);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们来声明 Product 对象，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Product(id, description) &#123;</span><br><span class="line">    this.getId = function () &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;;</span><br><span class="line">    this.getDescription = function () &#123;</span><br><span class="line">        return description;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着来声明 Cart 对象，该对象的 addItem 的 function 里我们要触发发布一个事件 itemAdded，然后将 item 作为参数传进去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Cart(eventAggregator) &#123;</span><br><span class="line">    var items = [];</span><br><span class="line">    this.addItem = function (item) &#123;</span><br><span class="line">        items.push(item);</span><br><span class="line">        eventAggregator.publish(&quot;itemAdded&quot;, item);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CartController 主要是接受 cart 对象和事件聚合器，通过订阅 itemAdded 来增加一个 li 元素节点，通过订阅 productSelected 事件来添加 product。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function CartController(cart, eventAggregator) &#123;</span><br><span class="line">    eventAggregator.subscribe(&quot;itemAdded&quot;, function (eventArgs) &#123;</span><br><span class="line">        var newItem = $(&apos;&lt;li&gt;&lt;/li&gt;&apos;).html(eventArgs.getDescription()).attr(&apos;id-cart&apos;, eventArgs.getId()).appendTo(&quot;#cart&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    eventAggregator.subscribe(&quot;productSelected&quot;, function (eventArgs) &#123;</span><br><span class="line">        cart.addItem(eventArgs.product);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Repository 的目的是为了获取数据（可以从 ajax 里获取），然后暴露 get 数据的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function ProductRepository() &#123;</span><br><span class="line">    var products = [new Product(1, &quot;Star Wars Lego Ship&quot;),</span><br><span class="line">            new Product(2, &quot;Barbie Doll&quot;),</span><br><span class="line">            new Product(3, &quot;Remote Control Airplane&quot;)];</span><br><span class="line">    this.getProducts = function () &#123;</span><br><span class="line">        return products;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProductController 里定义了一个 onProductSelect 方法，主要是发布触发 productSelected 事件，forEach 主要是用于绑定数据到产品列表上，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function ProductController(eventAggregator, productRepository) &#123;</span><br><span class="line">    var products = productRepository.getProducts();</span><br><span class="line">    function onProductSelected() &#123;</span><br><span class="line">        var productId = $(this).attr(&apos;id&apos;);</span><br><span class="line">        var product = $.grep(products, function (x) &#123;</span><br><span class="line">            return x.getId() == productId;</span><br><span class="line">        &#125;)[0];</span><br><span class="line">        eventAggregator.publish(&quot;productSelected&quot;, &#123;</span><br><span class="line">            product: product</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    products.forEach(function (product) &#123;</span><br><span class="line">        var newItem = $(&apos;&lt;li&gt;&lt;/li&gt;&apos;).html(product.getDescription())</span><br><span class="line">                                    .attr(&apos;id&apos;, product.getId())</span><br><span class="line">                                    .dblclick(onProductSelected)</span><br><span class="line">                                    .appendTo(&quot;#products&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后声明匿名函数（需要确保 HTML 都加载完了才能执行这段代码，比如放在 jQuery 的 ready 方法里）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">    var eventAggregator = new EventAggregator(),</span><br><span class="line">cart = new Cart(eventAggregator),</span><br><span class="line">cartController = new CartController(cart, eventAggregator),</span><br><span class="line">productRepository = new ProductRepository(),</span><br><span class="line">productController = new ProductController(eventAggregator, productRepository);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>可以看到匿名函数的代码减少了很多，主要是一个对象的实例化代码，代码里我们介绍了 Controller 的概念，他接受信息然后传递到 action，我们也介绍了 Repository 的概念，主要是用来处理 product 的展示，重构的结果就是写了一大堆的对象声明，但是好处是每个对象有了自己明确的职责，该展示数据的展示数据，改处理集合的处理集合，这样耦合度就非常低了。</p><p>最终代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">function Event(name) &#123;</span><br><span class="line">    var handlers = [];</span><br><span class="line">    this.getName = function () &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;;</span><br><span class="line">    this.addHandler = function (handler) &#123;</span><br><span class="line">        handlers.push(handler);</span><br><span class="line">    &#125;;</span><br><span class="line">    this.removeHandler = function (handler) &#123;</span><br><span class="line">        for (var i = 0; i &lt; handlers.length; i++) &#123;</span><br><span class="line">            if (handlers[i] == handler) &#123;</span><br><span class="line">                handlers.splice(i, 1);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    this.fire = function (eventArgs) &#123;</span><br><span class="line">        handlers.forEach(function (h) &#123;</span><br><span class="line">            h(eventArgs);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function EventAggregator() &#123;</span><br><span class="line">    var events = [];</span><br><span class="line">    function getEvent(eventName) &#123;</span><br><span class="line">        return $.grep(events, function (event) &#123;</span><br><span class="line">            return event.getName() === eventName;</span><br><span class="line">        &#125;)[0];</span><br><span class="line">    &#125;</span><br><span class="line">    this.publish = function (eventName, eventArgs) &#123;</span><br><span class="line">        var event = getEvent(eventName);</span><br><span class="line">        if (!event) &#123;</span><br><span class="line">            event = new Event(eventName);</span><br><span class="line">            events.push(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.fire(eventArgs);</span><br><span class="line">    &#125;;</span><br><span class="line">    this.subscribe = function (eventName, handler) &#123;</span><br><span class="line">        var event = getEvent(eventName);</span><br><span class="line">        if (!event) &#123;</span><br><span class="line">            event = new Event(eventName);</span><br><span class="line">            events.push(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.addHandler(handler);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function Product(id, description) &#123;</span><br><span class="line">    this.getId = function () &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;;</span><br><span class="line">    this.getDescription = function () &#123;</span><br><span class="line">        return description;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function Cart(eventAggregator) &#123;</span><br><span class="line">    var items = [];</span><br><span class="line">    this.addItem = function (item) &#123;</span><br><span class="line">        items.push(item);</span><br><span class="line">        eventAggregator.publish(&quot;itemAdded&quot;, item);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function CartController(cart, eventAggregator) &#123;</span><br><span class="line">    eventAggregator.subscribe(&quot;itemAdded&quot;, function (eventArgs) &#123;</span><br><span class="line">        var newItem = $(&apos;&lt;li&gt;&lt;/li&gt;&apos;).html(eventArgs.getDescription()).attr(&apos;id-cart&apos;, eventArgs.getId()).appendTo(&quot;#cart&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    eventAggregator.subscribe(&quot;productSelected&quot;, function (eventArgs) &#123;</span><br><span class="line">        cart.addItem(eventArgs.product);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">function ProductRepository() &#123;</span><br><span class="line">    var products = [new Product(1, &quot;Star Wars Lego Ship&quot;),</span><br><span class="line">    new Product(2, &quot;Barbie Doll&quot;),</span><br><span class="line">    new Product(3, &quot;Remote Control Airplane&quot;)];</span><br><span class="line">    this.getProducts = function () &#123;</span><br><span class="line">        return products;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function ProductController(eventAggregator, productRepository) &#123;</span><br><span class="line">    var products = productRepository.getProducts();</span><br><span class="line">    function onProductSelected() &#123;</span><br><span class="line">        var productId = $(this).attr(&apos;id&apos;);</span><br><span class="line">        var product = $.grep(products, function (x) &#123;</span><br><span class="line">            return x.getId() == productId;</span><br><span class="line">        &#125;)[0];</span><br><span class="line">        eventAggregator.publish(&quot;productSelected&quot;, &#123;</span><br><span class="line">            product: product</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    products.forEach(function (product) &#123;</span><br><span class="line">        var newItem = $(&apos;&lt;li&gt;&lt;/li&gt;&apos;).html(product.getDescription())</span><br><span class="line">                            .attr(&apos;id&apos;, product.getId())</span><br><span class="line">                            .dblclick(onProductSelected)</span><br><span class="line">                            .appendTo(&quot;#products&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">(function () &#123;</span><br><span class="line">    var eventAggregator = new EventAggregator(),</span><br><span class="line">        cart = new Cart(eventAggregator),</span><br><span class="line">        cartController = new CartController(cart, eventAggregator),</span><br><span class="line">        productRepository = new ProductRepository(),</span><br><span class="line">        productController = new ProductController(eventAggregator, productRepository);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你的项目是个是个非常小的项目，代码也不是很多，那其实是没有必要重构得这么复杂，但如果你的项目是个很复杂的大型项目，或者你的小项目将来可能增长得很快的话，那就在前期就得考虑 SRP 原则进行职责分离了，这样才有利于以后的维护。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Bob 大叔提出并发扬了 S.O.L.I.D 五大原则，用来更好地进行面向对象编程，五大原则分别是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The Single Responsibility Principle（单一职责 SRP）&lt;/li&gt;
&lt;li&gt;The Open/Closed Principle（开闭原则 OCP）&lt;/li&gt;
&lt;li&gt;The Liskov Substitution Principle（里氏替换原则 LSP）&lt;/li&gt;
&lt;li&gt;The Interface Segregation Principle（接口分离原则 ISP）&lt;/li&gt;
&lt;li&gt;The Dependency Inversion Principle（依赖反转原则 DIP）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;五大原则，我相信在博客园已经被讨论烂了，尤其是 C# 的实现，但是相对于 JavaScript 这种以原型为 base 的动态类型语言来说还为数不多，该系列将分 5 篇文章以 JavaScript 编程语言为基础来展示五大原则的应用。 OK，开始我们的第一篇：单一职责。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
